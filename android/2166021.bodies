class Parcel
!!!14680709.cpp!!!	Parcel()
    LOG_ALLOC("Parcel %p: constructing", this);
    initState();
!!!14680837.cpp!!!	~Parcel()
    freeDataNoInit();
    LOG_ALLOC("Parcel %p: destroyed", this);
!!!14680965.cpp!!!	data() : uint8_t
    return mData;
!!!14681093.cpp!!!	dataSize() : size_t
    return (mDataSize > mDataPos ? mDataSize : mDataPos);
!!!14681221.cpp!!!	dataAvail() : size_t
    size_t result = dataSize() - dataPosition();
    if (result > INT32_MAX) {
        abort();
    }
    return result;
!!!14681349.cpp!!!	dataPosition() : size_t
    return mDataPos;
!!!14681477.cpp!!!	dataCapacity() : size_t
    return mDataCapacity;
!!!14681605.cpp!!!	setDataSize(in size : size_t) : status_t
    if (size > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    status_t err;
    err = continueWrite(size);
    if (err == NO_ERROR) {
        mDataSize = size;
        ALOGV("setDataSize Setting data size of %p to %zu", this, mDataSize);
    }
    return err;
!!!14681733.cpp!!!	setDataPosition(in pos : size_t) : void
    if (pos > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        abort();
    }

    mDataPos = pos;
    mNextObjectHint = 0;
!!!14681861.cpp!!!	setDataCapacity(in size : size_t) : status_t
    if (size > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    if (size > mDataCapacity) return continueWrite(size);
    return NO_ERROR;
!!!14681989.cpp!!!	setData(in buffer : uint8_t, in len : size_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    status_t err = restartWrite(len);
    if (err == NO_ERROR) {
        memcpy(const_cast<uint8_t*>(data()), buffer, len);
        mDataSize = len;
        mFdsKnown = false;
    }
    return err;
!!!14682117.cpp!!!	appendFrom(in parcel : Parcel, in offset : size_t, in len : size_t) : status_t
    const sp<ProcessState> proc(ProcessState::self());
    status_t err;
    const uint8_t *data = parcel->mData;
    const binder_size_t *objects = parcel->mObjects;
    size_t size = parcel->mObjectsSize;
    int startPos = mDataPos;
    int firstIndex = -1, lastIndex = -2;

    if (len == 0) {
        return NO_ERROR;
    }

    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    // range checks against the source parcel size
    if ((offset > parcel->mDataSize)
            || (len > parcel->mDataSize)
            || (offset + len > parcel->mDataSize)) {
        return BAD_VALUE;
    }

    // Count objects in range
    for (int i = 0; i < (int) size; i++) {
        size_t off = objects[i];
        if ((off >= offset) && (off + sizeof(flat_binder_object) <= offset + len)) {
            if (firstIndex == -1) {
                firstIndex = i;
            }
            lastIndex = i;
        }
    }
    int numObjects = lastIndex - firstIndex + 1;

    if ((mDataSize+len) > mDataCapacity) {
        // grow data
        err = growData(len);
        if (err != NO_ERROR) {
            return err;
        }
    }

    // append data
    memcpy(mData + mDataPos, data + offset, len);
    mDataPos += len;
    mDataSize += len;

    err = NO_ERROR;

    if (numObjects > 0) {
        // grow objects
        if (mObjectsCapacity < mObjectsSize + numObjects) {
            size_t newSize = ((mObjectsSize + numObjects)*3)/2;
            if (newSize*sizeof(binder_size_t) < mObjectsSize) return NO_MEMORY;   // overflow
            binder_size_t *objects =
                (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
            if (objects == (binder_size_t*)0) {
                return NO_MEMORY;
            }
            mObjects = objects;
            mObjectsCapacity = newSize;
        }

        // append and acquire objects
        int idx = mObjectsSize;
        for (int i = firstIndex; i <= lastIndex; i++) {
            size_t off = objects[i] - offset + startPos;
            mObjects[idx++] = off;
            mObjectsSize++;

            flat_binder_object* flat
                = reinterpret_cast<flat_binder_object*>(mData + off);
            acquire_object(proc, *flat, this, &mOpenAshmemSize);

            if (flat->type == BINDER_TYPE_FD) {
                // If this is a file descriptor, we need to dup it so the
                // new Parcel now owns its own fd, and can declare that we
                // officially know we have fds.
                flat->handle = fcntl(flat->handle, F_DUPFD_CLOEXEC, 0);
                flat->cookie = 1;
                mHasFds = mFdsKnown = true;
                if (!mAllowFds) {
                    err = FDS_NOT_ALLOWED;
                }
            }
        }
    }

    return err;
!!!14682245.cpp!!!	compareData(in other : Parcel) : int
    size_t size = dataSize();
    if (size != other.dataSize()) {
        return size < other.dataSize() ? -1 : 1;
    }
    return memcmp(data(), other.data(), size);
!!!14682373.cpp!!!	allowFds() : bool
    return mAllowFds;
!!!14682501.cpp!!!	pushAllowFds(in allowFds : bool) : bool
    const bool origValue = mAllowFds;
    if (!allowFds) {
        mAllowFds = false;
    }
    return origValue;
!!!14682629.cpp!!!	restoreAllowFds(in lastValue : bool) : void
    mAllowFds = lastValue;
!!!14682757.cpp!!!	hasFileDescriptors() : bool
    if (!mFdsKnown) {
        scanForFds();
    }
    return mHasFds;
!!!14682885.cpp!!!	writeInterfaceToken(in interface : String16) : status_t
    writeInt32(IPCThreadState::self()->getStrictModePolicy() |
               STRICT_MODE_PENALTY_GATHER);
    // currently the interface identification token is just its name as a string
    return writeString16(interface);
!!!14683013.cpp!!!	enforceInterface(in interface : String16, inout threadState : IPCThreadState = NULL) : bool
    int32_t strictPolicy = readInt32();
    if (threadState == NULL) {
        threadState = IPCThreadState::self();
    }
    if ((threadState->getLastTransactionBinderFlags() &
         IBinder::FLAG_ONEWAY) != 0) {
      // For one-way calls, the callee is running entirely
      // disconnected from the caller, so disable StrictMode entirely.
      // Not only does disk/network usage not impact the caller, but
      // there's no way to commuicate back any violations anyway.
      threadState->setStrictModePolicy(0);
    } else {
      threadState->setStrictModePolicy(strictPolicy);
    }
    const String16 str(readString16());
    if (str == interface) {
        return true;
    } else {
        ALOGW("**** enforceInterface() expected '%s' but read '%s'",
                String8(interface).string(), String8(str).string());
        return false;
    }
!!!14683141.cpp!!!	checkInterface(inout binder : IBinder) : bool
    return enforceInterface(binder->getInterfaceDescriptor());
!!!14683269.cpp!!!	freeData() : void
    freeDataNoInit();
    initState();
!!!14683397.cpp!!!	objects() : binder_size_t
    return mObjects;
!!!14683525.cpp!!!	objectsCount() : size_t
    return mObjectsSize;
!!!14683653.cpp!!!	errorCheck() : status_t
    return mError;
!!!14683781.cpp!!!	setError(in err : status_t) : void
    mError = err;
!!!14683909.cpp!!!	write(in data : void, in len : size_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    void* const d = writeInplace(len);
    if (d) {
        memcpy(d, data, len);
        return NO_ERROR;
    }
    return mError;
!!!14684037.cpp!!!	writeInplace(in len : size_t) : void
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return NULL;
    }

    const size_t padded = pad_size(len);

    // sanity check for integer overflow
    if (mDataPos+padded < mDataPos) {
        return NULL;
    }

    if ((mDataPos+padded) <= mDataCapacity) {
restart_write:
        //printf("Writing %ld bytes, padded to %ld\n", len, padded);
        uint8_t* const data = mData+mDataPos;

        // Need to pad at end?
        if (padded != len) {
#if BYTE_ORDER == BIG_ENDIAN
            static const uint32_t mask[4] = {
                0x00000000, 0xffffff00, 0xffff0000, 0xff000000
            };
#endif
#if BYTE_ORDER == LITTLE_ENDIAN
            static const uint32_t mask[4] = {
                0x00000000, 0x00ffffff, 0x0000ffff, 0x000000ff
            };
#endif
            //printf("Applying pad mask: %p to %p\n", (void*)mask[padded-len],
            //    *reinterpret_cast<void**>(data+padded-4));
            *reinterpret_cast<uint32_t*>(data+padded-4) &= mask[padded-len];
        }

        finishWrite(padded);
        return data;
    }

    status_t err = growData(padded);
    if (err == NO_ERROR) goto restart_write;
    return NULL;
!!!14684165.cpp!!!	writeUnpadded(in data : void, in len : size_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    size_t end = mDataPos + len;
    if (end < mDataPos) {
        // integer overflow
        return BAD_VALUE;
    }

    if (end <= mDataCapacity) {
restart_write:
        memcpy(mData+mDataPos, data, len);
        return finishWrite(len);
    }

    status_t err = growData(len);
    if (err == NO_ERROR) goto restart_write;
    return err;
!!!14684293.cpp!!!	writeInt32(in val : int32_t) : status_t
    return writeAligned(val);
!!!14684421.cpp!!!	writeUint32(in val : uint32_t) : status_t
    return writeAligned(val);
!!!14684549.cpp!!!	writeInt64(in val : int64_t) : status_t
    return writeAligned(val);
!!!14684677.cpp!!!	writeUint64(in val : uint64_t) : status_t
    return writeAligned(val);
!!!14684805.cpp!!!	writeFloat(in val : float) : status_t
    return writeAligned(val);
!!!14684933.cpp!!!	writeDouble(in val : double) : status_t
    return writeAligned(val);
!!!14685061.cpp!!!	writeCString(in str : char) : status_t
    return write(str, strlen(str)+1);
!!!14685189.cpp!!!	writeString8(in str : String8) : status_t
    status_t err = writeInt32(str.bytes());
    // only write string if its length is more than zero characters,
    // as readString8 will only read if the length field is non-zero.
    // this is slightly different from how writeString16 works.
    if (str.bytes() > 0 && err == NO_ERROR) {
        err = write(str.string(), str.bytes()+1);
    }
    return err;
!!!14685317.cpp!!!	writeString16(in str : String16) : status_t
    return writeString16(str.string(), str.size());
!!!14685445.cpp!!!	writeString16(in str : std::unique_ptr<String16>) : status_t
    if (!str) {
        return writeInt32(-1);
    }

    return writeString16(*str);
!!!14685573.cpp!!!	writeString16(in str : char16_t, in len : size_t) : status_t
    if (str == NULL) return writeInt32(-1);

    status_t err = writeInt32(len);
    if (err == NO_ERROR) {
        len *= sizeof(char16_t);
        uint8_t* data = (uint8_t*)writeInplace(len+sizeof(char16_t));
        if (data) {
            memcpy(data, str, len);
            *reinterpret_cast<char16_t*>(data+len) = 0;
            return NO_ERROR;
        }
        err = mError;
    }
    return err;
!!!14685701.cpp!!!	writeStrongBinder(in val : sp<IBinder>) : status_t
    return flatten_binder(ProcessState::self(), val, this);
!!!14685829.cpp!!!	writeWeakBinder(in val : wp<IBinder>) : status_t
    return flatten_binder(ProcessState::self(), val, this);
!!!14685957.cpp!!!	writeInt32Array(in len : size_t, in val : int32_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    if (!val) {
        return writeInt32(-1);
    }
    status_t ret = writeInt32(static_cast<uint32_t>(len));
    if (ret == NO_ERROR) {
        ret = write(val, len * sizeof(*val));
    }
    return ret;
!!!14686085.cpp!!!	writeByteArray(in len : size_t, in val : uint8_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    if (!val) {
        return writeInt32(-1);
    }
    status_t ret = writeInt32(static_cast<uint32_t>(len));
    if (ret == NO_ERROR) {
        ret = write(val, len * sizeof(*val));
    }
    return ret;
!!!14686213.cpp!!!	writeBool(in val : bool) : status_t
    return writeInt32(int32_t(val));
!!!14686341.cpp!!!	writeChar(in val : char16_t) : status_t
    return writeInt32(int32_t(val));
!!!14686469.cpp!!!	writeByte(in val : int8_t) : status_t
    return writeInt32(int32_t(val));
!!!14686597.cpp!!!	writeUtf8AsUtf16(in str : std::string) : status_t
    const uint8_t* strData = (uint8_t*)str.data();
    const size_t strLen= str.length();
    const ssize_t utf16Len = utf8_to_utf16_length(strData, strLen);
    if (utf16Len < 0 || utf16Len > std::numeric_limits<int32_t>::max()) {
        return BAD_VALUE;
    }

    status_t err = writeInt32(utf16Len);
    if (err) {
        return err;
    }

    // Allocate enough bytes to hold our converted string and its terminating NULL.
    void* dst = writeInplace((utf16Len + 1) * sizeof(char16_t));
    if (!dst) {
        return NO_MEMORY;
    }

    utf8_to_utf16(strData, strLen, (char16_t*)dst, (size_t) utf16Len + 1);

    return NO_ERROR;
!!!14686725.cpp!!!	writeUtf8AsUtf16(in str : std::unique_ptr<std::string>) : status_t
  if (!str) {
    return writeInt32(-1);
  }
  return writeUtf8AsUtf16(*str);
!!!14686853.cpp!!!	writeByteVector(in val : std::unique_ptr<std::vector<int8_t>>) : status_t
    return writeByteVectorInternalPtr(this, val);
!!!14686981.cpp!!!	writeByteVector(in val : std::vector<int8_t>) : status_t
    return writeByteVectorInternal(this, val);
!!!14687109.cpp!!!	writeByteVector(in val : std::unique_ptr<std::vector<uint8_t>>) : status_t
    return writeByteVectorInternalPtr(this, val);
!!!14687237.cpp!!!	writeByteVector(in val : std::vector<uint8_t>) : status_t
    return writeByteVectorInternal(this, val);
!!!14687365.cpp!!!	writeInt32Vector(in val : std::unique_ptr<std::vector<int32_t>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeInt32);
!!!14687493.cpp!!!	writeInt32Vector(in val : std::vector<int32_t>) : status_t
    return writeTypedVector(val, &Parcel::writeInt32);
!!!14687621.cpp!!!	writeInt64Vector(in val : std::unique_ptr<std::vector<int64_t>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeInt64);
!!!14687749.cpp!!!	writeInt64Vector(in val : std::vector<int64_t>) : status_t
    return writeTypedVector(val, &Parcel::writeInt64);
!!!14687877.cpp!!!	writeFloatVector(in val : std::unique_ptr<std::vector<float>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeFloat);
!!!14688005.cpp!!!	writeFloatVector(in val : std::vector<float>) : status_t
    return writeTypedVector(val, &Parcel::writeFloat);
!!!14688133.cpp!!!	writeDoubleVector(in val : std::unique_ptr<std::vector<double>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeDouble);
!!!14688261.cpp!!!	writeDoubleVector(in val : std::vector<double>) : status_t
    return writeTypedVector(val, &Parcel::writeDouble);
!!!14688389.cpp!!!	writeBoolVector(in val : std::unique_ptr<std::vector<bool>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeBool);
!!!14688517.cpp!!!	writeBoolVector(in val : std::vector<bool>) : status_t
    return writeTypedVector(val, &Parcel::writeBool);
!!!14688645.cpp!!!	writeCharVector(in val : std::unique_ptr<std::vector<char16_t>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeChar);
!!!14688773.cpp!!!	writeCharVector(in val : std::vector<char16_t>) : status_t
    return writeTypedVector(val, &Parcel::writeChar);
!!!14688901.cpp!!!	writeString16Vector(in val : std::unique_ptr<std::vector<std::unique_ptr<String16>>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeString16);
!!!14689029.cpp!!!	writeString16Vector(in val : std::vector<String16>) : status_t
    return writeTypedVector(val, &Parcel::writeString16);
!!!14689157.cpp!!!	writeUtf8VectorAsUtf16Vector(in val : std::unique_ptr<std::vector<std::unique_ptr<std::string>>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeUtf8AsUtf16);
!!!14689285.cpp!!!	writeUtf8VectorAsUtf16Vector(in val : std::vector<std::string>) : status_t
    return writeTypedVector(val, &Parcel::writeUtf8AsUtf16);
!!!14689413.cpp!!!	writeStrongBinderVector(in val : std::unique_ptr<std::vector<sp<IBinder>>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeStrongBinder);
!!!14689541.cpp!!!	writeStrongBinderVector(in val : std::vector<sp<IBinder>>) : status_t
    return writeTypedVector(val, &Parcel::writeStrongBinder);
!!!14689669.cpp!!!	writeParcelableVector(in val : std::unique_ptr<std::vector<std::unique_ptr<T>>>) : status_t
    if (val.get() == nullptr) {
        return this->writeInt32(-1);
    }

    return unsafeWriteTypedVector(*val, &Parcel::writeNullableParcelable<T>);
!!!14689797.cpp!!!	writeParcelableVector(in val : std::shared_ptr<std::vector<std::unique_ptr<T>>>) : status_t
    if (val.get() == nullptr) {
        return this->writeInt32(-1);
    }

    return unsafeWriteTypedVector(*val, &Parcel::writeNullableParcelable<T>);
!!!14689925.cpp!!!	writeParcelableVector(in val : std::vector<T>) : status_t
    return unsafeWriteTypedVector<T,const Parcelable&>(val, &Parcel::writeParcelable);
!!!14690053.cpp!!!	writeNullableParcelable(in parcelable : std::unique_ptr<T>) : status_t
    return writeRawNullableParcelable(parcelable.get());
!!!14690181.cpp!!!	writeParcelable(in parcelable : Parcelable) : status_t
    status_t status = writeInt32(1);  // parcelable is not null.
    if (status != OK) {
        return status;
    }
    return parcelable.writeToParcel(this);
!!!14690309.cpp!!!	writeValue(in value : Value) : status_t
    return value.writeToParcel(this);
!!!14690437.cpp!!!	write(in val : Flattenable<T>) : status_t
    const FlattenableHelper<T> helper(val);
    return write(helper);
!!!14690565.cpp!!!	write(in val : LightFlattenable<T>) : status_t
    size_t size(val.getFlattenedSize());
    if (!val.isFixedSize()) {
        if (size > INT32_MAX) {
            return BAD_VALUE;
        }
        status_t err = writeInt32(static_cast<int32_t>(size));
        if (err != NO_ERROR) {
            return err;
        }
    }
    if (size) {
        void* buffer = writeInplace(size);
        if (buffer == NULL)
            return NO_MEMORY;
        return val.flatten(buffer, size);
    }
    return NO_ERROR;
!!!14690693.cpp!!!	writeVectorSize(in val : std::vector<T>) : status_t
    if (val.size() > INT32_MAX) {
        return BAD_VALUE;
    }
    return writeInt32(static_cast<int32_t>(val.size()));
!!!14690821.cpp!!!	writeVectorSize(in val : std::unique_ptr<std::vector<T>>) : status_t
    if (!val) {
        return writeInt32(-1);
    }

    return writeVectorSize(*val);
!!!14690949.cpp!!!	writeMap(in map_in : Map) : status_t
    using ::std::map;
    using ::android::binder::Value;
    using ::android::binder::Map;

    Map::const_iterator iter;
    status_t ret;

    ret = writeInt32(map_in.size());

    if (ret != NO_ERROR) {
        return ret;
    }

    for (iter = map_in.begin(); iter != map_in.end(); ++iter) {
        ret = writeValue(Value(iter->first));
        if (ret != NO_ERROR) {
            return ret;
        }

        ret = writeValue(iter->second);
        if (ret != NO_ERROR) {
            return ret;
        }
    }

    return ret;
!!!14691077.cpp!!!	writeNullableMap(in map : std::unique_ptr<binder::Map>) : status_t
    if (map == NULL) {
        return writeInt32(-1);
    }

    return writeMap(*map.get());
!!!14691205.cpp!!!	writeNativeHandle(in handle : native_handle) : status_t
    if (!handle || handle->version != sizeof(native_handle))
        return BAD_TYPE;

    status_t err;
    err = writeInt32(handle->numFds);
    if (err != NO_ERROR) return err;

    err = writeInt32(handle->numInts);
    if (err != NO_ERROR) return err;

    for (int i=0 ; err==NO_ERROR && i<handle->numFds ; i++)
        err = writeDupFileDescriptor(handle->data[i]);

    if (err != NO_ERROR) {
        ALOGD("write native handle, write dup fd failed");
        return err;
    }
    err = write(handle->data + handle->numFds, sizeof(int)*handle->numInts);
    return err;
!!!14691333.cpp!!!	writeFileDescriptor(in fd : int, in takeOwnership : bool = false) : status_t
    flat_binder_object obj;
    obj.type = BINDER_TYPE_FD;
    obj.flags = 0x7f | FLAT_BINDER_FLAG_ACCEPTS_FDS;
    obj.binder = 0; /* Don't pass uninitialized stack data to a remote process */
    obj.handle = fd;
    obj.cookie = takeOwnership ? 1 : 0;
    return writeObject(obj, true);
!!!14691461.cpp!!!	writeDupFileDescriptor(in fd : int) : status_t
    int dupFd = fcntl(fd, F_DUPFD_CLOEXEC, 0);
    if (dupFd < 0) {
        return -errno;
    }
    status_t err = writeFileDescriptor(dupFd, true /*takeOwnership*/);
    if (err != OK) {
        close(dupFd);
    }
    return err;
!!!14691589.cpp!!!	writeParcelFileDescriptor(in fd : int, in takeOwnership : bool = false) : status_t
    writeInt32(0);
    return writeFileDescriptor(fd, takeOwnership);
!!!14691717.cpp!!!	writeUniqueFileDescriptor(in fd : base::unique_fd) : status_t
    return writeDupFileDescriptor(fd.get());
!!!14691845.cpp!!!	writeUniqueFileDescriptorVector(in val : std::unique_ptr<std::vector<base::unique_fd>>) : status_t
    return writeNullableTypedVector(val, &Parcel::writeUniqueFileDescriptor);
!!!14691973.cpp!!!	writeUniqueFileDescriptorVector(in val : std::vector<base::unique_fd>) : status_t
    return writeTypedVector(val, &Parcel::writeUniqueFileDescriptor);
!!!14692101.cpp!!!	writeBlob(in len : size_t, in mutableCopy : bool, inout outBlob : Parcel::WritableBlob) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    status_t status;
    if (!mAllowFds || len <= BLOB_INPLACE_LIMIT) {
        ALOGV("writeBlob: write in place");
        status = writeInt32(BLOB_INPLACE);
        if (status) return status;

        void* ptr = writeInplace(len);
        if (!ptr) return NO_MEMORY;

        outBlob->init(-1, ptr, len, false);
        return NO_ERROR;
    }

    ALOGV("writeBlob: write to ashmem");
    int fd = ashmem_create_region("Parcel Blob", len);
    if (fd < 0) return NO_MEMORY;

    int result = ashmem_set_prot_region(fd, PROT_READ | PROT_WRITE);
    if (result < 0) {
        status = result;
    } else {
        void* ptr = ::mmap(NULL, len, PROT_READ | PROT_WRITE, MAP_SHARED, fd, 0);
        if (ptr == MAP_FAILED) {
            status = -errno;
        } else {
            if (!mutableCopy) {
                result = ashmem_set_prot_region(fd, PROT_READ);
            }
            if (result < 0) {
                status = result;
            } else {
                status = writeInt32(mutableCopy ? BLOB_ASHMEM_MUTABLE : BLOB_ASHMEM_IMMUTABLE);
                if (!status) {
                    status = writeFileDescriptor(fd, true /*takeOwnership*/);
                    if (!status) {
                        outBlob->init(fd, ptr, len, mutableCopy);
                        return NO_ERROR;
                    }
                }
            }
        }
        ::munmap(ptr, len);
    }
    ::close(fd);
    return status;
!!!14692229.cpp!!!	writeDupImmutableBlobFileDescriptor(in fd : int) : status_t
    // Must match up with what's done in writeBlob.
    if (!mAllowFds) return FDS_NOT_ALLOWED;
    status_t status = writeInt32(BLOB_ASHMEM_IMMUTABLE);
    if (status) return status;
    return writeDupFileDescriptor(fd);
!!!14692357.cpp!!!	writeObject(in val : flat_binder_object, in nullMetaData : bool) : status_t
    const bool enoughData = (mDataPos+sizeof(val)) <= mDataCapacity;
    const bool enoughObjects = mObjectsSize < mObjectsCapacity;
    if (enoughData && enoughObjects) {
restart_write:
        *reinterpret_cast<flat_binder_object*>(mData+mDataPos) = val;

        // remember if it's a file descriptor
        if (val.type == BINDER_TYPE_FD) {
            if (!mAllowFds) {
                // fail before modifying our object index
                return FDS_NOT_ALLOWED;
            }
            mHasFds = mFdsKnown = true;
        }

        // Need to write meta-data?
        if (nullMetaData || val.binder != 0) {
            mObjects[mObjectsSize] = mDataPos;
            acquire_object(ProcessState::self(), val, this, &mOpenAshmemSize);
            mObjectsSize++;
        }

        return finishWrite(sizeof(flat_binder_object));
    }

    if (!enoughData) {
        const status_t err = growData(sizeof(val));
        if (err != NO_ERROR) return err;
    }
    if (!enoughObjects) {
        size_t newSize = ((mObjectsSize+2)*3)/2;
        if (newSize*sizeof(binder_size_t) < mObjectsSize) return NO_MEMORY;   // overflow
        binder_size_t* objects = (binder_size_t*)realloc(mObjects, newSize*sizeof(binder_size_t));
        if (objects == NULL) return NO_MEMORY;
        mObjects = objects;
        mObjectsCapacity = newSize;
    }

    goto restart_write;
!!!14692485.cpp!!!	writeNoException() : status_t
    binder::Status status;
    return status.writeToParcel(this);
!!!14692613.cpp!!!	remove(in start : size_t, in amt : size_t) : void
    LOG_ALWAYS_FATAL("Parcel::remove() not yet implemented!");
!!!14692741.cpp!!!	read(inout outData : void, in len : size_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize
            && len <= pad_size(len)) {
        memcpy(outData, mData+mDataPos, len);
        mDataPos += pad_size(len);
        ALOGV("read Setting data pos of %p to %zu", this, mDataPos);
        return NO_ERROR;
    }
    return NOT_ENOUGH_DATA;
!!!14692869.cpp!!!	readInplace(in len : size_t) : void
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return NULL;
    }

    if ((mDataPos+pad_size(len)) >= mDataPos && (mDataPos+pad_size(len)) <= mDataSize
            && len <= pad_size(len)) {
        const void* data = mData+mDataPos;
        mDataPos += pad_size(len);
        ALOGV("readInplace Setting data pos of %p to %zu", this, mDataPos);
        return data;
    }
    return NULL;
!!!14692997.cpp!!!	readInt32() : int32_t
    return readAligned<int32_t>();
!!!14693125.cpp!!!	readInt32(inout pArg : int32_t) : status_t
    return readAligned(pArg);
!!!14693253.cpp!!!	readUint32() : uint32_t
    return readAligned<uint32_t>();
!!!14693381.cpp!!!	readUint32(inout pArg : uint32_t) : status_t
    return readAligned(pArg);
!!!14693509.cpp!!!	readInt64() : int64_t
    return readAligned<int64_t>();
!!!14693637.cpp!!!	readInt64(inout pArg : int64_t) : status_t
    return readAligned(pArg);
!!!14693765.cpp!!!	readUint64() : uint64_t
    return readAligned<uint64_t>();
!!!14693893.cpp!!!	readUint64(inout pArg : uint64_t) : status_t
    return readAligned(pArg);
!!!14694021.cpp!!!	readFloat() : float
    return readAligned<float>();
!!!14694149.cpp!!!	readFloat(inout pArg : float) : status_t
    return readAligned(pArg);
!!!14694277.cpp!!!	readDouble() : double
    return readAligned<double>();
!!!14694405.cpp!!!	readDouble(inout pArg : double) : status_t
    return readAligned(pArg);
!!!14694533.cpp!!!	readIntPtr() : intptr_t
    return readAligned<intptr_t>();
!!!14694661.cpp!!!	readIntPtr(inout pArg : intptr_t) : status_t
    return readAligned(pArg);
!!!14694789.cpp!!!	readBool() : bool
    return readInt32() != 0;
!!!14694917.cpp!!!	readBool(inout pArg : bool) : status_t
    int32_t tmp;
    status_t ret = readInt32(&tmp);
    *pArg = (tmp != 0);
    return ret;
!!!14695045.cpp!!!	readChar() : char16_t
    return char16_t(readInt32());
!!!14695173.cpp!!!	readChar(inout pArg : char16_t) : status_t
    int32_t tmp;
    status_t ret = readInt32(&tmp);
    *pArg = char16_t(tmp);
    return ret;
!!!14695301.cpp!!!	readByte() : int8_t
    return int8_t(readInt32());
!!!14695429.cpp!!!	readByte(inout pArg : int8_t) : status_t
    int32_t tmp;
    status_t ret = readInt32(&tmp);
    *pArg = int8_t(tmp);
    return ret;
!!!14695557.cpp!!!	readUtf8FromUtf16(inout str : std::string) : status_t
    size_t utf16Size = 0;
    const char16_t* src = readString16Inplace(&utf16Size);
    if (!src) {
        return UNEXPECTED_NULL;
    }

    // Save ourselves the trouble, we're done.
    if (utf16Size == 0u) {
        str->clear();
       return NO_ERROR;
    }

    // Allow for closing '\0'
    ssize_t utf8Size = utf16_to_utf8_length(src, utf16Size) + 1;
    if (utf8Size < 1) {
        return BAD_VALUE;
    }
    // Note that while it is probably safe to assume string::resize keeps a
    // spare byte around for the trailing null, we still pass the size including the trailing null
    str->resize(utf8Size);
    utf16_to_utf8(src, utf16Size, &((*str)[0]), utf8Size);
    str->resize(utf8Size - 1);
    return NO_ERROR;
!!!14695685.cpp!!!	readUtf8FromUtf16(inout str : std::unique_ptr<std::string>) : status_t
    const int32_t start = dataPosition();
    int32_t size;
    status_t status = readInt32(&size);
    str->reset();

    if (status != OK || size < 0) {
        return status;
    }

    setDataPosition(start);
    str->reset(new (std::nothrow) std::string());
    return readUtf8FromUtf16(str->get());
!!!14695813.cpp!!!	readCString() : char
    const size_t avail = mDataSize-mDataPos;
    if (avail > 0) {
        const char* str = reinterpret_cast<const char*>(mData+mDataPos);
        // is the string's trailing NUL within the parcel's valid bounds?
        const char* eos = reinterpret_cast<const char*>(memchr(str, 0, avail));
        if (eos) {
            const size_t len = eos - str;
            mDataPos += pad_size(len+1);
            ALOGV("readCString Setting data pos of %p to %zu", this, mDataPos);
            return str;
        }
    }
    return NULL;
!!!14695941.cpp!!!	readString8() : String8
    String8 retString;
    status_t status = readString8(&retString);
    if (status != OK) {
        // We don't care about errors here, so just return an empty string.
        return String8();
    }
    return retString;
!!!14696069.cpp!!!	readString8(inout pArg : String8) : status_t
    int32_t size;
    status_t status = readInt32(&size);
    if (status != OK) {
        return status;
    }
    // watch for potential int overflow from size+1
    if (size < 0 || size >= INT32_MAX) {
        return BAD_VALUE;
    }
    // |writeString8| writes nothing for empty string.
    if (size == 0) {
        *pArg = String8();
        return OK;
    }
    const char* str = (const char*)readInplace(size + 1);
    if (str == NULL) {
        return BAD_VALUE;
    }
    pArg->setTo(str, size);
    return OK;
!!!14696197.cpp!!!	readString16() : String16
    size_t len;
    const char16_t* str = readString16Inplace(&len);
    if (str) return String16(str, len);
    ALOGE("Reading a NULL string not supported here.");
    return String16();
!!!14696325.cpp!!!	readString16(inout pArg : String16) : status_t
    size_t len;
    const char16_t* str = readString16Inplace(&len);
    if (str) {
        pArg->setTo(str, len);
        return 0;
    } else {
        *pArg = String16();
        return UNEXPECTED_NULL;
    }
!!!14696453.cpp!!!	readString16(inout pArg : std::unique_ptr<String16>) : status_t
    const int32_t start = dataPosition();
    int32_t size;
    status_t status = readInt32(&size);
    pArg->reset();

    if (status != OK || size < 0) {
        return status;
    }

    setDataPosition(start);
    pArg->reset(new (std::nothrow) String16());

    status = readString16(pArg->get());

    if (status != OK) {
        pArg->reset();
    }

    return status;
!!!14696581.cpp!!!	readString16Inplace(inout outLen : size_t) : char16_t
    int32_t size = readInt32();
    // watch for potential int overflow from size+1
    if (size >= 0 && size < INT32_MAX) {
        *outLen = size;
        const char16_t* str = (const char16_t*)readInplace((size+1)*sizeof(char16_t));
        if (str != NULL) {
            return str;
        }
    }
    *outLen = 0;
    return NULL;
!!!14696709.cpp!!!	readStrongBinder() : sp<IBinder>
    sp<IBinder> val;
    // Note that a lot of code in Android reads binders by hand with this
    // method, and that code has historically been ok with getting nullptr
    // back (while ignoring error codes).
    readNullableStrongBinder(&val);
    return val;
!!!14696837.cpp!!!	readStrongBinder(inout val : sp<IBinder>) : status_t
    status_t status = readNullableStrongBinder(val);
    if (status == OK && !val->get()) {
        status = UNEXPECTED_NULL;
    }
    return status;
!!!14696965.cpp!!!	readNullableStrongBinder(inout val : sp<IBinder>) : status_t
    return unflatten_binder(ProcessState::self(), *this, val);
!!!14697093.cpp!!!	readWeakBinder() : wp<IBinder>
    wp<IBinder> val;
    unflatten_binder(ProcessState::self(), *this, &val);
    return val;
!!!14697221.cpp!!!	readParcelableVector(inout val : std::unique_ptr<std::vector<std::unique_ptr<T>>>) : status_t
    const size_t start = dataPosition();
    int32_t size;
    status_t status = readInt32(&size);
    val->reset();

    if (status != OK || size < 0) {
        return status;
    }

    setDataPosition(start);
    val->reset(new std::vector<std::unique_ptr<T>>());

    status = unsafeReadTypedVector(val->get(), &Parcel::readParcelable<T>);

    if (status != OK) {
        val->reset();
    }

    return status;
!!!14697349.cpp!!!	readParcelableVector(inout val : std::vector<T>) : status_t
    return unsafeReadTypedVector<T, Parcelable>(val, &Parcel::readParcelable);
!!!14697477.cpp!!!	readParcelable(inout parcelable : Parcelable) : status_t
    int32_t have_parcelable = 0;
    status_t status = readInt32(&have_parcelable);
    if (status != OK) {
        return status;
    }
    if (!have_parcelable) {
        return UNEXPECTED_NULL;
    }
    return parcelable->readFromParcel(this);
!!!14697605.cpp!!!	readParcelable(inout parcelable : std::unique_ptr<T>) : status_t
    const size_t start = dataPosition();
    int32_t present;
    status_t status = readInt32(&present);
    parcelable->reset();

    if (status != OK || !present) {
        return status;
    }

    setDataPosition(start);
    parcelable->reset(new T());

    status = readParcelable(parcelable->get());

    if (status != OK) {
        parcelable->reset();
    }

    return status;
!!!14697733.cpp!!!	readValue(inout value : Value) : status_t
    return value->readFromParcel(this);
!!!14697861.cpp!!!	readStrongBinder(inout val : sp<T>) : status_t
    sp<IBinder> tmp;
    status_t ret = readStrongBinder(&tmp);

    if (ret == OK) {
        *val = interface_cast<T>(tmp);

        if (val->get() == nullptr) {
            return UNKNOWN_ERROR;
        }
    }

    return ret;
!!!14697989.cpp!!!	readNullableStrongBinder(inout val : sp<T>) : status_t
    sp<IBinder> tmp;
    status_t ret = readNullableStrongBinder(&tmp);

    if (ret == OK) {
        *val = interface_cast<T>(tmp);

        if (val->get() == nullptr && tmp.get() != nullptr) {
            ret = UNKNOWN_ERROR;
        }
    }

    return ret;
!!!14698117.cpp!!!	readStrongBinderVector(inout val : std::unique_ptr<std::vector<sp<IBinder>>>) : status_t
    return readNullableTypedVector(val, &Parcel::readNullableStrongBinder);
!!!14698245.cpp!!!	readStrongBinderVector(inout val : std::vector<sp<IBinder>>) : status_t
    return readTypedVector(val, &Parcel::readStrongBinder);
!!!14698373.cpp!!!	readByteVector(inout val : std::unique_ptr<std::vector<int8_t>>) : status_t
    return readByteVectorInternalPtr(this, val);
!!!14698501.cpp!!!	readByteVector(inout val : std::vector<int8_t>) : status_t
    return readByteVectorInternal(this, val);
!!!14698629.cpp!!!	readByteVector(inout val : std::unique_ptr<std::vector<uint8_t>>) : status_t
    return readByteVectorInternalPtr(this, val);
!!!14698757.cpp!!!	readByteVector(inout val : std::vector<uint8_t>) : status_t
    return readByteVectorInternal(this, val);
!!!14698885.cpp!!!	readInt32Vector(inout val : std::unique_ptr<std::vector<int32_t>>) : status_t
    return readNullableTypedVector(val, &Parcel::readInt32);
!!!14699013.cpp!!!	readInt32Vector(inout val : std::vector<int32_t>) : status_t
    return readTypedVector(val, &Parcel::readInt32);
!!!14699141.cpp!!!	readInt64Vector(inout val : std::unique_ptr<std::vector<int64_t>>) : status_t
    return readNullableTypedVector(val, &Parcel::readInt64);
!!!14699269.cpp!!!	readInt64Vector(inout val : std::vector<int64_t>) : status_t
    return readTypedVector(val, &Parcel::readInt64);
!!!14699397.cpp!!!	readFloatVector(inout val : std::unique_ptr<std::vector<float>>) : status_t
    return readNullableTypedVector(val, &Parcel::readFloat);
!!!14699525.cpp!!!	readFloatVector(inout val : std::vector<float>) : status_t
    return readTypedVector(val, &Parcel::readFloat);
!!!14699653.cpp!!!	readDoubleVector(inout val : std::unique_ptr<std::vector<double>>) : status_t
    return readNullableTypedVector(val, &Parcel::readDouble);
!!!14699781.cpp!!!	readDoubleVector(inout val : std::vector<double>) : status_t
    return readTypedVector(val, &Parcel::readDouble);
!!!14699909.cpp!!!	readBoolVector(inout val : std::unique_ptr<std::vector<bool>>) : status_t
    const int32_t start = dataPosition();
    int32_t size;
    status_t status = readInt32(&size);
    val->reset();

    if (status != OK || size < 0) {
        return status;
    }

    setDataPosition(start);
    val->reset(new (std::nothrow) std::vector<bool>());

    status = readBoolVector(val->get());

    if (status != OK) {
        val->reset();
    }

    return status;
!!!14700037.cpp!!!	readBoolVector(inout val : std::vector<bool>) : status_t
    int32_t size;
    status_t status = readInt32(&size);

    if (status != OK) {
        return status;
    }

    if (size < 0) {
        return UNEXPECTED_NULL;
    }

    val->resize(size);

    /* C++ bool handling means a vector of bools isn't necessarily addressable
     * (we might use individual bits)
     */
    bool data;
    for (int32_t i = 0; i < size; ++i) {
        status = readBool(&data);
        (*val)[i] = data;

        if (status != OK) {
            return status;
        }
    }

    return OK;
!!!14700165.cpp!!!	readCharVector(inout val : std::unique_ptr<std::vector<char16_t>>) : status_t
    return readNullableTypedVector(val, &Parcel::readChar);
!!!14700293.cpp!!!	readCharVector(inout val : std::vector<char16_t>) : status_t
    return readTypedVector(val, &Parcel::readChar);
!!!14700421.cpp!!!	readString16Vector(inout val : std::unique_ptr<std::vector<std::unique_ptr<String16>>>) : status_t
    return readNullableTypedVector(val, &Parcel::readString16);
!!!14700549.cpp!!!	readString16Vector(inout val : std::vector<String16>) : status_t
    return readTypedVector(val, &Parcel::readString16);
!!!14700677.cpp!!!	readUtf8VectorFromUtf16Vector(inout val : std::unique_ptr<std::vector<std::unique_ptr<std::string>>>) : status_t
    return readNullableTypedVector(val, &Parcel::readUtf8FromUtf16);
!!!14700805.cpp!!!	readUtf8VectorFromUtf16Vector(inout val : std::vector<std::string>) : status_t
    return readTypedVector(val, &Parcel::readUtf8FromUtf16);
!!!14700933.cpp!!!	read(inout val : Flattenable<T>) : status_t
    FlattenableHelper<T> helper(val);
    return read(helper);
!!!14701061.cpp!!!	read(inout val : LightFlattenable<T>) : status_t
    size_t size;
    if (val.isFixedSize()) {
        size = val.getFlattenedSize();
    } else {
        int32_t s;
        status_t err = readInt32(&s);
        if (err != NO_ERROR) {
            return err;
        }
        size = static_cast<size_t>(s);
    }
    if (size) {
        void const* buffer = readInplace(size);
        return buffer == NULL ? NO_MEMORY :
                val.unflatten(buffer, size);
    }
    return NO_ERROR;
!!!14701189.cpp!!!	resizeOutVector(inout val : std::vector<T>) : status_t
    int32_t size;
    status_t err = readInt32(&size);
    if (err != NO_ERROR) {
        return err;
    }

    if (size < 0) {
        return UNEXPECTED_NULL;
    }
    val->resize(size_t(size));
    return OK;
!!!14701317.cpp!!!	resizeOutVector(inout val : std::unique_ptr<std::vector<T>>) : status_t
    int32_t size;
    status_t err = readInt32(&size);
    if (err != NO_ERROR) {
        return err;
    }

    val->reset();
    if (size >= 0) {
        val->reset(new std::vector<T>(size_t(size)));
    }

    return OK;
!!!14701445.cpp!!!	readMap(inout map_out : Map) : status_t
    using ::std::map;
    using ::android::String16;
    using ::android::String8;
    using ::android::binder::Value;
    using ::android::binder::Map;

    status_t ret = NO_ERROR;
    int32_t count;

    ret = readInt32(&count);
    if (ret != NO_ERROR) {
        return ret;
    }

    if (count < 0) {
        ALOGE("readMap: Unexpected count: %d", count);
        return (count == -1)
            ? UNEXPECTED_NULL
            : BAD_VALUE;
    }

    map_out->clear();

    while (count--) {
        Map::key_type key;
        Value value;

        ret = readValue(&value);
        if (ret != NO_ERROR) {
            return ret;
        }

        if (!value.getString(&key)) {
            ALOGE("readMap: Key type not a string (parcelType = %d)", value.parcelType());
            return BAD_VALUE;
        }

        ret = readValue(&value);
        if (ret != NO_ERROR) {
            return ret;
        }

        (*map_out)[key] = value;
    }

    return ret;
!!!14701573.cpp!!!	readNullableMap(inout map : std::unique_ptr<binder::Map>) : status_t
    const size_t start = dataPosition();
    int32_t count;
    status_t status = readInt32(&count);
    map->reset();

    if (status != OK || count == -1) {
        return status;
    }

    setDataPosition(start);
    map->reset(new binder::Map());

    status = readMap(map->get());

    if (status != OK) {
        map->reset();
    }

    return status;
!!!14701701.cpp!!!	readExceptionCode() : int32_t
    binder::Status status;
    status.readFromParcel(*this);
    return status.exceptionCode();
!!!14701829.cpp!!!	readNativeHandle() : native_handle
    int numFds, numInts;
    status_t err;
    err = readInt32(&numFds);
    if (err != NO_ERROR) return 0;
    err = readInt32(&numInts);
    if (err != NO_ERROR) return 0;

    native_handle* h = native_handle_create(numFds, numInts);
    if (!h) {
        return 0;
    }

    for (int i=0 ; err==NO_ERROR && i<numFds ; i++) {
        h->data[i] = fcntl(readFileDescriptor(), F_DUPFD_CLOEXEC, 0);
        if (h->data[i] < 0) {
            for (int j = 0; j < i; j++) {
                close(h->data[j]);
            }
            native_handle_delete(h);
            return 0;
        }
    }
    err = read(h->data + numFds, sizeof(int)*numInts);
    if (err != NO_ERROR) {
        native_handle_close(h);
        native_handle_delete(h);
        h = 0;
    }
    return h;
!!!14701957.cpp!!!	readFileDescriptor() : int
    const flat_binder_object* flat = readObject(true);

    if (flat && flat->type == BINDER_TYPE_FD) {
        return flat->handle;
    }

    return BAD_TYPE;
!!!14702085.cpp!!!	readParcelFileDescriptor() : int
    int32_t hasComm = readInt32();
    int fd = readFileDescriptor();
    if (hasComm != 0) {
        // skip
        readFileDescriptor();
    }
    return fd;
!!!14702213.cpp!!!	readUniqueFileDescriptor(inout val : base::unique_fd) : status_t
    int got = readFileDescriptor();

    if (got == BAD_TYPE) {
        return BAD_TYPE;
    }

    val->reset(fcntl(got, F_DUPFD_CLOEXEC, 0));

    if (val->get() < 0) {
        return BAD_VALUE;
    }

    return OK;
!!!14702341.cpp!!!	readUniqueFileDescriptorVector(inout val : std::unique_ptr<std::vector<base::unique_fd>>) : status_t
    return readNullableTypedVector(val, &Parcel::readUniqueFileDescriptor);
!!!14702469.cpp!!!	readUniqueFileDescriptorVector(inout val : std::vector<base::unique_fd>) : status_t
    return readTypedVector(val, &Parcel::readUniqueFileDescriptor);
!!!14702597.cpp!!!	readBlob(in len : size_t, inout outBlob : Parcel::ReadableBlob) : status_t
    int32_t blobType;
    status_t status = readInt32(&blobType);
    if (status) return status;

    if (blobType == BLOB_INPLACE) {
        ALOGV("readBlob: read in place");
        const void* ptr = readInplace(len);
        if (!ptr) return BAD_VALUE;

        outBlob->init(-1, const_cast<void*>(ptr), len, false);
        return NO_ERROR;
    }

    ALOGV("readBlob: read from ashmem");
    bool isMutable = (blobType == BLOB_ASHMEM_MUTABLE);
    int fd = readFileDescriptor();
    if (fd == int(BAD_TYPE)) return BAD_VALUE;

    void* ptr = ::mmap(NULL, len, isMutable ? PROT_READ | PROT_WRITE : PROT_READ,
            MAP_SHARED, fd, 0);
    if (ptr == MAP_FAILED) return NO_MEMORY;

    outBlob->init(fd, ptr, len, isMutable);
    return NO_ERROR;
!!!14702725.cpp!!!	readObject(in nullMetaData : bool) : flat_binder_object
    const size_t DPOS = mDataPos;
    if ((DPOS+sizeof(flat_binder_object)) <= mDataSize) {
        const flat_binder_object* obj
                = reinterpret_cast<const flat_binder_object*>(mData+DPOS);
        mDataPos = DPOS + sizeof(flat_binder_object);
        if (!nullMetaData && (obj->cookie == 0 && obj->binder == 0)) {
            // When transferring a NULL object, we don't write it into
            // the object list, so we don't want to check for it when
            // reading.
            ALOGV("readObject Setting data pos of %p to %zu", this, mDataPos);
            return obj;
        }

        // Ensure that this object is valid...
        binder_size_t* const OBJS = mObjects;
        const size_t N = mObjectsSize;
        size_t opos = mNextObjectHint;

        if (N > 0) {
            ALOGV("Parcel %p looking for obj at %zu, hint=%zu",
                 this, DPOS, opos);

            // Start at the current hint position, looking for an object at
            // the current data position.
            if (opos < N) {
                while (opos < (N-1) && OBJS[opos] < DPOS) {
                    opos++;
                }
            } else {
                opos = N-1;
            }
            if (OBJS[opos] == DPOS) {
                // Found it!
                ALOGV("Parcel %p found obj %zu at index %zu with forward search",
                     this, DPOS, opos);
                mNextObjectHint = opos+1;
                ALOGV("readObject Setting data pos of %p to %zu", this, mDataPos);
                return obj;
            }

            // Look backwards for it...
            while (opos > 0 && OBJS[opos] > DPOS) {
                opos--;
            }
            if (OBJS[opos] == DPOS) {
                // Found it!
                ALOGV("Parcel %p found obj %zu at index %zu with backward search",
                     this, DPOS, opos);
                mNextObjectHint = opos+1;
                ALOGV("readObject Setting data pos of %p to %zu", this, mDataPos);
                return obj;
            }
        }
        ALOGW("Attempt to read object from Parcel %p at offset %zu that is not in the object list",
             this, DPOS);
    }
    return NULL;
!!!14702853.cpp!!!	closeFileDescriptors() : void
    size_t i = mObjectsSize;
    if (i > 0) {
        //ALOGI("Closing file descriptors for %zu objects...", i);
    }
    while (i > 0) {
        i--;
        const flat_binder_object* flat
            = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);
        if (flat->type == BINDER_TYPE_FD) {
            //ALOGI("Closing fd: %ld", flat->handle);
            close(flat->handle);
        }
    }
!!!14702981.cpp!!!	getGlobalAllocSize() : size_t
    pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
    size_t size = gParcelGlobalAllocSize;
    pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
    return size;
!!!14703109.cpp!!!	getGlobalAllocCount() : size_t
    pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
    size_t count = gParcelGlobalAllocCount;
    pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
    return count;
!!!14703237.cpp!!!	ipcData() : uintptr_t
    return reinterpret_cast<uintptr_t>(mData);
!!!14703365.cpp!!!	ipcDataSize() : size_t
    return (mDataSize > mDataPos ? mDataSize : mDataPos);
!!!14703493.cpp!!!	ipcObjects() : uintptr_t
    return reinterpret_cast<uintptr_t>(mObjects);
!!!14703621.cpp!!!	ipcObjectsCount() : size_t
    return mObjectsSize;
!!!14703749.cpp!!!	ipcSetDataReference(in data : uint8_t, in dataSize : size_t, in objects : binder_size_t, in objectsCount : size_t, in relFunc : Parcel::release_func, inout relCookie : void) : void
    binder_size_t minOffset = 0;
    freeDataNoInit();
    mError = NO_ERROR;
    mData = const_cast<uint8_t*>(data);
    mDataSize = mDataCapacity = dataSize;
    //ALOGI("setDataReference Setting data size of %p to %lu (pid=%d)", this, mDataSize, getpid());
    mDataPos = 0;
    ALOGV("setDataReference Setting data pos of %p to %zu", this, mDataPos);
    mObjects = const_cast<binder_size_t*>(objects);
    mObjectsSize = mObjectsCapacity = objectsCount;
    mNextObjectHint = 0;
    mOwner = relFunc;
    mOwnerCookie = relCookie;
    for (size_t i = 0; i < mObjectsSize; i++) {
        binder_size_t offset = mObjects[i];
        if (offset < minOffset) {
            ALOGE("%s: bad object offset %" PRIu64 " < %" PRIu64 "\n",
                  __func__, (uint64_t)offset, (uint64_t)minOffset);
            mObjectsSize = 0;
            break;
        }
        minOffset = offset + sizeof(flat_binder_object);
    }
    scanForFds();
!!!14703877.cpp!!!	print(inout to : TextOutput, in flags : uint32_t = 0) : void
    to << "Parcel(";

    if (errorCheck() != NO_ERROR) {
        const status_t err = errorCheck();
        to << "Error: " << (void*)(intptr_t)err << " \"" << strerror(-err) << "\"";
    } else if (dataSize() > 0) {
        const uint8_t* DATA = data();
        to << indent << HexDump(DATA, dataSize()) << dedent;
        const binder_size_t* OBJS = objects();
        const size_t N = objectsCount();
        for (size_t i=0; i<N; i++) {
            const flat_binder_object* flat
                = reinterpret_cast<const flat_binder_object*>(DATA+OBJS[i]);
            to << endl << "Object #" << i << " @ " << (void*)OBJS[i] << ": "
                << TypeCode(flat->type & 0x7f7f7f00)
                << " = " << flat->binder;
        }
    } else {
        to << "NULL";
    }

    to << ")";
!!!14704261.cpp!!!	finishWrite(in len : size_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    //printf("Finish write of %d\n", len);
    mDataPos += len;
    ALOGV("finishWrite Setting data pos of %p to %zu", this, mDataPos);
    if (mDataPos > mDataSize) {
        mDataSize = mDataPos;
        ALOGV("finishWrite Setting data size of %p to %zu", this, mDataSize);
    }
    //printf("New pos=%d, size=%d\n", mDataPos, mDataSize);
    return NO_ERROR;
!!!14704389.cpp!!!	releaseObjects() : void
    const sp<ProcessState> proc(ProcessState::self());
    size_t i = mObjectsSize;
    uint8_t* const data = mData;
    binder_size_t* const objects = mObjects;
    while (i > 0) {
        i--;
        const flat_binder_object* flat
            = reinterpret_cast<flat_binder_object*>(data+objects[i]);
        release_object(proc, *flat, this, &mOpenAshmemSize);
    }
!!!14704517.cpp!!!	acquireObjects() : void
    const sp<ProcessState> proc(ProcessState::self());
    size_t i = mObjectsSize;
    uint8_t* const data = mData;
    binder_size_t* const objects = mObjects;
    while (i > 0) {
        i--;
        const flat_binder_object* flat
            = reinterpret_cast<flat_binder_object*>(data+objects[i]);
        acquire_object(proc, *flat, this, &mOpenAshmemSize);
    }
!!!14704645.cpp!!!	growData(in len : size_t) : status_t
    if (len > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    size_t newSize = ((mDataSize+len)*3)/2;
    return (newSize <= mDataSize)
            ? (status_t) NO_MEMORY
            : continueWrite(newSize);
!!!14704773.cpp!!!	restartWrite(in desired : size_t) : status_t
    if (desired > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    if (mOwner) {
        freeData();
        return continueWrite(desired);
    }

    uint8_t* data = (uint8_t*)realloc(mData, desired);
    if (!data && desired > mDataCapacity) {
        mError = NO_MEMORY;
        return NO_MEMORY;
    }

    releaseObjects();

    if (data) {
        LOG_ALLOC("Parcel %p: restart from %zu to %zu capacity", this, mDataCapacity, desired);
        pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
        gParcelGlobalAllocSize += desired;
        gParcelGlobalAllocSize -= mDataCapacity;
        if (!mData) {
            gParcelGlobalAllocCount++;
        }
        pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
        mData = data;
        mDataCapacity = desired;
    }

    mDataSize = mDataPos = 0;
    ALOGV("restartWrite Setting data size of %p to %zu", this, mDataSize);
    ALOGV("restartWrite Setting data pos of %p to %zu", this, mDataPos);

    free(mObjects);
    mObjects = NULL;
    mObjectsSize = mObjectsCapacity = 0;
    mNextObjectHint = 0;
    mHasFds = false;
    mFdsKnown = true;
    mAllowFds = true;

    return NO_ERROR;
!!!14704901.cpp!!!	continueWrite(in desired : size_t) : status_t
    if (desired > INT32_MAX) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    // If shrinking, first adjust for any objects that appear
    // after the new data size.
    size_t objectsSize = mObjectsSize;
    if (desired < mDataSize) {
        if (desired == 0) {
            objectsSize = 0;
        } else {
            while (objectsSize > 0) {
                if (mObjects[objectsSize-1] < desired)
                    break;
                objectsSize--;
            }
        }
    }

    if (mOwner) {
        // If the size is going to zero, just release the owner's data.
        if (desired == 0) {
            freeData();
            return NO_ERROR;
        }

        // If there is a different owner, we need to take
        // posession.
        uint8_t* data = (uint8_t*)malloc(desired);
        if (!data) {
            mError = NO_MEMORY;
            return NO_MEMORY;
        }
        binder_size_t* objects = NULL;

        if (objectsSize) {
            objects = (binder_size_t*)calloc(objectsSize, sizeof(binder_size_t));
            if (!objects) {
                free(data);

                mError = NO_MEMORY;
                return NO_MEMORY;
            }

            // Little hack to only acquire references on objects
            // we will be keeping.
            size_t oldObjectsSize = mObjectsSize;
            mObjectsSize = objectsSize;
            acquireObjects();
            mObjectsSize = oldObjectsSize;
        }

        if (mData) {
            memcpy(data, mData, mDataSize < desired ? mDataSize : desired);
        }
        if (objects && mObjects) {
            memcpy(objects, mObjects, objectsSize*sizeof(binder_size_t));
        }
        //ALOGI("Freeing data ref of %p (pid=%d)", this, getpid());
        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
        mOwner = NULL;

        LOG_ALLOC("Parcel %p: taking ownership of %zu capacity", this, desired);
        pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
        gParcelGlobalAllocSize += desired;
        gParcelGlobalAllocCount++;
        pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);

        mData = data;
        mObjects = objects;
        mDataSize = (mDataSize < desired) ? mDataSize : desired;
        ALOGV("continueWrite Setting data size of %p to %zu", this, mDataSize);
        mDataCapacity = desired;
        mObjectsSize = mObjectsCapacity = objectsSize;
        mNextObjectHint = 0;

    } else if (mData) {
        if (objectsSize < mObjectsSize) {
            // Need to release refs on any objects we are dropping.
            const sp<ProcessState> proc(ProcessState::self());
            for (size_t i=objectsSize; i<mObjectsSize; i++) {
                const flat_binder_object* flat
                    = reinterpret_cast<flat_binder_object*>(mData+mObjects[i]);
                if (flat->type == BINDER_TYPE_FD) {
                    // will need to rescan because we may have lopped off the only FDs
                    mFdsKnown = false;
                }
                release_object(proc, *flat, this, &mOpenAshmemSize);
            }
            binder_size_t* objects =
                (binder_size_t*)realloc(mObjects, objectsSize*sizeof(binder_size_t));
            if (objects) {
                mObjects = objects;
            }
            mObjectsSize = objectsSize;
            mNextObjectHint = 0;
        }

        // We own the data, so we can just do a realloc().
        if (desired > mDataCapacity) {
            uint8_t* data = (uint8_t*)realloc(mData, desired);
            if (data) {
                LOG_ALLOC("Parcel %p: continue from %zu to %zu capacity", this, mDataCapacity,
                        desired);
                pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
                gParcelGlobalAllocSize += desired;
                gParcelGlobalAllocSize -= mDataCapacity;
                pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
                mData = data;
                mDataCapacity = desired;
            } else if (desired > mDataCapacity) {
                mError = NO_MEMORY;
                return NO_MEMORY;
            }
        } else {
            if (mDataSize > desired) {
                mDataSize = desired;
                ALOGV("continueWrite Setting data size of %p to %zu", this, mDataSize);
            }
            if (mDataPos > desired) {
                mDataPos = desired;
                ALOGV("continueWrite Setting data pos of %p to %zu", this, mDataPos);
            }
        }

    } else {
        // This is the first data.  Easy!
        uint8_t* data = (uint8_t*)malloc(desired);
        if (!data) {
            mError = NO_MEMORY;
            return NO_MEMORY;
        }

        if(!(mDataCapacity == 0 && mObjects == NULL
             && mObjectsCapacity == 0)) {
            ALOGE("continueWrite: %zu/%p/%zu/%zu", mDataCapacity, mObjects, mObjectsCapacity, desired);
        }

        LOG_ALLOC("Parcel %p: allocating with %zu capacity", this, desired);
        pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
        gParcelGlobalAllocSize += desired;
        gParcelGlobalAllocCount++;
        pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);

        mData = data;
        mDataSize = mDataPos = 0;
        ALOGV("continueWrite Setting data size of %p to %zu", this, mDataSize);
        ALOGV("continueWrite Setting data pos of %p to %zu", this, mDataPos);
        mDataCapacity = desired;
    }

    return NO_ERROR;
!!!14705029.cpp!!!	writePointer(in val : uintptr_t) : status_t
    return writeAligned<binder_uintptr_t>(val);
!!!14705157.cpp!!!	readPointer(inout pArg : uintptr_t) : status_t
    status_t ret;
    binder_uintptr_t ptr;
    ret = readAligned(&ptr);
    if (!ret)
        *pArg = ptr;
    return ret;
!!!14705285.cpp!!!	readPointer() : uintptr_t
    return readAligned<binder_uintptr_t>();
!!!14705413.cpp!!!	freeDataNoInit() : void
    if (mOwner) {
        LOG_ALLOC("Parcel %p: freeing other owner data", this);
        //ALOGI("Freeing data ref of %p (pid=%d)", this, getpid());
        mOwner(this, mData, mDataSize, mObjects, mObjectsSize, mOwnerCookie);
    } else {
        LOG_ALLOC("Parcel %p: freeing allocated data", this);
        releaseObjects();
        if (mData) {
            LOG_ALLOC("Parcel %p: freeing with %zu capacity", this, mDataCapacity);
            pthread_mutex_lock(&gParcelGlobalAllocSizeLock);
            if (mDataCapacity <= gParcelGlobalAllocSize) {
              gParcelGlobalAllocSize = gParcelGlobalAllocSize - mDataCapacity;
            } else {
              gParcelGlobalAllocSize = 0;
            }
            if (gParcelGlobalAllocCount > 0) {
              gParcelGlobalAllocCount--;
            }
            pthread_mutex_unlock(&gParcelGlobalAllocSizeLock);
            free(mData);
        }
        if (mObjects) free(mObjects);
    }
!!!14705541.cpp!!!	initState() : void
    LOG_ALLOC("Parcel %p: initState", this);
    mError = NO_ERROR;
    mData = 0;
    mDataSize = 0;
    mDataCapacity = 0;
    mDataPos = 0;
    ALOGV("initState Setting data size of %p to %zu", this, mDataSize);
    ALOGV("initState Setting data pos of %p to %zu", this, mDataPos);
    mObjects = NULL;
    mObjectsSize = 0;
    mObjectsCapacity = 0;
    mNextObjectHint = 0;
    mHasFds = false;
    mFdsKnown = true;
    mAllowFds = true;
    mOwner = NULL;
    mOpenAshmemSize = 0;

    // racing multiple init leads only to multiple identical write
    if (gMaxFds == 0) {
        struct rlimit result;
        if (!getrlimit(RLIMIT_NOFILE, &result)) {
            gMaxFds = (size_t)result.rlim_cur;
            //ALOGI("parcel fd limit set to %zu", gMaxFds);
        } else {
            ALOGW("Unable to getrlimit: %s", strerror(errno));
            gMaxFds = 1024;
        }
    }
!!!14705669.cpp!!!	scanForFds() : void
    bool hasFds = false;
    for (size_t i=0; i<mObjectsSize; i++) {
        const flat_binder_object* flat
            = reinterpret_cast<const flat_binder_object*>(mData + mObjects[i]);
        if (flat->type == BINDER_TYPE_FD) {
            hasFds = true;
            break;
        }
    }
    mHasFds = hasFds;
    mFdsKnown = true;
!!!14705797.cpp!!!	readAligned(inout pArg : T) : status_t
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));

    if ((mDataPos+sizeof(T)) <= mDataSize) {
        const void* data = mData+mDataPos;
        mDataPos += sizeof(T);
        *pArg =  *reinterpret_cast<const T*>(data);
        return NO_ERROR;
    } else {
        return NOT_ENOUGH_DATA;
    }
!!!14705925.cpp!!!	readAligned() : T
    T result;
    if (readAligned(&result) != NO_ERROR) {
        result = 0;
    }

    return result;
!!!14706053.cpp!!!	writeAligned(in val : T) : status_t
    COMPILE_TIME_ASSERT_FUNCTION_SCOPE(PAD_SIZE_UNSAFE(sizeof(T)) == sizeof(T));

    if ((mDataPos+sizeof(val)) <= mDataCapacity) {
restart_write:
        *reinterpret_cast<T*>(mData+mDataPos) = val;
        return finishWrite(sizeof(val));
    }

    status_t err = growData(sizeof(val));
    if (err == NO_ERROR) goto restart_write;
    return err;
!!!14706181.cpp!!!	writeRawNullableParcelable(in parcelable : Parcelable) : status_t
    if (!parcelable) {
        return writeInt32(0);
    }

    return writeParcelable(*parcelable);
!!!14706309.cpp!!!	unsafeReadTypedVector(inout val : std::vector<T>, in read_func : status_t(Parcel::*)(U*)) : status_t
    int32_t size;
    status_t status = this->readInt32(&size);

    if (status != OK) {
        return status;
    }

    if (size < 0) {
        return UNEXPECTED_NULL;
    }

    if (val->max_size() < static_cast<size_t>(size)) {
        return NO_MEMORY;
    }

    val->resize(static_cast<size_t>(size));

    if (val->size() < static_cast<size_t>(size)) {
        return NO_MEMORY;
    }

    for (auto& v: *val) {
        status = (this->*read_func)(&v);

        if (status != OK) {
            return status;
        }
    }

    return OK;
!!!14706437.cpp!!!	readNullableTypedVector(inout val : std::unique_ptr<std::vector<T>>, in read_func : status_t(Parcel::*)(T*)) : status_t
    const size_t start = dataPosition();
    int32_t size;
    status_t status = readInt32(&size);
    val->reset();

    if (status != OK || size < 0) {
        return status;
    }

    setDataPosition(start);
    val->reset(new std::vector<T>());

    status = unsafeReadTypedVector(val->get(), read_func);

    if (status != OK) {
        val->reset();
    }

    return status;
!!!14706565.cpp!!!	readTypedVector(inout val : std::vector<T>, in read_func : status_t(Parcel::*)(T*)) : status_t
    return unsafeReadTypedVector(val, read_func);
!!!14706693.cpp!!!	unsafeWriteTypedVector(in val : std::vector<T>, in write_func : status_t(Parcel::*)(U)) : status_t
    if (val.size() > std::numeric_limits<int32_t>::max()) {
        return BAD_VALUE;
    }

    status_t status = this->writeInt32(static_cast<int32_t>(val.size()));

    if (status != OK) {
        return status;
    }

    for (const auto& item : val) {
        status = (this->*write_func)(item);

        if (status != OK) {
            return status;
        }
    }

    return OK;
!!!14706821.cpp!!!	writeNullableTypedVector(in val : std::unique_ptr<std::vector<T>>, in write_func : status_t(Parcel::*)(const T&)) : status_t
    if (val.get() == nullptr) {
        return this->writeInt32(-1);
    }

    return unsafeWriteTypedVector(*val, write_func);
!!!14706949.cpp!!!	writeNullableTypedVector(in val : std::unique_ptr<std::vector<T>>, in write_func : status_t(Parcel::*)(T)) : status_t
    if (val.get() == nullptr) {
        return this->writeInt32(-1);
    }

    return unsafeWriteTypedVector(*val, write_func);
!!!14707077.cpp!!!	writeTypedVector(in val : std::vector<T>, in write_func : status_t(Parcel::*)(const T&)) : status_t
    return unsafeWriteTypedVector(val, write_func);
!!!14707205.cpp!!!	writeTypedVector(in val : std::vector<T>, in write_func : status_t(Parcel::*)(T)) : status_t
    return unsafeWriteTypedVector(val, write_func);
!!!14709765.cpp!!!	write(in val : Parcel::FlattenableHelperInterface) : status_t
    status_t err;

    // size if needed
    const size_t len = val.getFlattenedSize();
    const size_t fd_count = val.getFdCount();

    if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    err = this->writeInt32(len);
    if (err) return err;

    err = this->writeInt32(fd_count);
    if (err) return err;

    // payload
    void* const buf = this->writeInplace(pad_size(len));
    if (buf == NULL)
        return BAD_VALUE;

    int* fds = NULL;
    if (fd_count) {
        fds = new (std::nothrow) int[fd_count];
        if (fds == nullptr) {
            ALOGE("write: failed to allocate requested %zu fds", fd_count);
            return BAD_VALUE;
        }
    }

    err = val.flatten(buf, len, fds, fd_count);
    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {
        err = this->writeDupFileDescriptor( fds[i] );
    }

    if (fd_count) {
        delete [] fds;
    }

    return err;
!!!14709893.cpp!!!	read(inout val : Parcel::FlattenableHelperInterface) : status_t
    // size
    const size_t len = this->readInt32();
    const size_t fd_count = this->readInt32();

    if ((len > INT32_MAX) || (fd_count >= gMaxFds)) {
        // don't accept size_t values which may have come from an
        // inadvertent conversion from a negative int.
        return BAD_VALUE;
    }

    // payload
    void const* const buf = this->readInplace(pad_size(len));
    if (buf == NULL)
        return BAD_VALUE;

    int* fds = NULL;
    if (fd_count) {
        fds = new (std::nothrow) int[fd_count];
        if (fds == nullptr) {
            ALOGE("read: failed to allocate requested %zu fds", fd_count);
            return BAD_VALUE;
        }
    }

    status_t err = NO_ERROR;
    for (size_t i=0 ; i<fd_count && err==NO_ERROR ; i++) {
        int fd = this->readFileDescriptor();
        if (fd < 0 || ((fds[i] = fcntl(fd, F_DUPFD_CLOEXEC, 0)) < 0)) {
            err = BAD_VALUE;
            ALOGE("fcntl(F_DUPFD_CLOEXEC) failed in Parcel::read, i is %zu, fds[i] is %d, fd_count is %zu, error: %s",
                  i, fds[i], fd_count, strerror(fd < 0 ? -fd : errno));
            // Close all the file descriptors that were dup-ed.
            for (size_t j=0; j<i ;j++) {
                close(fds[j]);
            }
        }
    }

    if (err == NO_ERROR) {
        err = val.unflatten(buf, len, fds, fd_count);
    }

    if (fd_count) {
        delete [] fds;
    }

    return err;
!!!14710405.cpp!!!	getBlobAshmemSize() : size_t
    // This used to return the size of all blobs that were written to ashmem, now we're returning
    // the ashmem currently referenced by this Parcel, which should be equivalent.
    // TODO: Remove method once ABI can be changed.
    return mOpenAshmemSize;
!!!14710533.cpp!!!	getOpenAshmemSize() : size_t
    return mOpenAshmemSize;
