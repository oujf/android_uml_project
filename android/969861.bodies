class Activity
!!!4791685.java!!!	getIntent() : Intent
        return mIntent;
!!!4791813.java!!!	setIntent(inout newIntent : Intent) : void
        mIntent = newIntent;
!!!4791941.java!!!	getApplication() : Application
        return mApplication;
!!!4792069.java!!!	isChild() : boolean
        return mParent != null;
!!!4792197.java!!!	getParent() : Activity
        return mParent;
!!!4792325.java!!!	getWindowManager() : WindowManager
        return mWindowManager;
!!!4792453.java!!!	getWindow() : Window
        return mWindow;
!!!4792581.java!!!	getLoaderManager() : LoaderManager
        return mFragments.getLoaderManager();
!!!4792709.java!!!	getCurrentFocus() : View
        return mWindow != null ? mWindow.getCurrentFocus() : null;
!!!4792837.java!!!	getAutofillManager() : AutofillManager
        if (mAutofillManager == null) {
            mAutofillManager = getSystemService(AutofillManager.class);
        }

        return mAutofillManager;
!!!4792965.java!!!	onCreate(inout savedInstanceState : Bundle) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onCreate " + this + ": " + savedInstanceState);

        if (getApplicationInfo().targetSdkVersion > O && mActivityInfo.isFixedOrientation()) {
            final TypedArray ta = obtainStyledAttributes(com.android.internal.R.styleable.Window);
            final boolean isTranslucentOrFloating = ActivityInfo.isTranslucentOrFloating(ta);
            ta.recycle();

            if (isTranslucentOrFloating) {
                throw new IllegalStateException(
                        "Only fullscreen opaque activities can request orientation");
            }
        }

        if (mLastNonConfigurationInstances != null) {
            mFragments.restoreLoaderNonConfig(mLastNonConfigurationInstances.loaders);
        }
        if (mActivityInfo.parentActivityName != null) {
            if (mActionBar == null) {
                mEnableDefaultActionBarUp = true;
            } else {
                mActionBar.setDefaultDisplayHomeAsUpEnabled(true);
            }
        }
        if (savedInstanceState != null) {
            mAutoFillResetNeeded = savedInstanceState.getBoolean(AUTOFILL_RESET_NEEDED, false);
            mLastAutofillId = savedInstanceState.getInt(LAST_AUTOFILL_ID,
                    View.LAST_APP_AUTOFILL_ID);

            if (mAutoFillResetNeeded) {
                getAutofillManager().onCreate(savedInstanceState);
            }

            Parcelable p = savedInstanceState.getParcelable(FRAGMENTS_TAG);
            mFragments.restoreAllState(p, mLastNonConfigurationInstances != null
                    ? mLastNonConfigurationInstances.fragments : null);
        }
        mFragments.dispatchCreate();
        getApplication().dispatchActivityCreated(this, savedInstanceState);
        if (mVoiceInteractor != null) {
            mVoiceInteractor.attachActivity(this);
        }
        mCalled = true;
!!!4793093.java!!!	onCreate(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        onCreate(savedInstanceState);
!!!4793221.java!!!	performRestoreInstanceState(inout savedInstanceState : Bundle) : void
        onRestoreInstanceState(savedInstanceState);
        restoreManagedDialogs(savedInstanceState);
!!!4793349.java!!!	performRestoreInstanceState(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        onRestoreInstanceState(savedInstanceState, persistentState);
        if (savedInstanceState != null) {
            restoreManagedDialogs(savedInstanceState);
        }
!!!4793477.java!!!	onRestoreInstanceState(inout savedInstanceState : Bundle) : void
        if (mWindow != null) {
            Bundle windowState = savedInstanceState.getBundle(WINDOW_HIERARCHY_TAG);
            if (windowState != null) {
                mWindow.restoreHierarchyState(windowState);
            }
        }
!!!4793605.java!!!	onRestoreInstanceState(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        if (savedInstanceState != null) {
            onRestoreInstanceState(savedInstanceState);
        }
!!!4793733.java!!!	restoreManagedDialogs(inout savedInstanceState : Bundle) : void
        final Bundle b = savedInstanceState.getBundle(SAVED_DIALOGS_TAG);
        if (b == null) {
            return;
        }

        final int[] ids = b.getIntArray(SAVED_DIALOG_IDS_KEY);
        final int numDialogs = ids.length;
        mManagedDialogs = new SparseArray<ManagedDialog>(numDialogs);
        for (int i = 0; i < numDialogs; i++) {
            final Integer dialogId = ids[i];
            Bundle dialogState = b.getBundle(savedDialogKeyFor(dialogId));
            if (dialogState != null) {
                // Calling onRestoreInstanceState() below will invoke dispatchOnCreate
                // so tell createDialog() not to do it, otherwise we get an exception
                final ManagedDialog md = new ManagedDialog();
                md.mArgs = b.getBundle(savedDialogArgsKeyFor(dialogId));
                md.mDialog = createDialog(dialogId, dialogState, md.mArgs);
                if (md.mDialog != null) {
                    mManagedDialogs.put(dialogId, md);
                    onPrepareDialog(dialogId, md.mDialog, md.mArgs);
                    md.mDialog.onRestoreInstanceState(dialogState);
                }
            }
        }
!!!4793861.java!!!	createDialog(inout dialogId : Integer, inout state : Bundle, inout args : Bundle) : Dialog
        final Dialog dialog = onCreateDialog(dialogId, args);
        if (dialog == null) {
            return null;
        }
        dialog.dispatchOnCreate(state);
        return dialog;
!!!4793989.java!!!	savedDialogKeyFor(in key : int) : String
        return SAVED_DIALOG_KEY_PREFIX + key;
!!!4794117.java!!!	savedDialogArgsKeyFor(in key : int) : String
        return SAVED_DIALOG_ARGS_KEY_PREFIX + key;
!!!4794245.java!!!	onPostCreate(inout savedInstanceState : Bundle) : void
        if (!isChild()) {
            mTitleReady = true;
            onTitleChanged(getTitle(), getTitleColor());
        }

        mCalled = true;
!!!4794373.java!!!	onPostCreate(inout savedInstanceState : Bundle, inout persistentState : PersistableBundle) : void
        onPostCreate(savedInstanceState);
!!!4794501.java!!!	onStart() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onStart " + this);
        mCalled = true;

        mFragments.doLoaderStart();

        getApplication().dispatchActivityStarted(this);

        if (mAutoFillResetNeeded) {
            AutofillManager afm = getAutofillManager();
            if (afm != null) {
                afm.onVisibleForAutofill();
            }
        }
!!!4794629.java!!!	onRestart() : void
        mCalled = true;
!!!4794885.java!!!	onResume() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onResume " + this);
        getApplication().dispatchActivityResumed(this);
        mActivityTransitionState.onResume(this, isTopOfTask());
        mCalled = true;
!!!4795013.java!!!	onPostResume() : void
        final Window win = getWindow();
        if (win != null) win.makeActive();
        if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(true);
        mCalled = true;
!!!4795141.java!!!	setVoiceInteractor(inout voiceInteractor : IVoiceInteractor) : void
        if (mVoiceInteractor != null) {
            for (Request activeRequest: mVoiceInteractor.getActiveRequests()) {
                activeRequest.cancel();
                activeRequest.clear();
            }
        }
        if (voiceInteractor == null) {
            mVoiceInteractor = null;
        } else {
            mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,
                    Looper.myLooper());
        }
!!!4795269.java!!!	getNextAutofillId() : int
        if (mLastAutofillId == Integer.MAX_VALUE - 1) {
            mLastAutofillId = View.LAST_APP_AUTOFILL_ID;
        }

        mLastAutofillId++;

        return mLastAutofillId;
!!!4795397.java!!!	isVoiceInteraction() : boolean
        return mVoiceInteractor != null;
!!!4795525.java!!!	isVoiceInteractionRoot() : boolean
        try {
            return mVoiceInteractor != null
                    && ActivityManager.getService().isRootVoiceInteraction(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!4795653.java!!!	getVoiceInteractor() : VoiceInteractor
        return mVoiceInteractor;
!!!4795781.java!!!	isLocalVoiceInteractionSupported() : boolean
        try {
            return ActivityManager.getService().supportsLocalVoiceInteraction();
        } catch (RemoteException re) {
        }
        return false;
!!!4795909.java!!!	startLocalVoiceInteraction(inout privateOptions : Bundle) : void
        try {
            ActivityManager.getService().startLocalVoiceInteraction(mToken, privateOptions);
        } catch (RemoteException re) {
        }
!!!4796293.java!!!	stopLocalVoiceInteraction() : void
        try {
            ActivityManager.getService().stopLocalVoiceInteraction(mToken);
        } catch (RemoteException re) {
        }
!!!4796549.java!!!	performSaveInstanceState(inout outState : Bundle) : void
        onSaveInstanceState(outState);
        saveManagedDialogs(outState);
        mActivityTransitionState.saveState(outState);
        storeHasCurrentPermissionRequest(outState);
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState);
!!!4796677.java!!!	performSaveInstanceState(inout outState : Bundle, inout outPersistentState : PersistableBundle) : void
        onSaveInstanceState(outState, outPersistentState);
        saveManagedDialogs(outState);
        storeHasCurrentPermissionRequest(outState);
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onSaveInstanceState " + this + ": " + outState +
                ", " + outPersistentState);
!!!4796805.java!!!	onSaveInstanceState(inout outState : Bundle) : void
        outState.putBundle(WINDOW_HIERARCHY_TAG, mWindow.saveHierarchyState());

        outState.putInt(LAST_AUTOFILL_ID, mLastAutofillId);
        Parcelable p = mFragments.saveAllState();
        if (p != null) {
            outState.putParcelable(FRAGMENTS_TAG, p);
        }
        if (mAutoFillResetNeeded) {
            outState.putBoolean(AUTOFILL_RESET_NEEDED, true);
            getAutofillManager().onSaveInstanceState(outState);
        }
        getApplication().dispatchActivitySaveInstanceState(this, outState);
!!!4796933.java!!!	onSaveInstanceState(inout outState : Bundle, inout outPersistentState : PersistableBundle) : void
        onSaveInstanceState(outState);
!!!4797061.java!!!	saveManagedDialogs(inout outState : Bundle) : void
        if (mManagedDialogs == null) {
            return;
        }

        final int numDialogs = mManagedDialogs.size();
        if (numDialogs == 0) {
            return;
        }

        Bundle dialogState = new Bundle();

        int[] ids = new int[mManagedDialogs.size()];

        // save each dialog's bundle, gather the ids
        for (int i = 0; i < numDialogs; i++) {
            final int key = mManagedDialogs.keyAt(i);
            ids[i] = key;
            final ManagedDialog md = mManagedDialogs.valueAt(i);
            dialogState.putBundle(savedDialogKeyFor(key), md.mDialog.onSaveInstanceState());
            if (md.mArgs != null) {
                dialogState.putBundle(savedDialogArgsKeyFor(key), md.mArgs);
            }
        }

        dialogState.putIntArray(SAVED_DIALOG_IDS_KEY, ids);
        outState.putBundle(SAVED_DIALOGS_TAG, dialogState);
!!!4797189.java!!!	onPause() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onPause " + this);
        getApplication().dispatchActivityPaused(this);
        mCalled = true;
!!!4797445.java!!!	onCreateThumbnail(inout outBitmap : Bitmap, inout canvas : Canvas) : boolean
        return false;
!!!4797573.java!!!	onCreateDescription() : CharSequence
        return null;
!!!4797957.java!!!	requestShowKeyboardShortcuts() : void
        Intent intent = new Intent(Intent.ACTION_SHOW_KEYBOARD_SHORTCUTS);
        intent.setPackage(KEYBOARD_SHORTCUTS_RECEIVER_PKG_NAME);
        sendBroadcastAsUser(intent, UserHandle.SYSTEM);
!!!4798085.java!!!	dismissKeyboardShortcutsHelper() : void
        Intent intent = new Intent(Intent.ACTION_DISMISS_KEYBOARD_SHORTCUTS);
        intent.setPackage(KEYBOARD_SHORTCUTS_RECEIVER_PKG_NAME);
        sendBroadcastAsUser(intent, UserHandle.SYSTEM);
!!!4798213.java!!!	onProvideKeyboardShortcuts(inout data : List<KeyboardShortcutGroup>, inout menu : Menu, in deviceId : int) : void
        if (menu == null) {
          return;
        }
        KeyboardShortcutGroup group = null;
        int menuSize = menu.size();
        for (int i = 0; i < menuSize; ++i) {
            final MenuItem item = menu.getItem(i);
            final CharSequence title = item.getTitle();
            final char alphaShortcut = item.getAlphabeticShortcut();
            final int alphaModifiers = item.getAlphabeticModifiers();
            if (title != null && alphaShortcut != MIN_VALUE) {
                if (group == null) {
                    final int resource = mApplication.getApplicationInfo().labelRes;
                    group = new KeyboardShortcutGroup(resource != 0 ? getString(resource) : null);
                }
                group.addItem(new KeyboardShortcutInfo(
                    title, alphaShortcut, alphaModifiers));
            }
        }
        if (group != null) {
            data.add(group);
        }
!!!4798341.java!!!	showAssist(inout args : Bundle) : boolean
        try {
            return ActivityManager.getService().showAssistFromActivity(mToken, args);
        } catch (RemoteException e) {
        }
        return false;
!!!4798469.java!!!	onStop() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onStop " + this);
        if (mActionBar != null) mActionBar.setShowHideAnimationEnabled(false);
        mActivityTransitionState.onStop();
        getApplication().dispatchActivityStopped(this);
        mTranslucentCallback = null;
        mCalled = true;
        if (isFinishing() && mAutoFillResetNeeded) {
            getAutofillManager().commit();
        }
!!!4798597.java!!!	onDestroy() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onDestroy " + this);
        mCalled = true;

        // dismiss any dialogs we are managing.
        if (mManagedDialogs != null) {
            final int numDialogs = mManagedDialogs.size();
            for (int i = 0; i < numDialogs; i++) {
                final ManagedDialog md = mManagedDialogs.valueAt(i);
                if (md.mDialog.isShowing()) {
                    md.mDialog.dismiss();
                }
            }
            mManagedDialogs = null;
        }

        // close any cursors we are managing.
        synchronized (mManagedCursors) {
            int numCursors = mManagedCursors.size();
            for (int i = 0; i < numCursors; i++) {
                ManagedCursor c = mManagedCursors.get(i);
                if (c != null) {
                    c.mCursor.close();
                }
            }
            mManagedCursors.clear();
        }

        // Close any open search dialog
        if (mSearchManager != null) {
            mSearchManager.stopSearch();
        }

        if (mActionBar != null) {
            mActionBar.onDestroy();
        }

        getApplication().dispatchActivityDestroyed(this);
!!!4798725.java!!!	reportFullyDrawn() : void
        if (mDoReportFullyDrawn) {
            mDoReportFullyDrawn = false;
            try {
                ActivityManager.getService().reportActivityFullyDrawn(mToken);
            } catch (RemoteException e) {
            }
        }
!!!4798853.java!!!	onMultiWindowModeChanged(inout isInMultiWindowMode : boolean, inout newConfig : Configuration) : void
        // Left deliberately empty. There should be no side effects if a direct
        // subclass of Activity does not call super.
        onMultiWindowModeChanged(isInMultiWindowMode);
!!!4798981.java!!!	onMultiWindowModeChanged(inout isInMultiWindowMode : boolean) : void
        // Left deliberately empty. There should be no side effects if a direct
        // subclass of Activity does not call super.
!!!4799109.java!!!	isInMultiWindowMode() : boolean
        try {
            return ActivityManager.getService().isInMultiWindowMode(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!4799237.java!!!	onPictureInPictureModeChanged(inout isInPictureInPictureMode : boolean, inout newConfig : Configuration) : void
        // Left deliberately empty. There should be no side effects if a direct
        // subclass of Activity does not call super.
        onPictureInPictureModeChanged(isInPictureInPictureMode);
!!!4799365.java!!!	onPictureInPictureModeChanged(inout isInPictureInPictureMode : boolean) : void
        // Left deliberately empty. There should be no side effects if a direct
        // subclass of Activity does not call super.
!!!4799493.java!!!	isInPictureInPictureMode() : boolean
        try {
            return ActivityManager.getService().isInPictureInPictureMode(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!4799621.java!!!	enterPictureInPictureMode() : void
        enterPictureInPictureMode(new PictureInPictureParams.Builder().build());
!!!4799749.java!!!	enterPictureInPictureMode(inout args : PictureInPictureArgs) : boolean
        return enterPictureInPictureMode(PictureInPictureArgs.convert(args));
!!!4799877.java!!!	enterPictureInPictureMode(inout params : PictureInPictureParams) : boolean
        try {
            if (params == null) {
                throw new IllegalArgumentException("Expected non-null picture-in-picture params");
            }
            return ActivityManagerNative.getDefault().enterPictureInPictureMode(mToken, params);
        } catch (RemoteException e) {
            return false;
        }
!!!4800005.java!!!	setPictureInPictureArgs(inout args : PictureInPictureArgs) : void
        setPictureInPictureParams(PictureInPictureArgs.convert(args));
!!!4800133.java!!!	setPictureInPictureParams(inout params : PictureInPictureParams) : void
        try {
            if (params == null) {
                throw new IllegalArgumentException("Expected non-null picture-in-picture params");
            }
            ActivityManagerNative.getDefault().setPictureInPictureParams(mToken, params);
        } catch (RemoteException e) {
        }
!!!4800261.java!!!	getMaxNumPictureInPictureActions() : int
        try {
            return ActivityManagerNative.getDefault().getMaxNumPictureInPictureActions(mToken);
        } catch (RemoteException e) {
            return 0;
        }
!!!4800389.java!!!	dispatchMovedToDisplay(in displayId : int, inout config : Configuration) : void
        updateDisplay(displayId);
        onMovedToDisplay(displayId, config);
!!!4800645.java!!!	onConfigurationChanged(inout newConfig : Configuration) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onConfigurationChanged " + this + ": " + newConfig);
        mCalled = true;

        mFragments.dispatchConfigurationChanged(newConfig);

        if (mWindow != null) {
            // Pass the configuration changed event to the window
            mWindow.onConfigurationChanged(newConfig);
        }

        if (mActionBar != null) {
            // Do this last; the action bar will need to access
            // view changes from above.
            mActionBar.onConfigurationChanged(newConfig);
        }
!!!4800773.java!!!	getChangingConfigurations() : int
        return mConfigChangeFlags;
!!!4800901.java!!!	getLastNonConfigurationInstance() : Object
        return mLastNonConfigurationInstances != null
                ? mLastNonConfigurationInstances.activity : null;
!!!4801029.java!!!	onRetainNonConfigurationInstance() : Object
        return null;
!!!4801157.java!!!	getLastNonConfigurationChildInstances() : HashMap<String, Object>
        return mLastNonConfigurationInstances != null
                ? mLastNonConfigurationInstances.children : null;
!!!4801285.java!!!	onRetainNonConfigurationChildInstances() : HashMap<String,Object>
        return null;
!!!4801413.java!!!	retainNonConfigurationInstances() : Activity::NonConfigurationInstances
        Object activity = onRetainNonConfigurationInstance();
        HashMap<String, Object> children = onRetainNonConfigurationChildInstances();
        FragmentManagerNonConfig fragments = mFragments.retainNestedNonConfig();

        // We're already stopped but we've been asked to retain.
        // Our fragments are taken care of but we need to mark the loaders for retention.
        // In order to do this correctly we need to restart the loaders first before
        // handing them off to the next activity.
        mFragments.doLoaderStart();
        mFragments.doLoaderStop(true);
        ArrayMap<String, LoaderManager> loaders = mFragments.retainLoaderNonConfig();

        if (activity == null && children == null && fragments == null && loaders == null
                && mVoiceInteractor == null) {
            return null;
        }

        NonConfigurationInstances nci = new NonConfigurationInstances();
        nci.activity = activity;
        nci.children = children;
        nci.fragments = fragments;
        nci.loaders = loaders;
        if (mVoiceInteractor != null) {
            mVoiceInteractor.retainInstance();
            nci.voiceInteractor = mVoiceInteractor;
        }
        return nci;
!!!4801541.java!!!	onLowMemory() : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onLowMemory " + this);
        mCalled = true;
        mFragments.dispatchLowMemory();
!!!4801669.java!!!	onTrimMemory(in level : int) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG, "onTrimMemory " + this + ": " + level);
        mCalled = true;
        mFragments.dispatchTrimMemory(level);
!!!4801797.java!!!	getFragmentManager() : FragmentManager
        return mFragments.getFragmentManager();
!!!4802053.java!!!	managedQuery(inout uri : Uri, inout projection : String [[]], in selection : String, in sortOrder : String) : Cursor
        Cursor c = getContentResolver().query(uri, projection, selection, null, sortOrder);
        if (c != null) {
            startManagingCursor(c);
        }
        return c;
!!!4802181.java!!!	managedQuery(inout uri : Uri, inout projection : String [[]], in selection : String, inout selectionArgs : String [[]], in sortOrder : String) : Cursor
        Cursor c = getContentResolver().query(uri, projection, selection, selectionArgs, sortOrder);
        if (c != null) {
            startManagingCursor(c);
        }
        return c;
!!!4802309.java!!!	startManagingCursor(inout c : Cursor) : void
        synchronized (mManagedCursors) {
            mManagedCursors.add(new ManagedCursor(c));
        }
!!!4802437.java!!!	stopManagingCursor(inout c : Cursor) : void
        synchronized (mManagedCursors) {
            final int N = mManagedCursors.size();
            for (int i=0; i<N; i++) {
                ManagedCursor mc = mManagedCursors.get(i);
                if (mc.mCursor == c) {
                    mManagedCursors.remove(i);
                    break;
                }
            }
        }
!!!4802693.java!!!	findViewById(in id : int) : T
        return getWindow().findViewById(id);
!!!4802821.java!!!	getActionBar() : ActionBar
        initWindowDecorActionBar();
        return mActionBar;
!!!4802949.java!!!	setActionBar(inout toolbar : Toolbar) : void
        final ActionBar ab = getActionBar();
        if (ab instanceof WindowDecorActionBar) {
            throw new IllegalStateException("This Activity already has an action bar supplied " +
                    "by the window decor. Do not request Window.FEATURE_ACTION_BAR and set " +
                    "android:windowActionBar to false in your theme to use a Toolbar instead.");
        }

        // If we reach here then we're setting a new action bar
        // First clear out the MenuInflater to make sure that it is valid for the new Action Bar
        mMenuInflater = null;

        // If we have an action bar currently, destroy it
        if (ab != null) {
            ab.onDestroy();
        }

        if (toolbar != null) {
            final ToolbarActionBar tbab = new ToolbarActionBar(toolbar, getTitle(), this);
            mActionBar = tbab;
            mWindow.setCallback(tbab.getWrappedWindowCallback());
        } else {
            mActionBar = null;
            // Re-set the original window callback since we may have already set a Toolbar wrapper
            mWindow.setCallback(this);
        }

        invalidateOptionsMenu();
!!!4803077.java!!!	initWindowDecorActionBar() : void
        Window window = getWindow();

        // Initializing the window decor can change window feature flags.
        // Make sure that we have the correct set before performing the test below.
        window.getDecorView();

        if (isChild() || !window.hasFeature(Window.FEATURE_ACTION_BAR) || mActionBar != null) {
            return;
        }

        mActionBar = new WindowDecorActionBar(this);
        mActionBar.setDefaultDisplayHomeAsUpEnabled(mEnableDefaultActionBarUp);

        mWindow.setDefaultIcon(mActivityInfo.getIconResource());
        mWindow.setDefaultLogo(mActivityInfo.getLogoResource());
!!!4803205.java!!!	setContentView(in layoutResID : int) : void
        getWindow().setContentView(layoutResID);
        initWindowDecorActionBar();
!!!4803333.java!!!	setContentView(inout view : View) : void
        getWindow().setContentView(view);
        initWindowDecorActionBar();
!!!4803461.java!!!	setContentView(inout view : View, inout params : ViewGroup::LayoutParams) : void
        getWindow().setContentView(view, params);
        initWindowDecorActionBar();
!!!4803589.java!!!	addContentView(inout view : View, inout params : ViewGroup::LayoutParams) : void
        getWindow().addContentView(view, params);
        initWindowDecorActionBar();
!!!4803717.java!!!	getContentTransitionManager() : TransitionManager
        return getWindow().getTransitionManager();
!!!4803845.java!!!	setContentTransitionManager(inout tm : TransitionManager) : void
        getWindow().setTransitionManager(tm);
!!!4803973.java!!!	getContentScene() : Scene
        return getWindow().getContentScene();
!!!4804101.java!!!	setFinishOnTouchOutside(inout finish : boolean) : void
        mWindow.setCloseOnTouchOutside(finish);
!!!4804229.java!!!	setDefaultKeyMode(in mode : int) : void
        mDefaultKeyMode = mode;

        // Some modes use a SpannableStringBuilder to track & dispatch input events
        // This list must remain in sync with the switch in onKeyDown()
        switch (mode) {
        case DEFAULT_KEYS_DISABLE:
        case DEFAULT_KEYS_SHORTCUT:
            mDefaultKeySsb = null;      // not used in these modes
            break;
        case DEFAULT_KEYS_DIALER:
        case DEFAULT_KEYS_SEARCH_LOCAL:
        case DEFAULT_KEYS_SEARCH_GLOBAL:
            mDefaultKeySsb = new SpannableStringBuilder();
            Selection.setSelection(mDefaultKeySsb,0);
            break;
        default:
            throw new IllegalArgumentException();
        }
!!!4804357.java!!!	onKeyDown(in keyCode : int, inout event : KeyEvent) : boolean
        if (keyCode == KeyEvent.KEYCODE_BACK) {
            if (getApplicationInfo().targetSdkVersion
                    >= Build.VERSION_CODES.ECLAIR) {
                event.startTracking();
            } else {
                onBackPressed();
            }
            return true;
        }

        if (mDefaultKeyMode == DEFAULT_KEYS_DISABLE) {
            return false;
        } else if (mDefaultKeyMode == DEFAULT_KEYS_SHORTCUT) {
            Window w = getWindow();
            if (w.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                    w.performPanelShortcut(Window.FEATURE_OPTIONS_PANEL, keyCode, event,
                            Menu.FLAG_ALWAYS_PERFORM_CLOSE)) {
                return true;
            }
            return false;
        } else if (keyCode == KeyEvent.KEYCODE_TAB) {
            // Don't consume TAB here since it's used for navigation. Arrow keys
            // aren't considered "typing keys" so they already won't get consumed.
            return false;
        } else {
            // Common code for DEFAULT_KEYS_DIALER & DEFAULT_KEYS_SEARCH_*
            boolean clearSpannable = false;
            boolean handled;
            if ((event.getRepeatCount() != 0) || event.isSystem()) {
                clearSpannable = true;
                handled = false;
            } else {
                handled = TextKeyListener.getInstance().onKeyDown(
                        null, mDefaultKeySsb, keyCode, event);
                if (handled && mDefaultKeySsb.length() > 0) {
                    // something useable has been typed - dispatch it now.

                    final String str = mDefaultKeySsb.toString();
                    clearSpannable = true;

                    switch (mDefaultKeyMode) {
                    case DEFAULT_KEYS_DIALER:
                        Intent intent = new Intent(Intent.ACTION_DIAL,  Uri.parse("tel:" + str));
                        intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
                        startActivity(intent);
                        break;
                    case DEFAULT_KEYS_SEARCH_LOCAL:
                        startSearch(str, false, null, false);
                        break;
                    case DEFAULT_KEYS_SEARCH_GLOBAL:
                        startSearch(str, false, null, true);
                        break;
                    }
                }
            }
            if (clearSpannable) {
                mDefaultKeySsb.clear();
                mDefaultKeySsb.clearSpans();
                Selection.setSelection(mDefaultKeySsb,0);
            }
            return handled;
        }
!!!4804485.java!!!	onKeyLongPress(in keyCode : int, inout event : KeyEvent) : boolean
        return false;
!!!4804613.java!!!	onKeyUp(in keyCode : int, inout event : KeyEvent) : boolean
        if (getApplicationInfo().targetSdkVersion
                >= Build.VERSION_CODES.ECLAIR) {
            if (keyCode == KeyEvent.KEYCODE_BACK && event.isTracking()
                    && !event.isCanceled()) {
                onBackPressed();
                return true;
            }
        }
        return false;
!!!4804741.java!!!	onKeyMultiple(in keyCode : int, in repeatCount : int, inout event : KeyEvent) : boolean
        return false;
!!!4804869.java!!!	onBackPressed() : void
        if (mActionBar != null && mActionBar.collapseActionView()) {
            return;
        }

        FragmentManager fragmentManager = mFragments.getFragmentManager();

        if (fragmentManager.isStateSaved() || !fragmentManager.popBackStackImmediate()) {
            finishAfterTransition();
        }
!!!4804997.java!!!	onKeyShortcut(in keyCode : int, inout event : KeyEvent) : boolean
        // Let the Action Bar have a chance at handling the shortcut.
        ActionBar actionBar = getActionBar();
        return (actionBar != null && actionBar.onKeyShortcut(keyCode, event));
!!!4805125.java!!!	onTouchEvent(inout event : MotionEvent) : boolean
        if (mWindow.shouldCloseOnTouch(this, event)) {
            finish();
            return true;
        }

        return false;
!!!4805253.java!!!	onTrackballEvent(inout event : MotionEvent) : boolean
        return false;
!!!4805381.java!!!	onGenericMotionEvent(inout event : MotionEvent) : boolean
        return false;
!!!4805637.java!!!	onWindowAttributesChanged(inout params : WindowManager::LayoutParams) : void
        // Update window manager if: we have a view, that view is
        // attached to its parent (which will be a RootView), and
        // this activity is not embedded.
        if (mParent == null) {
            View decor = mDecor;
            if (decor != null && decor.getParent() != null) {
                getWindowManager().updateViewLayout(decor, params);
            }
        }
!!!4806277.java!!!	hasWindowFocus() : boolean
        Window w = getWindow();
        if (w != null) {
            View d = w.getDecorView();
            if (d != null) {
                return d.hasWindowFocus();
            }
        }
        return false;
!!!4806405.java!!!	onWindowDismissed(inout finishTask : boolean, inout suppressWindowTransition : boolean) : void
        finish(finishTask ? FINISH_TASK_WITH_ACTIVITY : DONT_FINISH_TASK_WITH_ACTIVITY);
        if (suppressWindowTransition) {
            overridePendingTransition(0, 0);
        }
!!!4806533.java!!!	exitFreeformMode() : void
        ActivityManager.getService().exitFreeformMode(mToken);
!!!4806661.java!!!	getWindowStackId() : int
        return ActivityManager.getService().getActivityStackId(mToken);
!!!4806789.java!!!	enterPictureInPictureModeIfPossible() : void
        if (mActivityInfo.supportsPictureInPicture()) {
            enterPictureInPictureMode();
        }
!!!4806917.java!!!	dispatchKeyEvent(inout event : KeyEvent) : boolean
        onUserInteraction();

        // Let action bars open menus in response to the menu key prioritized over
        // the window handling it
        final int keyCode = event.getKeyCode();
        if (keyCode == KeyEvent.KEYCODE_MENU &&
                mActionBar != null && mActionBar.onMenuKeyEvent(event)) {
            return true;
        }

        Window win = getWindow();
        if (win.superDispatchKeyEvent(event)) {
            return true;
        }
        View decor = mDecor;
        if (decor == null) decor = win.getDecorView();
        return event.dispatch(this, decor != null
                ? decor.getKeyDispatcherState() : null, this);
!!!4807045.java!!!	dispatchKeyShortcutEvent(inout event : KeyEvent) : boolean
        onUserInteraction();
        if (getWindow().superDispatchKeyShortcutEvent(event)) {
            return true;
        }
        return onKeyShortcut(event.getKeyCode(), event);
!!!4807173.java!!!	dispatchTouchEvent(inout ev : MotionEvent) : boolean
        if (ev.getAction() == MotionEvent.ACTION_DOWN) {
            onUserInteraction();
        }
        if (getWindow().superDispatchTouchEvent(ev)) {
            return true;
        }
        return onTouchEvent(ev);
!!!4807301.java!!!	dispatchTrackballEvent(inout ev : MotionEvent) : boolean
        onUserInteraction();
        if (getWindow().superDispatchTrackballEvent(ev)) {
            return true;
        }
        return onTrackballEvent(ev);
!!!4807429.java!!!	dispatchGenericMotionEvent(inout ev : MotionEvent) : boolean
        onUserInteraction();
        if (getWindow().superDispatchGenericMotionEvent(ev)) {
            return true;
        }
        return onGenericMotionEvent(ev);
!!!4807557.java!!!	dispatchPopulateAccessibilityEvent(inout event : AccessibilityEvent) : boolean
        event.setClassName(getClass().getName());
        event.setPackageName(getPackageName());

        LayoutParams params = getWindow().getAttributes();
        boolean isFullScreen = (params.width == LayoutParams.MATCH_PARENT) &&
            (params.height == LayoutParams.MATCH_PARENT);
        event.setFullScreen(isFullScreen);

        CharSequence title = getTitle();
        if (!TextUtils.isEmpty(title)) {
           event.getText().add(title);
        }

        return true;
!!!4807685.java!!!	onCreatePanelView(in featureId : int) : View
        return null;
!!!4807813.java!!!	onCreatePanelMenu(in featureId : int, inout menu : Menu) : boolean
        if (featureId == Window.FEATURE_OPTIONS_PANEL) {
            boolean show = onCreateOptionsMenu(menu);
            show |= mFragments.dispatchCreateOptionsMenu(menu, getMenuInflater());
            return show;
        }
        return false;
!!!4807941.java!!!	onPreparePanel(in featureId : int, inout view : View, inout menu : Menu) : boolean
        if (featureId == Window.FEATURE_OPTIONS_PANEL && menu != null) {
            boolean goforit = onPrepareOptionsMenu(menu);
            goforit |= mFragments.dispatchPrepareOptionsMenu(menu);
            return goforit;
        }
        return true;
!!!4808069.java!!!	onMenuOpened(in featureId : int, inout menu : Menu) : boolean
        if (featureId == Window.FEATURE_ACTION_BAR) {
            initWindowDecorActionBar();
            if (mActionBar != null) {
                mActionBar.dispatchMenuVisibilityChanged(true);
            } else {
                Log.e(TAG, "Tried to open action bar menu with no action bar");
            }
        }
        return true;
!!!4808197.java!!!	onMenuItemSelected(in featureId : int, inout item : MenuItem) : boolean
        CharSequence titleCondensed = item.getTitleCondensed();

        switch (featureId) {
            case Window.FEATURE_OPTIONS_PANEL:
                // Put event logging here so it gets called even if subclass
                // doesn't call through to superclass's implmeentation of each
                // of these methods below
                if(titleCondensed != null) {
                    EventLog.writeEvent(50000, 0, titleCondensed.toString());
                }
                if (onOptionsItemSelected(item)) {
                    return true;
                }
                if (mFragments.dispatchOptionsItemSelected(item)) {
                    return true;
                }
                if (item.getItemId() == android.R.id.home && mActionBar != null &&
                        (mActionBar.getDisplayOptions() & ActionBar.DISPLAY_HOME_AS_UP) != 0) {
                    if (mParent == null) {
                        return onNavigateUp();
                    } else {
                        return mParent.onNavigateUpFromChild(this);
                    }
                }
                return false;

            case Window.FEATURE_CONTEXT_MENU:
                if(titleCondensed != null) {
                    EventLog.writeEvent(50000, 1, titleCondensed.toString());
                }
                if (onContextItemSelected(item)) {
                    return true;
                }
                return mFragments.dispatchContextItemSelected(item);

            default:
                return false;
        }
!!!4808325.java!!!	onPanelClosed(in featureId : int, inout menu : Menu) : void
        switch (featureId) {
            case Window.FEATURE_OPTIONS_PANEL:
                mFragments.dispatchOptionsMenuClosed(menu);
                onOptionsMenuClosed(menu);
                break;

            case Window.FEATURE_CONTEXT_MENU:
                onContextMenuClosed(menu);
                break;

            case Window.FEATURE_ACTION_BAR:
                initWindowDecorActionBar();
                mActionBar.dispatchMenuVisibilityChanged(false);
                break;
        }
!!!4808453.java!!!	invalidateOptionsMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                (mActionBar == null || !mActionBar.invalidateOptionsMenu())) {
            mWindow.invalidatePanelMenu(Window.FEATURE_OPTIONS_PANEL);
        }
!!!4808581.java!!!	onCreateOptionsMenu(inout menu : Menu) : boolean
        if (mParent != null) {
            return mParent.onCreateOptionsMenu(menu);
        }
        return true;
!!!4808709.java!!!	onPrepareOptionsMenu(inout menu : Menu) : boolean
        if (mParent != null) {
            return mParent.onPrepareOptionsMenu(menu);
        }
        return true;
!!!4808837.java!!!	onOptionsItemSelected(inout item : MenuItem) : boolean
        if (mParent != null) {
            return mParent.onOptionsItemSelected(item);
        }
        return false;
!!!4808965.java!!!	onNavigateUp() : boolean
        // Automatically handle hierarchical Up navigation if the proper
        // metadata is available.
        Intent upIntent = getParentActivityIntent();
        if (upIntent != null) {
            if (mActivityInfo.taskAffinity == null) {
                // Activities with a null affinity are special; they really shouldn't
                // specify a parent activity intent in the first place. Just finish
                // the current activity and call it a day.
                finish();
            } else if (shouldUpRecreateTask(upIntent)) {
                TaskStackBuilder b = TaskStackBuilder.create(this);
                onCreateNavigateUpTaskStack(b);
                onPrepareNavigateUpTaskStack(b);
                b.startActivities();

                // We can't finishAffinity if we have a result.
                // Fall back and simply finish the current activity instead.
                if (mResultCode != RESULT_CANCELED || mResultData != null) {
                    // Tell the developer what's going on to avoid hair-pulling.
                    Log.i(TAG, "onNavigateUp only finishing topmost activity to return a result");
                    finish();
                } else {
                    finishAffinity();
                }
            } else {
                navigateUpTo(upIntent);
            }
            return true;
        }
        return false;
!!!4809093.java!!!	onNavigateUpFromChild(inout child : Activity) : boolean
        return onNavigateUp();
!!!4809221.java!!!	onCreateNavigateUpTaskStack(inout builder : TaskStackBuilder) : void
        builder.addParentStack(this);
!!!4809477.java!!!	onOptionsMenuClosed(inout menu : Menu) : void
        if (mParent != null) {
            mParent.onOptionsMenuClosed(menu);
        }
!!!4809605.java!!!	openOptionsMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                (mActionBar == null || !mActionBar.openOptionsMenu())) {
            mWindow.openPanel(Window.FEATURE_OPTIONS_PANEL, null);
        }
!!!4809733.java!!!	closeOptionsMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_OPTIONS_PANEL) &&
                (mActionBar == null || !mActionBar.closeOptionsMenu())) {
            mWindow.closePanel(Window.FEATURE_OPTIONS_PANEL);
        }
!!!4809989.java!!!	registerForContextMenu(inout view : View) : void
        view.setOnCreateContextMenuListener(this);
!!!4810117.java!!!	unregisterForContextMenu(inout view : View) : void
        view.setOnCreateContextMenuListener(null);
!!!4810245.java!!!	openContextMenu(inout view : View) : void
        view.showContextMenu();
!!!4810373.java!!!	closeContextMenu() : void
        if (mWindow.hasFeature(Window.FEATURE_CONTEXT_MENU)) {
            mWindow.closePanel(Window.FEATURE_CONTEXT_MENU);
        }
!!!4810501.java!!!	onContextItemSelected(inout item : MenuItem) : boolean
        if (mParent != null) {
            return mParent.onContextItemSelected(item);
        }
        return false;
!!!4810629.java!!!	onContextMenuClosed(inout menu : Menu) : void
        if (mParent != null) {
            mParent.onContextMenuClosed(menu);
        }
!!!4810757.java!!!	onCreateDialog(in id : int) : Dialog
        return null;
!!!4810885.java!!!	onCreateDialog(in id : int, inout args : Bundle) : Dialog
        return onCreateDialog(id);
!!!4811013.java!!!	onPrepareDialog(in id : int, inout dialog : Dialog) : void
        dialog.setOwnerActivity(this);
!!!4811141.java!!!	onPrepareDialog(in id : int, inout dialog : Dialog, inout args : Bundle) : void
        onPrepareDialog(id, dialog);
!!!4811269.java!!!	showDialog(in id : int) : void
        showDialog(id, null);
!!!4811397.java!!!	showDialog(in id : int, inout args : Bundle) : boolean
        if (mManagedDialogs == null) {
            mManagedDialogs = new SparseArray<ManagedDialog>();
        }
        ManagedDialog md = mManagedDialogs.get(id);
        if (md == null) {
            md = new ManagedDialog();
            md.mDialog = createDialog(id, null, args);
            if (md.mDialog == null) {
                return false;
            }
            mManagedDialogs.put(id, md);
        }

        md.mArgs = args;
        onPrepareDialog(id, md.mDialog, args);
        md.mDialog.show();
        return true;
!!!4811525.java!!!	dismissDialog(in id : int) : void
        if (mManagedDialogs == null) {
            throw missingDialog(id);
        }

        final ManagedDialog md = mManagedDialogs.get(id);
        if (md == null) {
            throw missingDialog(id);
        }
        md.mDialog.dismiss();
!!!4811653.java!!!	missingDialog(in id : int) : IllegalArgumentException
        return new IllegalArgumentException("no dialog with id " + id + " was ever "
                + "shown via Activity#showDialog");
!!!4811781.java!!!	removeDialog(in id : int) : void
        if (mManagedDialogs != null) {
            final ManagedDialog md = mManagedDialogs.get(id);
            if (md != null) {
                md.mDialog.dismiss();
                mManagedDialogs.remove(id);
            }
        }
!!!4811909.java!!!	onSearchRequested(inout searchEvent : SearchEvent) : boolean
        mSearchEvent = searchEvent;
        boolean result = onSearchRequested();
        mSearchEvent = null;
        return result;
!!!4812037.java!!!	onSearchRequested() : boolean
        if ((getResources().getConfiguration().uiMode&Configuration.UI_MODE_TYPE_MASK)
                != Configuration.UI_MODE_TYPE_TELEVISION) {
            startSearch(null, false, null, false);
            return true;
        } else {
            return false;
        }
!!!4812165.java!!!	getSearchEvent() : SearchEvent
        return mSearchEvent;
!!!4812293.java!!!	startSearch(in initialQuery : String, inout selectInitialQuery : boolean, inout appSearchData : Bundle, inout globalSearch : boolean) : void
        ensureSearchManager();
        mSearchManager.startSearch(initialQuery, selectInitialQuery, getComponentName(),
                appSearchData, globalSearch);
!!!4812421.java!!!	triggerSearch(in query : String, inout appSearchData : Bundle) : void
        ensureSearchManager();
        mSearchManager.triggerSearch(query, getComponentName(), appSearchData);
!!!4812549.java!!!	takeKeyEvents(inout get : boolean) : void
        getWindow().takeKeyEvents(get);
!!!4812677.java!!!	requestWindowFeature(in featureId : int) : boolean
        return getWindow().requestFeature(featureId);
!!!4812805.java!!!	setFeatureDrawableResource(in featureId : int, in resId : int) : void
        getWindow().setFeatureDrawableResource(featureId, resId);
!!!4812933.java!!!	setFeatureDrawableUri(in featureId : int, inout uri : Uri) : void
        getWindow().setFeatureDrawableUri(featureId, uri);
!!!4813061.java!!!	setFeatureDrawable(in featureId : int, inout drawable : Drawable) : void
        getWindow().setFeatureDrawable(featureId, drawable);
!!!4813189.java!!!	setFeatureDrawableAlpha(in featureId : int, in alpha : int) : void
        getWindow().setFeatureDrawableAlpha(featureId, alpha);
!!!4813317.java!!!	getLayoutInflater() : LayoutInflater
        return getWindow().getLayoutInflater();
!!!4813445.java!!!	getMenuInflater() : MenuInflater
        // Make sure that action views can get an appropriate theme.
        if (mMenuInflater == null) {
            initWindowDecorActionBar();
            if (mActionBar != null) {
                mMenuInflater = new MenuInflater(mActionBar.getThemedContext(), this);
            } else {
                mMenuInflater = new MenuInflater(this);
            }
        }
        return mMenuInflater;
!!!4813573.java!!!	setTheme(in resid : int) : void
        super.setTheme(resid);
        mWindow.setTheme(resid);
!!!4813701.java!!!	onApplyThemeResource(inout theme : Resources::Theme, in resid : int, inout first : boolean) : void
        if (mParent == null) {
            super.onApplyThemeResource(theme, resid, first);
        } else {
            try {
                theme.setTo(mParent.getTheme());
            } catch (Exception e) {
                // Empty
            }
            theme.applyStyle(resid, false);
        }

        // Get the primary color and update the TaskDescription for this activity
        TypedArray a = theme.obtainStyledAttributes(
                com.android.internal.R.styleable.ActivityTaskDescription);
        if (mTaskDescription.getPrimaryColor() == 0) {
            int colorPrimary = a.getColor(
                    com.android.internal.R.styleable.ActivityTaskDescription_colorPrimary, 0);
            if (colorPrimary != 0 && Color.alpha(colorPrimary) == 0xFF) {
                mTaskDescription.setPrimaryColor(colorPrimary);
            }
        }

        int colorBackground = a.getColor(
                com.android.internal.R.styleable.ActivityTaskDescription_colorBackground, 0);
        if (colorBackground != 0 && Color.alpha(colorBackground) == 0xFF) {
            mTaskDescription.setBackgroundColor(colorBackground);
        }

        final int statusBarColor = a.getColor(
                com.android.internal.R.styleable.ActivityTaskDescription_statusBarColor, 0);
        if (statusBarColor != 0) {
            mTaskDescription.setStatusBarColor(statusBarColor);
        }

        final int navigationBarColor = a.getColor(
                com.android.internal.R.styleable.ActivityTaskDescription_navigationBarColor, 0);
        if (navigationBarColor != 0) {
            mTaskDescription.setNavigationBarColor(navigationBarColor);
        }

        a.recycle();
        setTaskDescription(mTaskDescription);
!!!4813829.java!!!	requestPermissions(inout permissions : String [[]], in requestCode : int) : void
        if (requestCode < 0) {
            throw new IllegalArgumentException("requestCode should be >= 0");
        }
        if (mHasCurrentPermissionsRequest) {
            Log.w(TAG, "Can reqeust only one set of permissions at a time");
            // Dispatch the callback with empty arrays which means a cancellation.
            onRequestPermissionsResult(requestCode, new String[0], new int[0]);
            return;
        }
        Intent intent = getPackageManager().buildRequestPermissionsIntent(permissions);
        startActivityForResult(REQUEST_PERMISSIONS_WHO_PREFIX, intent, requestCode, null);
        mHasCurrentPermissionsRequest = true;
!!!4813957.java!!!	onRequestPermissionsResult(in requestCode : int, inout permissions : String [[]], inout grantResults : int [[]]) : void
        /* callback - no nothing */
!!!4814085.java!!!	shouldShowRequestPermissionRationale(in permission : String) : boolean
        return getPackageManager().shouldShowRequestPermissionRationale(permission);
!!!4814213.java!!!	startActivityForResult(inout intent : Intent, in requestCode : int) : void
        startActivityForResult(intent, requestCode, null);
!!!4814341.java!!!	startActivityForResult(inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        if (mParent == null) {
            options = transferSpringboardActivityOptions(options);
            Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                    this, mMainThread.getApplicationThread(), mToken, this,
                    intent, requestCode, options);
            if (ar != null) {
                mMainThread.sendActivityResult(
                    mToken, mEmbeddedID, requestCode, ar.getResultCode(),
                    ar.getResultData());
            }
            if (requestCode >= 0) {
                // If this start is requesting a result, we can avoid making
                // the activity visible until the result is received.  Setting
                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
                // activity hidden during this time, to avoid flickering.
                // This can only be done when a result is requested because
                // that guarantees we will get information back when the
                // activity is finished, no matter what happens to it.
                mStartedActivity = true;
            }

            cancelInputsAndStartExitTransition(options);
            // TODO Consider clearing/flushing other event sources and events for child windows.
        } else {
            if (options != null) {
                mParent.startActivityFromChild(this, intent, requestCode, options);
            } else {
                // Note we want to go through this method for compatibility with
                // existing applications that may have overridden it.
                mParent.startActivityFromChild(this, intent, requestCode);
            }
        }
!!!4814469.java!!!	cancelInputsAndStartExitTransition(inout options : Bundle) : void
        final View decor = mWindow != null ? mWindow.peekDecorView() : null;
        if (decor != null) {
            decor.cancelPendingInputEvents();
        }
        if (options != null && !isTopOfTask()) {
            mActivityTransitionState.startExitOutTransition(this, options);
        }
!!!4814597.java!!!	isActivityTransitionRunning() : boolean
        return mActivityTransitionState.isTransitionRunning();
!!!4814725.java!!!	transferSpringboardActivityOptions(inout options : Bundle) : Bundle
        if (options == null && (mWindow != null && !mWindow.isActive())) {
            final ActivityOptions activityOptions = getActivityOptions();
            if (activityOptions != null &&
                    activityOptions.getAnimationType() == ActivityOptions.ANIM_SCENE_TRANSITION) {
                return activityOptions.toBundle();
            }
        }
        return options;
!!!4814853.java!!!	startActivityForResultAsUser(inout intent : Intent, in requestCode : int, inout user : UserHandle) : void
        startActivityForResultAsUser(intent, requestCode, null, user);
!!!4814981.java!!!	startActivityForResultAsUser(inout intent : Intent, in requestCode : int, inout options : Bundle, inout user : UserHandle) : void
        startActivityForResultAsUser(intent, mEmbeddedID, requestCode, options, user);
!!!4815109.java!!!	startActivityForResultAsUser(inout intent : Intent, in resultWho : String, in requestCode : int, inout options : Bundle, inout user : UserHandle) : void
        if (mParent != null) {
            throw new RuntimeException("Can't be called from a child");
        }
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar = mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, resultWho, intent, requestCode,
                options, user);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, requestCode, ar.getResultCode(), ar.getResultData());
        }
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }

        cancelInputsAndStartExitTransition(options);
!!!4815237.java!!!	startActivityAsUser(inout intent : Intent, inout user : UserHandle) : void
        startActivityAsUser(intent, null, user);
!!!4815365.java!!!	startActivityAsUser(inout intent : Intent, inout options : Bundle, inout user : UserHandle) : void
        if (mParent != null) {
            throw new RuntimeException("Can't be called from a child");
        }
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivity(
                        this, mMainThread.getApplicationThread(), mToken, mEmbeddedID,
                        intent, -1, options, user);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, -1, ar.getResultCode(),
                ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!4815493.java!!!	startActivityAsCaller(inout intent : Intent, inout options : Bundle, inout ignoreTargetSecurity : boolean, in userId : int) : void
        if (mParent != null) {
            throw new RuntimeException("Can't be called from a child");
        }
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
                mInstrumentation.execStartActivityAsCaller(
                        this, mMainThread.getApplicationThread(), mToken, this,
                        intent, -1, options, ignoreTargetSecurity, userId);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, mEmbeddedID, -1, ar.getResultCode(),
                ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!4815621.java!!!	startIntentSenderForResult(inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int) : void
        startIntentSenderForResult(intent, requestCode, fillInIntent, flagsMask,
                flagsValues, extraFlags, null);
!!!4815749.java!!!	startIntentSenderForResult(inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        if (mParent == null) {
            startIntentSenderForResultInner(intent, mEmbeddedID, requestCode, fillInIntent,
                    flagsMask, flagsValues, options);
        } else if (options != null) {
            mParent.startIntentSenderFromChild(this, intent, requestCode,
                    fillInIntent, flagsMask, flagsValues, extraFlags, options);
        } else {
            // Note we want to go through this call for compatibility with
            // existing applications that may have overridden the method.
            mParent.startIntentSenderFromChild(this, intent, requestCode,
                    fillInIntent, flagsMask, flagsValues, extraFlags);
        }
!!!4815877.java!!!	startIntentSenderForResultInner(inout intent : IntentSender, in who : String, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, inout options : Bundle) : void
        try {
            String resolvedType = null;
            if (fillInIntent != null) {
                fillInIntent.migrateExtraStreamToClipData();
                fillInIntent.prepareToLeaveProcess(this);
                resolvedType = fillInIntent.resolveTypeIfNeeded(getContentResolver());
            }
            int result = ActivityManager.getService()
                .startActivityIntentSender(mMainThread.getApplicationThread(),
                        intent != null ? intent.getTarget() : null,
                        intent != null ? intent.getWhitelistToken() : null,
                        fillInIntent, resolvedType, mToken, who,
                        requestCode, flagsMask, flagsValues, options);
            if (result == ActivityManager.START_CANCELED) {
                throw new IntentSender.SendIntentException();
            }
            Instrumentation.checkStartActivityResult(result, null);
        } catch (RemoteException e) {
        }
        if (requestCode >= 0) {
            // If this start is requesting a result, we can avoid making
            // the activity visible until the result is received.  Setting
            // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
            // activity hidden during this time, to avoid flickering.
            // This can only be done when a result is requested because
            // that guarantees we will get information back when the
            // activity is finished, no matter what happens to it.
            mStartedActivity = true;
        }
!!!4816005.java!!!	startActivity(inout intent : Intent) : void
        this.startActivity(intent, null);
!!!4816133.java!!!	startActivity(inout intent : Intent, inout options : Bundle) : void
        if (options != null) {
            startActivityForResult(intent, -1, options);
        } else {
            // Note we want to go through this call for compatibility with
            // applications that may have overridden the method.
            startActivityForResult(intent, -1);
        }
!!!4816261.java!!!	startActivities(inout intents : Intent [[]]) : void
        startActivities(intents, null);
!!!4816389.java!!!	startActivities(inout intents : Intent [[]], inout options : Bundle) : void
        mInstrumentation.execStartActivities(this, mMainThread.getApplicationThread(),
                mToken, this, intents, options);
!!!4816517.java!!!	startIntentSender(inout intent : IntentSender, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int) : void
        startIntentSender(intent, fillInIntent, flagsMask, flagsValues,
                extraFlags, null);
!!!4816645.java!!!	startIntentSender(inout intent : IntentSender, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        if (options != null) {
            startIntentSenderForResult(intent, -1, fillInIntent, flagsMask,
                    flagsValues, extraFlags, options);
        } else {
            // Note we want to go through this call for compatibility with
            // applications that may have overridden the method.
            startIntentSenderForResult(intent, -1, fillInIntent, flagsMask,
                    flagsValues, extraFlags);
        }
!!!4816773.java!!!	startActivityIfNeeded(inout intent : Intent, in requestCode : int) : boolean
        return startActivityIfNeeded(intent, requestCode, null);
!!!4816901.java!!!	startActivityIfNeeded(inout intent : Intent, in requestCode : int, inout options : Bundle) : boolean
        if (mParent == null) {
            int result = ActivityManager.START_RETURN_INTENT_TO_CALLER;
            try {
                Uri referrer = onProvideReferrer();
                if (referrer != null) {
                    intent.putExtra(Intent.EXTRA_REFERRER, referrer);
                }
                intent.migrateExtraStreamToClipData();
                intent.prepareToLeaveProcess(this);
                result = ActivityManager.getService()
                    .startActivity(mMainThread.getApplicationThread(), getBasePackageName(),
                            intent, intent.resolveTypeIfNeeded(getContentResolver()), mToken,
                            mEmbeddedID, requestCode, ActivityManager.START_FLAG_ONLY_IF_NEEDED,
                            null, options);
            } catch (RemoteException e) {
                // Empty
            }

            Instrumentation.checkStartActivityResult(result, intent);

            if (requestCode >= 0) {
                // If this start is requesting a result, we can avoid making
                // the activity visible until the result is received.  Setting
                // this code during onCreate(Bundle savedInstanceState) or onResume() will keep the
                // activity hidden during this time, to avoid flickering.
                // This can only be done when a result is requested because
                // that guarantees we will get information back when the
                // activity is finished, no matter what happens to it.
                mStartedActivity = true;
            }
            return result != ActivityManager.START_RETURN_INTENT_TO_CALLER;
        }

        throw new UnsupportedOperationException(
            "startActivityIfNeeded can only be called from a top-level activity");
!!!4817029.java!!!	startNextMatchingActivity(inout intent : Intent) : boolean
        return startNextMatchingActivity(intent, null);
!!!4817157.java!!!	startNextMatchingActivity(inout intent : Intent, inout options : Bundle) : boolean
        if (mParent == null) {
            try {
                intent.migrateExtraStreamToClipData();
                intent.prepareToLeaveProcess(this);
                return ActivityManager.getService()
                    .startNextMatchingActivity(mToken, intent, options);
            } catch (RemoteException e) {
                // Empty
            }
            return false;
        }

        throw new UnsupportedOperationException(
            "startNextMatchingActivity can only be called from a top-level activity");
!!!4817285.java!!!	startActivityFromChild(inout child : Activity, inout intent : Intent, in requestCode : int) : void
        startActivityFromChild(child, intent, requestCode, null);
!!!4817413.java!!!	startActivityFromChild(inout child : Activity, inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, child,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, child.mEmbeddedID, requestCode,
                ar.getResultCode(), ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!4817541.java!!!	startActivityFromFragment(inout fragment : Fragment, inout intent : Intent, in requestCode : int) : void
        startActivityFromFragment(fragment, intent, requestCode, null);
!!!4817669.java!!!	startActivityFromFragment(inout fragment : Fragment, inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        startActivityForResult(fragment.mWho, intent, requestCode, options);
!!!4817797.java!!!	startActivityAsUserFromFragment(inout fragment : Fragment, inout intent : Intent, in requestCode : int, inout options : Bundle, inout user : UserHandle) : void
        startActivityForResultAsUser(intent, fragment.mWho, requestCode, options, user);
!!!4817925.java!!!	startActivityForResult(in who : String, inout intent : Intent, in requestCode : int, inout options : Bundle) : void
        Uri referrer = onProvideReferrer();
        if (referrer != null) {
            intent.putExtra(Intent.EXTRA_REFERRER, referrer);
        }
        options = transferSpringboardActivityOptions(options);
        Instrumentation.ActivityResult ar =
            mInstrumentation.execStartActivity(
                this, mMainThread.getApplicationThread(), mToken, who,
                intent, requestCode, options);
        if (ar != null) {
            mMainThread.sendActivityResult(
                mToken, who, requestCode,
                ar.getResultCode(), ar.getResultData());
        }
        cancelInputsAndStartExitTransition(options);
!!!4818053.java!!!	canStartActivityForResult() : boolean
        return true;
!!!4818181.java!!!	startIntentSenderFromChild(inout child : Activity, inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int) : void
        startIntentSenderFromChild(child, intent, requestCode, fillInIntent,
                flagsMask, flagsValues, extraFlags, null);
!!!4818309.java!!!	startIntentSenderFromChild(inout child : Activity, inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        startIntentSenderForResultInner(intent, child.mEmbeddedID, requestCode, fillInIntent,
                flagsMask, flagsValues, options);
!!!4818437.java!!!	startIntentSenderFromChildFragment(inout child : Fragment, inout intent : IntentSender, in requestCode : int, inout fillInIntent : Intent, in flagsMask : int, in flagsValues : int, in extraFlags : int, inout options : Bundle) : void
        startIntentSenderForResultInner(intent, child.mWho, requestCode, fillInIntent,
                flagsMask, flagsValues, options);
!!!4818565.java!!!	overridePendingTransition(in enterAnim : int, in exitAnim : int) : void
        try {
            ActivityManager.getService().overridePendingTransition(
                    mToken, getPackageName(), enterAnim, exitAnim);
        } catch (RemoteException e) {
        }
!!!4818693.java!!!	setResult(in resultCode : int) : void
        synchronized (this) {
            mResultCode = resultCode;
            mResultData = null;
        }
!!!4818821.java!!!	setResult(in resultCode : int, inout data : Intent) : void
        synchronized (this) {
            mResultCode = resultCode;
            mResultData = data;
        }
!!!4818949.java!!!	getReferrer() : Uri
        Intent intent = getIntent();
        try {
            Uri referrer = intent.getParcelableExtra(Intent.EXTRA_REFERRER);
            if (referrer != null) {
                return referrer;
            }
            String referrerName = intent.getStringExtra(Intent.EXTRA_REFERRER_NAME);
            if (referrerName != null) {
                return Uri.parse(referrerName);
            }
        } catch (BadParcelableException e) {
            Log.w(TAG, "Cannot read referrer from intent;"
                    + " intent extras contain unknown custom Parcelable objects");
        }
        if (mReferrer != null) {
            return new Uri.Builder().scheme("android-app").authority(mReferrer).build();
        }
        return null;
!!!4819077.java!!!	onProvideReferrer() : Uri
        return null;
!!!4819205.java!!!	getCallingPackage() : String
        try {
            return ActivityManager.getService().getCallingPackage(mToken);
        } catch (RemoteException e) {
            return null;
        }
!!!4819333.java!!!	getCallingActivity() : ComponentName
        try {
            return ActivityManager.getService().getCallingActivity(mToken);
        } catch (RemoteException e) {
            return null;
        }
!!!4819461.java!!!	setVisible(inout visible : boolean) : void
        if (mVisibleFromClient != visible) {
            mVisibleFromClient = visible;
            if (mVisibleFromServer) {
                if (visible) makeVisible();
                else mDecor.setVisibility(View.INVISIBLE);
            }
        }
!!!4819589.java!!!	makeVisible() : void
        if (!mWindowAdded) {
            ViewManager wm = getWindowManager();
            wm.addView(mDecor, getWindow().getAttributes());
            mWindowAdded = true;
        }
        mDecor.setVisibility(View.VISIBLE);
!!!4819717.java!!!	isFinishing() : boolean
        return mFinished;
!!!4819845.java!!!	isDestroyed() : boolean
        return mDestroyed;
!!!4819973.java!!!	isChangingConfigurations() : boolean
        return mChangingConfigurations;
!!!4820101.java!!!	recreate() : void
        if (mParent != null) {
            throw new IllegalStateException("Can only be called on top-level activity");
        }
        if (Looper.myLooper() != mMainThread.getLooper()) {
            throw new IllegalStateException("Must be called from main thread");
        }
        try {
            ActivityManager.getService().requestActivityRelaunch(mToken);
        } catch (RemoteException e) {
        }
!!!4820229.java!!!	finish(in finishTask : int) : void
        if (mParent == null) {
            int resultCode;
            Intent resultData;
            synchronized (this) {
                resultCode = mResultCode;
                resultData = mResultData;
            }
            if (false) Log.v(TAG, "Finishing self: token=" + mToken);
            try {
                if (resultData != null) {
                    resultData.prepareToLeaveProcess(this);
                }
                if (ActivityManager.getService()
                        .finishActivity(mToken, resultCode, resultData, finishTask)) {
                    mFinished = true;
                }
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            mParent.finishFromChild(this);
        }
!!!4820357.java!!!	finish() : void
        finish(DONT_FINISH_TASK_WITH_ACTIVITY);
!!!4820485.java!!!	finishAffinity() : void
        if (mParent != null) {
            throw new IllegalStateException("Can not be called from an embedded activity");
        }
        if (mResultCode != RESULT_CANCELED || mResultData != null) {
            throw new IllegalStateException("Can not be called to deliver a result");
        }
        try {
            if (ActivityManager.getService().finishActivityAffinity(mToken)) {
                mFinished = true;
            }
        } catch (RemoteException e) {
            // Empty
        }
!!!4820613.java!!!	finishFromChild(inout child : Activity) : void
        finish();
!!!4820741.java!!!	finishAfterTransition() : void
        if (!mActivityTransitionState.startExitBackTransition(this)) {
            finish();
        }
!!!4820869.java!!!	finishActivity(in requestCode : int) : void
        if (mParent == null) {
            try {
                ActivityManager.getService()
                    .finishSubActivity(mToken, mEmbeddedID, requestCode);
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            mParent.finishActivityFromChild(this, requestCode);
        }
!!!4820997.java!!!	finishActivityFromChild(inout child : Activity, in requestCode : int) : void
        try {
            ActivityManager.getService()
                .finishSubActivity(mToken, child.mEmbeddedID, requestCode);
        } catch (RemoteException e) {
            // Empty
        }
!!!4821125.java!!!	finishAndRemoveTask() : void
        finish(FINISH_TASK_WITH_ROOT_ACTIVITY);
!!!4821253.java!!!	releaseInstance() : boolean
        try {
            return ActivityManager.getService().releaseActivityInstance(mToken);
        } catch (RemoteException e) {
            // Empty
        }
        return false;
!!!4821637.java!!!	createPendingResult(in requestCode : int, inout data : Intent, in flags : int) : PendingIntent
        String packageName = getPackageName();
        try {
            data.prepareToLeaveProcess(this);
            IIntentSender target =
                ActivityManager.getService().getIntentSender(
                        ActivityManager.INTENT_SENDER_ACTIVITY_RESULT, packageName,
                        mParent == null ? mToken : mParent.mToken,
                        mEmbeddedID, requestCode, new Intent[] { data }, null, flags, null,
                        UserHandle.myUserId());
            return target != null ? new PendingIntent(target) : null;
        } catch (RemoteException e) {
            // Empty
        }
        return null;
!!!4821765.java!!!	setRequestedOrientation(in requestedOrientation : int) : void
        if (mParent == null) {
            try {
                ActivityManager.getService().setRequestedOrientation(
                        mToken, requestedOrientation);
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            mParent.setRequestedOrientation(requestedOrientation);
        }
!!!4821893.java!!!	getRequestedOrientation() : int
        if (mParent == null) {
            try {
                return ActivityManager.getService()
                        .getRequestedOrientation(mToken);
            } catch (RemoteException e) {
                // Empty
            }
        } else {
            return mParent.getRequestedOrientation();
        }
        return ActivityInfo.SCREEN_ORIENTATION_UNSPECIFIED;
!!!4822021.java!!!	getTaskId() : int
        try {
            return ActivityManager.getService()
                .getTaskForActivity(mToken, false);
        } catch (RemoteException e) {
            return -1;
        }
!!!4822149.java!!!	isTaskRoot() : boolean
        try {
            return ActivityManager.getService().getTaskForActivity(mToken, true) >= 0;
        } catch (RemoteException e) {
            return false;
        }
!!!4822277.java!!!	moveTaskToBack(inout nonRoot : boolean) : boolean
        try {
            return ActivityManager.getService().moveActivityTaskToBack(
                    mToken, nonRoot);
        } catch (RemoteException e) {
            // Empty
        }
        return false;
!!!4822405.java!!!	getLocalClassName() : String
        final String pkg = getPackageName();
        final String cls = mComponent.getClassName();
        int packageLen = pkg.length();
        if (!cls.startsWith(pkg) || cls.length() <= packageLen
                || cls.charAt(packageLen) != '.') {
            return cls;
        }
        return cls.substring(packageLen+1);
!!!4822533.java!!!	getComponentName() : ComponentName
        return mComponent;
!!!4822661.java!!!	getPreferences(in mode : int) : SharedPreferences
        return getSharedPreferences(getLocalClassName(), mode);
!!!4822789.java!!!	ensureSearchManager() : void
        if (mSearchManager != null) {
            return;
        }

        try {
            mSearchManager = new SearchManager(this, null);
        } catch (ServiceNotFoundException e) {
            throw new IllegalStateException(e);
        }
!!!4822917.java!!!	getSystemService(in name : String) : Object
        if (getBaseContext() == null) {
            throw new IllegalStateException(
                    "System services not available to Activities before onCreate()");
        }

        if (WINDOW_SERVICE.equals(name)) {
            return mWindowManager;
        } else if (SEARCH_SERVICE.equals(name)) {
            ensureSearchManager();
            return mSearchManager;
        }
        return super.getSystemService(name);
!!!4823045.java!!!	setTitle(inout title : CharSequence) : void
        mTitle = title;
        onTitleChanged(title, mTitleColor);

        if (mParent != null) {
            mParent.onChildTitleChanged(this, title);
        }
!!!4823173.java!!!	setTitle(in titleId : int) : void
        setTitle(getText(titleId));
!!!4823301.java!!!	setTitleColor(in textColor : int) : void
        mTitleColor = textColor;
        onTitleChanged(mTitle, textColor);
!!!4823429.java!!!	getTitle() : CharSequence
        return mTitle;
!!!4823557.java!!!	getTitleColor() : int
        return mTitleColor;
!!!4823685.java!!!	onTitleChanged(inout title : CharSequence, in color : int) : void
        if (mTitleReady) {
            final Window win = getWindow();
            if (win != null) {
                win.setTitle(title);
                if (color != 0) {
                    win.setTitleColor(color);
                }
            }
            if (mActionBar != null) {
                mActionBar.setWindowTitle(title);
            }
        }
!!!4823941.java!!!	setTaskDescription(inout taskDescription : ActivityManager::TaskDescription) : void
        if (mTaskDescription != taskDescription) {
            mTaskDescription.copyFromPreserveHiddenFields(taskDescription);
            // Scale the icon down to something reasonable if it is provided
            if (taskDescription.getIconFilename() == null && taskDescription.getIcon() != null) {
                final int size = ActivityManager.getLauncherLargeIconSizeInner(this);
                final Bitmap icon = Bitmap.createScaledBitmap(taskDescription.getIcon(), size, size,
                        true);
                mTaskDescription.setIcon(icon);
            }
        }
        try {
            ActivityManager.getService().setTaskDescription(mToken, mTaskDescription);
        } catch (RemoteException e) {
        }
!!!4824069.java!!!	setProgressBarVisibility(inout visible : boolean) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, visible ? Window.PROGRESS_VISIBILITY_ON :
            Window.PROGRESS_VISIBILITY_OFF);
!!!4824197.java!!!	setProgressBarIndeterminateVisibility(inout visible : boolean) : void
        getWindow().setFeatureInt(Window.FEATURE_INDETERMINATE_PROGRESS,
                visible ? Window.PROGRESS_VISIBILITY_ON : Window.PROGRESS_VISIBILITY_OFF);
!!!4824325.java!!!	setProgressBarIndeterminate(inout indeterminate : boolean) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS,
                indeterminate ? Window.PROGRESS_INDETERMINATE_ON
                        : Window.PROGRESS_INDETERMINATE_OFF);
!!!4824453.java!!!	setProgress(in progress : int) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS, progress + Window.PROGRESS_START);
!!!4824581.java!!!	setSecondaryProgress(in secondaryProgress : int) : void
        getWindow().setFeatureInt(Window.FEATURE_PROGRESS,
                secondaryProgress + Window.PROGRESS_SECONDARY_START);
!!!4824709.java!!!	setVolumeControlStream(in streamType : int) : void
        getWindow().setVolumeControlStream(streamType);
!!!4824837.java!!!	getVolumeControlStream() : int
        return getWindow().getVolumeControlStream();
!!!4824965.java!!!	setMediaController(inout controller : MediaController) : void
        getWindow().setMediaController(controller);
!!!4825093.java!!!	getMediaController() : MediaController
        return getWindow().getMediaController();
!!!4825221.java!!!	runOnUiThread(inout action : Runnable) : void
        if (Thread.currentThread() != mUiThread) {
            mHandler.post(action);
        } else {
            action.run();
        }
!!!4825349.java!!!	onCreateView(in name : String, inout context : Context, inout attrs : AttributeSet) : View
        return null;
!!!4825477.java!!!	onCreateView(inout parent : View, in name : String, inout context : Context, inout attrs : AttributeSet) : View
        if (!"fragment".equals(name)) {
            return onCreateView(name, context, attrs);
        }

        return mFragments.onCreateView(parent, name, context, attrs);
!!!4825605.java!!!	dump(in prefix : String, inout fd : FileDescriptor, inout writer : PrintWriter, inout args : String [[]]) : void
        dumpInner(prefix, fd, writer, args);
!!!4825733.java!!!	dumpInner(in prefix : String, inout fd : FileDescriptor, inout writer : PrintWriter, inout args : String [[]]) : void
        writer.print(prefix); writer.print("Local Activity ");
                writer.print(Integer.toHexString(System.identityHashCode(this)));
                writer.println(" State:");
        String innerPrefix = prefix + "  ";
        writer.print(innerPrefix); writer.print("mResumed=");
                writer.print(mResumed); writer.print(" mStopped=");
                writer.print(mStopped); writer.print(" mFinished=");
                writer.println(mFinished);
        writer.print(innerPrefix); writer.print("mChangingConfigurations=");
                writer.println(mChangingConfigurations);
        writer.print(innerPrefix); writer.print("mCurrentConfig=");
                writer.println(mCurrentConfig);

        mFragments.dumpLoaders(innerPrefix, fd, writer, args);
        mFragments.getFragmentManager().dump(innerPrefix, fd, writer, args);
        if (mVoiceInteractor != null) {
            mVoiceInteractor.dump(innerPrefix, fd, writer, args);
        }

        if (getWindow() != null &&
                getWindow().peekDecorView() != null &&
                getWindow().peekDecorView().getViewRootImpl() != null) {
            getWindow().peekDecorView().getViewRootImpl().dump(prefix, fd, writer, args);
        }

        mHandler.getLooper().dump(new PrintWriterPrinter(writer), prefix);
!!!4825861.java!!!	isImmersive() : boolean
        try {
            return ActivityManager.getService().isImmersive(mToken);
        } catch (RemoteException e) {
            return false;
        }
!!!4825989.java!!!	isTopOfTask() : boolean
        if (mToken == null || mWindow == null) {
            return false;
        }
        try {
            return ActivityManager.getService().isTopOfTask(getActivityToken());
        } catch (RemoteException e) {
            return false;
        }
!!!4826117.java!!!	convertFromTranslucent() : void
        try {
            mTranslucentCallback = null;
            if (ActivityManager.getService().convertFromTranslucent(mToken)) {
                WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, true);
            }
        } catch (RemoteException e) {
            // pass
        }
!!!4826245.java!!!	convertToTranslucent(inout callback : Activity::TranslucentConversionListener, inout options : ActivityOptions) : boolean
        boolean drawComplete;
        try {
            mTranslucentCallback = callback;
            mChangeCanvasToTranslucent = ActivityManager.getService().convertToTranslucent(
                    mToken, options == null ? null : options.toBundle());
            WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, false);
            drawComplete = true;
        } catch (RemoteException e) {
            // Make callback return as though it timed out.
            mChangeCanvasToTranslucent = false;
            drawComplete = false;
        }
        if (!mChangeCanvasToTranslucent && mTranslucentCallback != null) {
            // Window is already translucent.
            mTranslucentCallback.onTranslucentConversionComplete(drawComplete);
        }
        return mChangeCanvasToTranslucent;
!!!4826373.java!!!	onTranslucentConversionComplete(inout drawComplete : boolean) : void
        if (mTranslucentCallback != null) {
            mTranslucentCallback.onTranslucentConversionComplete(drawComplete);
            mTranslucentCallback = null;
        }
        if (mChangeCanvasToTranslucent) {
            WindowManagerGlobal.getInstance().changeCanvasOpacity(mToken, false);
        }
!!!4826501.java!!!	onNewActivityOptions(inout options : ActivityOptions) : void
        mActivityTransitionState.setEnterActivityOptions(this, options);
        if (!mStopped) {
            mActivityTransitionState.enterReady(this);
        }
!!!4826629.java!!!	getActivityOptions() : ActivityOptions
        try {
            return ActivityOptions.fromBundle(
                    ActivityManager.getService().getActivityOptions(mToken));
        } catch (RemoteException e) {
        }
        return null;
!!!4826757.java!!!	requestVisibleBehind(inout visible : boolean) : boolean
        return false;
!!!4826885.java!!!	onVisibleBehindCanceled() : void
        mCalled = true;
!!!4827013.java!!!	isBackgroundVisibleBehind() : boolean
        try {
            return ActivityManager.getService().isBackgroundVisibleBehind(mToken);
        } catch (RemoteException e) {
        }
        return false;
!!!4827397.java!!!	dispatchEnterAnimationComplete() : void
        onEnterAnimationComplete();
        if (getWindow() != null && getWindow().getDecorView() != null) {
            getWindow().getDecorView().getViewTreeObserver().dispatchOnEnterAnimationComplete();
        }
!!!4827525.java!!!	setImmersive(inout i : boolean) : void
        try {
            ActivityManager.getService().setImmersive(mToken, i);
        } catch (RemoteException e) {
            // pass
        }
!!!4827653.java!!!	setVrModeEnabled(inout enabled : boolean, inout requestedComponent : ComponentName) : void
        try {
            if (ActivityManager.getService().setVrMode(mToken, enabled, requestedComponent)
                    != 0) {
                throw new PackageManager.NameNotFoundException(
                        requestedComponent.flattenToString());
            }
        } catch (RemoteException e) {
            // pass
        }
!!!4827781.java!!!	startActionMode(inout callback : ActionMode::Callback) : ActionMode
        return mWindow.getDecorView().startActionMode(callback);
!!!4827909.java!!!	startActionMode(inout callback : ActionMode::Callback, in type : int) : ActionMode
        return mWindow.getDecorView().startActionMode(callback, type);
!!!4828037.java!!!	onWindowStartingActionMode(inout callback : ActionMode::Callback) : ActionMode
        // Only Primary ActionModes are represented in the ActionBar.
        if (mActionModeTypeStarting == ActionMode.TYPE_PRIMARY) {
            initWindowDecorActionBar();
            if (mActionBar != null) {
                return mActionBar.startActionMode(callback);
            }
        }
        return null;
!!!4828165.java!!!	onWindowStartingActionMode(inout callback : ActionMode::Callback, in type : int) : ActionMode
        try {
            mActionModeTypeStarting = type;
            return onWindowStartingActionMode(callback);
        } finally {
            mActionModeTypeStarting = ActionMode.TYPE_PRIMARY;
        }
!!!4828549.java!!!	shouldUpRecreateTask(inout targetIntent : Intent) : boolean
        try {
            PackageManager pm = getPackageManager();
            ComponentName cn = targetIntent.getComponent();
            if (cn == null) {
                cn = targetIntent.resolveActivity(pm);
            }
            ActivityInfo info = pm.getActivityInfo(cn, 0);
            if (info.taskAffinity == null) {
                return false;
            }
            return ActivityManager.getService()
                    .shouldUpRecreateTask(mToken, info.taskAffinity);
        } catch (RemoteException e) {
            return false;
        } catch (NameNotFoundException e) {
            return false;
        }
!!!4828677.java!!!	navigateUpTo(inout upIntent : Intent) : boolean
        if (mParent == null) {
            ComponentName destInfo = upIntent.getComponent();
            if (destInfo == null) {
                destInfo = upIntent.resolveActivity(getPackageManager());
                if (destInfo == null) {
                    return false;
                }
                upIntent = new Intent(upIntent);
                upIntent.setComponent(destInfo);
            }
            int resultCode;
            Intent resultData;
            synchronized (this) {
                resultCode = mResultCode;
                resultData = mResultData;
            }
            if (resultData != null) {
                resultData.prepareToLeaveProcess(this);
            }
            try {
                upIntent.prepareToLeaveProcess(this);
                return ActivityManager.getService().navigateUpTo(mToken, upIntent,
                        resultCode, resultData);
            } catch (RemoteException e) {
                return false;
            }
        } else {
            return mParent.navigateUpToFromChild(this, upIntent);
        }
!!!4828805.java!!!	navigateUpToFromChild(inout child : Activity, inout upIntent : Intent) : boolean
        return navigateUpTo(upIntent);
!!!4828933.java!!!	getParentActivityIntent() : Intent
        final String parentName = mActivityInfo.parentActivityName;
        if (TextUtils.isEmpty(parentName)) {
            return null;
        }

        // If the parent itself has no parent, generate a main activity intent.
        final ComponentName target = new ComponentName(this, parentName);
        try {
            final ActivityInfo parentInfo = getPackageManager().getActivityInfo(target, 0);
            final String parentActivity = parentInfo.parentActivityName;
            final Intent parentIntent = parentActivity == null
                    ? Intent.makeMainActivity(target)
                    : new Intent().setComponent(target);
            return parentIntent;
        } catch (NameNotFoundException e) {
            Log.e(TAG, "getParentActivityIntent: bad parentActivityName '" + parentName +
                    "' in manifest");
            return null;
        }
!!!4829061.java!!!	setEnterSharedElementCallback(inout callback : SharedElementCallback) : void
        if (callback == null) {
            callback = SharedElementCallback.NULL_CALLBACK;
        }
        mEnterTransitionListener = callback;
!!!4829189.java!!!	setExitSharedElementCallback(inout callback : SharedElementCallback) : void
        if (callback == null) {
            callback = SharedElementCallback.NULL_CALLBACK;
        }
        mExitTransitionListener = callback;
!!!4829317.java!!!	postponeEnterTransition() : void
        mActivityTransitionState.postponeEnterTransition();
!!!4829445.java!!!	startPostponedEnterTransition() : void
        mActivityTransitionState.startPostponedEnterTransition();
!!!4829573.java!!!	requestDragAndDropPermissions(inout event : DragEvent) : DragAndDropPermissions
        DragAndDropPermissions dragAndDropPermissions = DragAndDropPermissions.obtain(event);
        if (dragAndDropPermissions != null && dragAndDropPermissions.take(getActivityToken())) {
            return dragAndDropPermissions;
        }
        return null;
!!!4829701.java!!!	setParent(inout parent : Activity) : void
        mParent = parent;
!!!4829829.java!!!	attach(inout context : Context, inout aThread : ActivityThread, inout instr : Instrumentation, inout token : IBinder, in ident : int, inout application : Application, inout intent : Intent, inout info : ActivityInfo, inout title : CharSequence, inout parent : Activity, in id : String, inout lastNonConfigurationInstances : Activity::NonConfigurationInstances, inout config : Configuration, in referrer : String, inout voiceInteractor : IVoiceInteractor, inout window : Window, inout activityConfigCallback : ViewRootImpl::ActivityConfigCallback) : void
        attachBaseContext(context);

        mFragments.attachHost(null /*parent*/);

        mWindow = new PhoneWindow(this, window, activityConfigCallback);
        mWindow.setWindowControllerCallback(this);
        mWindow.setCallback(this);
        mWindow.setOnWindowDismissedCallback(this);
        mWindow.getLayoutInflater().setPrivateFactory(this);
        if (info.softInputMode != WindowManager.LayoutParams.SOFT_INPUT_STATE_UNSPECIFIED) {
            mWindow.setSoftInputMode(info.softInputMode);
        }
        if (info.uiOptions != 0) {
            mWindow.setUiOptions(info.uiOptions);
        }
        mUiThread = Thread.currentThread();

        mMainThread = aThread;
        mInstrumentation = instr;
        mToken = token;
        mIdent = ident;
        mApplication = application;
        mIntent = intent;
        mReferrer = referrer;
        mComponent = intent.getComponent();
        mActivityInfo = info;
        mTitle = title;
        mParent = parent;
        mEmbeddedID = id;
        mLastNonConfigurationInstances = lastNonConfigurationInstances;
        if (voiceInteractor != null) {
            if (lastNonConfigurationInstances != null) {
                mVoiceInteractor = lastNonConfigurationInstances.voiceInteractor;
            } else {
                mVoiceInteractor = new VoiceInteractor(voiceInteractor, this, this,
                        Looper.myLooper());
            }
        }

        mWindow.setWindowManager(
                (WindowManager)context.getSystemService(Context.WINDOW_SERVICE),
                mToken, mComponent.flattenToString(),
                (info.flags & ActivityInfo.FLAG_HARDWARE_ACCELERATED) != 0);
        if (mParent != null) {
            mWindow.setContainer(mParent.getWindow());
        }
        mWindowManager = mWindow.getWindowManager();
        mCurrentConfig = config;

        mWindow.setColorMode(info.colorMode);
!!!4829957.java!!!	getActivityToken() : IBinder
        return mParent != null ? mParent.getActivityToken() : mToken;
!!!4830085.java!!!	performCreateCommon() : void
        mVisibleFromClient = !mWindow.getWindowStyle().getBoolean(
                com.android.internal.R.styleable.Window_windowNoDisplay, false);
        mFragments.dispatchActivityCreated();
        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
!!!4830213.java!!!	performCreate(inout icicle : Bundle) : void
        restoreHasCurrentPermissionRequest(icicle);
        onCreate(icicle);
        mActivityTransitionState.readState(icicle);
        performCreateCommon();
!!!4830341.java!!!	performCreate(inout icicle : Bundle, inout persistentState : PersistableBundle) : void
        restoreHasCurrentPermissionRequest(icicle);
        onCreate(icicle, persistentState);
        mActivityTransitionState.readState(icicle);
        performCreateCommon();
!!!4830469.java!!!	performStart() : void
        mActivityTransitionState.setEnterActivityOptions(this, getActivityOptions());
        mFragments.noteStateNotSaved();
        mCalled = false;
        mFragments.execPendingActions();
        mInstrumentation.callActivityOnStart(this);
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onStart()");
        }
        mFragments.dispatchStart();
        mFragments.reportLoaderStart();

        // This property is set for all builds except final release
        boolean isDlwarningEnabled = SystemProperties.getInt("ro.bionic.ld.warning", 0) == 1;
        boolean isAppDebuggable =
                (mApplication.getApplicationInfo().flags & ApplicationInfo.FLAG_DEBUGGABLE) != 0;

        if (isAppDebuggable || isDlwarningEnabled) {
            String dlwarning = getDlWarning();
            if (dlwarning != null) {
                String appName = getApplicationInfo().loadLabel(getPackageManager())
                        .toString();
                String warning = "Detected problems with app native libraries\n" +
                                 "(please consult log for detail):\n" + dlwarning;
                if (isAppDebuggable) {
                      new AlertDialog.Builder(this).
                          setTitle(appName).
                          setMessage(warning).
                          setPositiveButton(android.R.string.ok, null).
                          setCancelable(false).
                          show();
                } else {
                    Toast.makeText(this, appName + "\n" + warning, Toast.LENGTH_LONG).show();
                }
            }
        }

        mActivityTransitionState.enterReady(this);
!!!4830597.java!!!	performRestart() : void
        mFragments.noteStateNotSaved();

        if (mToken != null && mParent == null) {
            // No need to check mStopped, the roots will check if they were actually stopped.
            WindowManagerGlobal.getInstance().setStoppedState(mToken, false /* stopped */);
        }

        if (mStopped) {
            mStopped = false;

            synchronized (mManagedCursors) {
                final int N = mManagedCursors.size();
                for (int i=0; i<N; i++) {
                    ManagedCursor mc = mManagedCursors.get(i);
                    if (mc.mReleased || mc.mUpdated) {
                        if (!mc.mCursor.requery()) {
                            if (getApplicationInfo().targetSdkVersion
                                    >= android.os.Build.VERSION_CODES.ICE_CREAM_SANDWICH) {
                                throw new IllegalStateException(
                                        "trying to requery an already closed cursor  "
                                        + mc.mCursor);
                            }
                        }
                        mc.mReleased = false;
                        mc.mUpdated = false;
                    }
                }
            }

            mCalled = false;
            mInstrumentation.callActivityOnRestart(this);
            if (!mCalled) {
                throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onRestart()");
            }
            performStart();
        }
!!!4830725.java!!!	performResume() : void
        performRestart();

        mFragments.execPendingActions();

        mLastNonConfigurationInstances = null;

        mCalled = false;
        // mResumed is set by the instrumentation
        mInstrumentation.callActivityOnResume(this);
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onResume()");
        }

        // invisible activities must be finished before onResume() completes
        if (!mVisibleFromClient && !mFinished) {
            Log.w(TAG, "An activity without a UI must call finish() before onResume() completes");
            if (getApplicationInfo().targetSdkVersion
                    > android.os.Build.VERSION_CODES.LOLLIPOP_MR1) {
                throw new IllegalStateException(
                        "Activity " + mComponent.toShortString() +
                        " did not call finish() prior to onResume() completing");
            }
        }

        // Now really resume, and install the current status bar and menu.
        mCalled = false;

        mFragments.dispatchResume();
        mFragments.execPendingActions();

        onPostResume();
        if (!mCalled) {
            throw new SuperNotCalledException(
                "Activity " + mComponent.toShortString() +
                " did not call through to super.onPostResume()");
        }
!!!4830853.java!!!	performPause() : void
        mDoReportFullyDrawn = false;
        mFragments.dispatchPause();
        mCalled = false;
        onPause();
        mResumed = false;
        if (!mCalled && getApplicationInfo().targetSdkVersion
                >= android.os.Build.VERSION_CODES.GINGERBREAD) {
            throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onPause()");
        }
        mResumed = false;
!!!4830981.java!!!	performUserLeaving() : void
        onUserInteraction();
        onUserLeaveHint();
!!!4831109.java!!!	performStop(inout preserveWindow : boolean) : void
        mDoReportFullyDrawn = false;
        mFragments.doLoaderStop(mChangingConfigurations /*retain*/);

        if (!mStopped) {
            if (mWindow != null) {
                mWindow.closeAllPanels();
            }

            // If we're preserving the window, don't setStoppedState to true, since we
            // need the window started immediately again. Stopping the window will
            // destroys hardware resources and causes flicker.
            if (!preserveWindow && mToken != null && mParent == null) {
                WindowManagerGlobal.getInstance().setStoppedState(mToken, true);
            }

            mFragments.dispatchStop();

            mCalled = false;
            mInstrumentation.callActivityOnStop(this);
            if (!mCalled) {
                throw new SuperNotCalledException(
                    "Activity " + mComponent.toShortString() +
                    " did not call through to super.onStop()");
            }

            synchronized (mManagedCursors) {
                final int N = mManagedCursors.size();
                for (int i=0; i<N; i++) {
                    ManagedCursor mc = mManagedCursors.get(i);
                    if (!mc.mReleased) {
                        mc.mCursor.deactivate();
                        mc.mReleased = true;
                    }
                }
            }

            mStopped = true;
        }
        mResumed = false;
!!!4831237.java!!!	performDestroy() : void
        mDestroyed = true;
        mWindow.destroy();
        mFragments.dispatchDestroy();
        onDestroy();
        mFragments.doLoaderDestroy();
        if (mVoiceInteractor != null) {
            mVoiceInteractor.detachActivity();
        }
!!!4831365.java!!!	dispatchMultiWindowModeChanged(inout isInMultiWindowMode : boolean, inout newConfig : Configuration) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG,
                "dispatchMultiWindowModeChanged " + this + ": " + isInMultiWindowMode
                        + " " + newConfig);
        mFragments.dispatchMultiWindowModeChanged(isInMultiWindowMode, newConfig);
        if (mWindow != null) {
            mWindow.onMultiWindowModeChanged();
        }
        onMultiWindowModeChanged(isInMultiWindowMode, newConfig);
!!!4831493.java!!!	dispatchPictureInPictureModeChanged(inout isInPictureInPictureMode : boolean, inout newConfig : Configuration) : void
        if (DEBUG_LIFECYCLE) Slog.v(TAG,
                "dispatchPictureInPictureModeChanged " + this + ": " + isInPictureInPictureMode
                        + " " + newConfig);
        mFragments.dispatchPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
        if (mWindow != null) {
            mWindow.onPictureInPictureModeChanged(isInPictureInPictureMode);
        }
        onPictureInPictureModeChanged(isInPictureInPictureMode, newConfig);
!!!4831621.java!!!	isResumed() : boolean
        return mResumed;
!!!4831749.java!!!	storeHasCurrentPermissionRequest(inout bundle : Bundle) : void
        if (bundle != null && mHasCurrentPermissionsRequest) {
            bundle.putBoolean(HAS_CURENT_PERMISSIONS_REQUEST_KEY, true);
        }
!!!4831877.java!!!	restoreHasCurrentPermissionRequest(inout bundle : Bundle) : void
        if (bundle != null) {
            mHasCurrentPermissionsRequest = bundle.getBoolean(
                    HAS_CURENT_PERMISSIONS_REQUEST_KEY, false);
        }
!!!4832005.java!!!	dispatchActivityResult(in who : String, in requestCode : int, in resultCode : int, inout data : Intent) : void
        if (false) Log.v(
            TAG, "Dispatching result: who=" + who + ", reqCode=" + requestCode
            + ", resCode=" + resultCode + ", data=" + data);
        mFragments.noteStateNotSaved();
        if (who == null) {
            onActivityResult(requestCode, resultCode, data);
        } else if (who.startsWith(REQUEST_PERMISSIONS_WHO_PREFIX)) {
            who = who.substring(REQUEST_PERMISSIONS_WHO_PREFIX.length());
            if (TextUtils.isEmpty(who)) {
                dispatchRequestPermissionsResult(requestCode, data);
            } else {
                Fragment frag = mFragments.findFragmentByWho(who);
                if (frag != null) {
                    dispatchRequestPermissionsResultToFragment(requestCode, data, frag);
                }
            }
        } else if (who.startsWith("@android:view:")) {
            ArrayList<ViewRootImpl> views = WindowManagerGlobal.getInstance().getRootViews(
                    getActivityToken());
            for (ViewRootImpl viewRoot : views) {
                if (viewRoot.getView() != null
                        && viewRoot.getView().dispatchActivityResult(
                                who, requestCode, resultCode, data)) {
                    return;
                }
            }
        } else if (who.startsWith(AUTO_FILL_AUTH_WHO_PREFIX)) {
            Intent resultData = (resultCode == Activity.RESULT_OK) ? data : null;
            getAutofillManager().onAuthenticationResult(requestCode, resultData);
        } else {
            Fragment frag = mFragments.findFragmentByWho(who);
            if (frag != null) {
                frag.onActivityResult(requestCode, resultCode, data);
            }
        }
!!!4832133.java!!!	startLockTask() : void
        try {
            ActivityManager.getService().startLockTaskModeByToken(mToken);
        } catch (RemoteException e) {
        }
!!!4832261.java!!!	stopLockTask() : void
        try {
            ActivityManager.getService().stopLockTaskMode();
        } catch (RemoteException e) {
        }
!!!4832389.java!!!	showLockTaskEscapeMessage() : void
        try {
            ActivityManager.getService().showLockTaskEscapeMessage(mToken);
        } catch (RemoteException e) {
        }
!!!4832517.java!!!	isOverlayWithDecorCaptionEnabled() : boolean
        return mWindow.isOverlayWithDecorCaptionEnabled();
!!!4832645.java!!!	setOverlayWithDecorCaptionEnabled(inout enabled : boolean) : void
        mWindow.setOverlayWithDecorCaptionEnabled(enabled);
!!!4832901.java!!!	dispatchRequestPermissionsResult(in requestCode : int, inout data : Intent) : void
        mHasCurrentPermissionsRequest = false;
        // If the package installer crashed we may have not data - best effort.
        String[] permissions = (data != null) ? data.getStringArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES) : new String[0];
        final int[] grantResults = (data != null) ? data.getIntArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS) : new int[0];
        onRequestPermissionsResult(requestCode, permissions, grantResults);
!!!4833029.java!!!	dispatchRequestPermissionsResultToFragment(in requestCode : int, inout data : Intent, inout fragment : Fragment) : void
        // If the package installer crashed we may have not data - best effort.
        String[] permissions = (data != null) ? data.getStringArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_NAMES) : new String[0];
        final int[] grantResults = (data != null) ? data.getIntArrayExtra(
                PackageManager.EXTRA_REQUEST_PERMISSIONS_RESULTS) : new int[0];
        fragment.onRequestPermissionsResult(requestCode, permissions, grantResults);
!!!4833157.java!!!	autofillCallbackAuthenticate(in authenticationId : int, inout intent : IntentSender, inout fillInIntent : Intent) : void
        try {
            startIntentSenderForResultInner(intent, AUTO_FILL_AUTH_WHO_PREFIX,
                    authenticationId, fillInIntent, 0, 0, null);
        } catch (IntentSender.SendIntentException e) {
            Log.e(TAG, "authenticate() failed for intent:" + intent, e);
        }
!!!4833285.java!!!	autofillCallbackResetableStateAvailable() : void
        mAutoFillResetNeeded = true;
!!!4833413.java!!!	autofillCallbackRequestShowFillUi(inout anchor : View, in width : int, in height : int, inout anchorBounds : Rect, inout presenter : IAutofillWindowPresenter) : boolean
        final boolean wasShowing;

        if (mAutofillPopupWindow == null) {
            wasShowing = false;
            mAutofillPopupWindow = new AutofillPopupWindow(presenter);
        } else {
            wasShowing = mAutofillPopupWindow.isShowing();
        }
        mAutofillPopupWindow.update(anchor, 0, 0, width, height, anchorBounds);

        return !wasShowing && mAutofillPopupWindow.isShowing();
!!!4833541.java!!!	autofillCallbackRequestHideFillUi() : boolean
        if (mAutofillPopupWindow == null) {
            return false;
        }
        mAutofillPopupWindow.dismiss();
        mAutofillPopupWindow = null;
        return true;
!!!4833669.java!!!	findViewsByAutofillIdTraversal(inout viewIds : int [[]]) : View
        final View[] views = new View[viewIds.length];
        final ArrayList<ViewRootImpl> roots =
                WindowManagerGlobal.getInstance().getRootViews(getActivityToken());

        for (int rootNum = 0; rootNum < roots.size(); rootNum++) {
            final View rootView = roots.get(rootNum).getView();

            if (rootView != null) {
                for (int viewNum = 0; viewNum < viewIds.length; viewNum++) {
                    if (views[viewNum] == null) {
                        views[viewNum] = rootView.findViewByAutofillIdTraversal(
                                viewIds[viewNum]);
                    }
                }
            }
        }

        return views;
!!!4833797.java!!!	findViewByAutofillIdTraversal(in viewId : int) : View
        final ArrayList<ViewRootImpl> roots =
                WindowManagerGlobal.getInstance().getRootViews(getActivityToken());
        for (int rootNum = 0; rootNum < roots.size(); rootNum++) {
            final View rootView = roots.get(rootNum).getView();

            if (rootView != null) {
                final View view = rootView.findViewByAutofillIdTraversal(viewId);
                if (view != null) {
                    return view;
                }
            }
        }

        return null;
!!!4833925.java!!!	getViewVisibility(inout viewIds : int [[]]) : boolean
        final boolean[] isVisible = new boolean[viewIds.length];
        final View views[] = findViewsByAutofillIdTraversal(viewIds);

        for (int i = 0; i < viewIds.length; i++) {
            View view = views[i];
            if (view == null) {
                isVisible[i] = false;
                continue;
            }

            isVisible[i] = true;

            // Check if the view is visible by checking all parents
            while (true) {
                if (view instanceof DecorView && view.getViewRootImpl() == view.getParent()) {
                    break;
                }

                if (view.getVisibility() != View.VISIBLE) {
                    isVisible[i] = false;
                    break;
                }

                if (view.getParent() instanceof View) {
                    view = (View) view.getParent();
                } else {
                    break;
                }
            }
        }

        return isVisible;
!!!4834053.java!!!	isVisibleForAutofill() : boolean
        return !mStopped;
!!!4834181.java!!!	setDisablePreviewScreenshots(inout disable : boolean) : void
        try {
            ActivityManager.getService().setDisablePreviewScreenshots(mToken, disable);
        } catch (RemoteException e) {
            Log.e(TAG, "Failed to call setDisablePreviewScreenshots", e);
        }
