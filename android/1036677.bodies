class ProtoOutputStream
!!!8549893.java!!!	ProtoOutputStream()
        this(0);
!!!8550021.java!!!	ProtoOutputStream(in chunkSize : int)
        mBuffer = new EncodedBuffer(chunkSize);
!!!8550149.java!!!	ProtoOutputStream(inout stream : OutputStream)
        this();
        mStream = stream;
!!!8550277.java!!!	ProtoOutputStream(inout fd : FileDescriptor)
        this(new FileOutputStream(fd));
!!!8550405.java!!!	write(in fieldId : long, in val : double) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // double
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeDoubleImpl(id, (double)val);
                break;
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedDoubleImpl(id, (double)val);
                break;
            // float
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFloatImpl(id, (float)val);
                break;
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFloatImpl(id, (float)val);
                break;
            // int32
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt32Impl(id, (int)val);
                break;
            // int64
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt64Impl(id, (long)val);
                break;
            // uint32
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt32Impl(id, (int)val);
                break;
            // uint64
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt64Impl(id, (long)val);
                break;
            // sint32
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt32Impl(id, (int)val);
                break;
            // sint64
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt64Impl(id, (long)val);
                break;
            // fixed32
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed32Impl(id, (int)val);
                break;
            // fixed64
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed64Impl(id, (long)val);
                break;
            // sfixed32
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed32Impl(id, (int)val);
                break;
            // sfixed64
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed64Impl(id, (long)val);
                break;
            // bool
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeBoolImpl(id, val != 0);
                break;
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedBoolImpl(id, val != 0);
                break;
            // enum
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeEnumImpl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedEnumImpl(id, (int)val);
                break;
            // string, bytes, object not allowed here.
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, double) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8550533.java!!!	write(in fieldId : long, in val : float) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // double
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeDoubleImpl(id, (double)val);
                break;
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedDoubleImpl(id, (double)val);
                break;
            // float
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFloatImpl(id, (float)val);
                break;
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFloatImpl(id, (float)val);
                break;
            // int32
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt32Impl(id, (int)val);
                break;
            // int64
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt64Impl(id, (long)val);
                break;
            // uint32
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt32Impl(id, (int)val);
                break;
            // uint64
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt64Impl(id, (long)val);
                break;
            // sint32
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt32Impl(id, (int)val);
                break;
            // sint64
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt64Impl(id, (long)val);
                break;
            // fixed32
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed32Impl(id, (int)val);
                break;
            // fixed64
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed64Impl(id, (long)val);
                break;
            // sfixed32
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed32Impl(id, (int)val);
                break;
            // sfixed64
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed64Impl(id, (long)val);
                break;
            // bool
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeBoolImpl(id, val != 0);
                break;
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedBoolImpl(id, val != 0);
                break;
            // enum
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeEnumImpl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedEnumImpl(id, (int)val);
                break;
            // string, bytes, object not allowed here.
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, float) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8550661.java!!!	write(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // double
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeDoubleImpl(id, (double)val);
                break;
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedDoubleImpl(id, (double)val);
                break;
            // float
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFloatImpl(id, (float)val);
                break;
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFloatImpl(id, (float)val);
                break;
            // int32
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt32Impl(id, (int)val);
                break;
            // int64
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt64Impl(id, (long)val);
                break;
            // uint32
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt32Impl(id, (int)val);
                break;
            // uint64
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt64Impl(id, (long)val);
                break;
            // sint32
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt32Impl(id, (int)val);
                break;
            // sint64
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt64Impl(id, (long)val);
                break;
            // fixed32
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed32Impl(id, (int)val);
                break;
            // fixed64
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed64Impl(id, (long)val);
                break;
            // sfixed32
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed32Impl(id, (int)val);
                break;
            // sfixed64
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed64Impl(id, (long)val);
                break;
            // bool
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeBoolImpl(id, val != 0);
                break;
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedBoolImpl(id, val != 0);
                break;
            // enum
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeEnumImpl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedEnumImpl(id, (int)val);
                break;
            // string, bytes, object not allowed here.
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, int) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8550789.java!!!	write(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // double
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeDoubleImpl(id, (double)val);
                break;
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_DOUBLE | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedDoubleImpl(id, (double)val);
                break;
            // float
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFloatImpl(id, (float)val);
                break;
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FLOAT | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFloatImpl(id, (float)val);
                break;
            // int32
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt32Impl(id, (int)val);
                break;
            // int64
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_INT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedInt64Impl(id, (long)val);
                break;
            // uint32
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt32Impl(id, (int)val);
                break;
            // uint64
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeUInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_UINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedUInt64Impl(id, (long)val);
                break;
            // sint32
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt32Impl(id, (int)val);
                break;
            // sint64
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSInt64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SINT64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSInt64Impl(id, (long)val);
                break;
            // fixed32
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed32Impl(id, (int)val);
                break;
            // fixed64
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_FIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedFixed64Impl(id, (long)val);
                break;
            // sfixed32
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed32Impl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED32 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed32Impl(id, (int)val);
                break;
            // sfixed64
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeSFixed64Impl(id, (long)val);
                break;
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_SFIXED64 | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedSFixed64Impl(id, (long)val);
                break;
            // bool
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeBoolImpl(id, val != 0);
                break;
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedBoolImpl(id, val != 0);
                break;
            // enum
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeEnumImpl(id, (int)val);
                break;
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_ENUM | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedEnumImpl(id, (int)val);
                break;
            // string, bytes, object not allowed here.
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, long) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8550917.java!!!	write(in fieldId : long, inout val : boolean) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // bool
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeBoolImpl(id, val);
                break;
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_BOOL | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedBoolImpl(id, val);
                break;
            // nothing else allowed
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, boolean) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8551045.java!!!	write(in fieldId : long, in val : String) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // string
            case (int)((FIELD_TYPE_STRING | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeStringImpl(id, val);
                break;
            case (int)((FIELD_TYPE_STRING | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_STRING | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedStringImpl(id, val);
                break;
            // nothing else allowed
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, String) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8551173.java!!!	write(in fieldId : long, inout val : byte [[]]) : void
        assertNotCompacted();
        final int id = (int)fieldId;

        switch ((int)((fieldId & (FIELD_TYPE_MASK | FIELD_COUNT_MASK)) >> FIELD_TYPE_SHIFT)) {
            // bytes
            case (int)((FIELD_TYPE_BYTES | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeBytesImpl(id, val);
                break;
            case (int)((FIELD_TYPE_BYTES | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_BYTES | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedBytesImpl(id, val);
                break;
            // Object
            case (int)((FIELD_TYPE_OBJECT | FIELD_COUNT_SINGLE) >> FIELD_TYPE_SHIFT):
                writeObjectImpl(id, val);
                break;
            case (int)((FIELD_TYPE_OBJECT | FIELD_COUNT_REPEATED) >> FIELD_TYPE_SHIFT):
            case (int)((FIELD_TYPE_OBJECT | FIELD_COUNT_PACKED) >> FIELD_TYPE_SHIFT):
                writeRepeatedObjectImpl(id, val);
                break;
            // nothing else allowed
            default: {
                throw new IllegalArgumentException("Attempt to call write(long, byte[]) with "
                        + getFieldIdString(fieldId));
            }
        }
!!!8551301.java!!!	start(in fieldId : long) : long
        assertNotCompacted();
        final int id = (int)fieldId;

        if ((fieldId & FIELD_TYPE_MASK) == FIELD_TYPE_OBJECT) {
            final long count = fieldId & FIELD_COUNT_MASK;
            if (count == FIELD_COUNT_SINGLE) {
                return startObjectImpl(id, false);
            } else if (count == FIELD_COUNT_REPEATED || count == FIELD_COUNT_PACKED) {
                return startObjectImpl(id, true);
            }
        }
        throw new IllegalArgumentException("Attempt to call start(long) with "
                + getFieldIdString(fieldId));
!!!8551429.java!!!	end(in token : long) : void
        endObjectImpl(token, getRepeatedFromToken(token));
!!!8551557.java!!!	writeDouble(in fieldId : long, in val : double) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_DOUBLE);

        writeDoubleImpl(id, val);
!!!8551685.java!!!	writeDoubleImpl(in id : int, in val : double) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_FIXED64);
            mBuffer.writeRawFixed64(Double.doubleToLongBits(val));
        }
!!!8551813.java!!!	writeRepeatedDouble(in fieldId : long, in val : double) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_DOUBLE);

        writeRepeatedDoubleImpl(id, val);
!!!8551941.java!!!	writeRepeatedDoubleImpl(in id : int, in val : double) : void
        writeTag(id, WIRE_TYPE_FIXED64);
        mBuffer.writeRawFixed64(Double.doubleToLongBits(val));
!!!8552069.java!!!	writePackedDouble(in fieldId : long, inout val : double [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_DOUBLE);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            writeKnownLengthHeader(id, N * 8);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawFixed64(Double.doubleToLongBits(val[i]));
            }
        }
!!!8552197.java!!!	writeFloat(in fieldId : long, in val : float) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_FLOAT);

        writeFloatImpl(id, val);
!!!8552325.java!!!	writeFloatImpl(in id : int, in val : float) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_FIXED32);
            mBuffer.writeRawFixed32(Float.floatToIntBits(val));
        }
!!!8552453.java!!!	writeRepeatedFloat(in fieldId : long, in val : float) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_FLOAT);

        writeRepeatedFloatImpl(id, val);
!!!8552581.java!!!	writeRepeatedFloatImpl(in id : int, in val : float) : void
        writeTag(id, WIRE_TYPE_FIXED32);
        mBuffer.writeRawFixed32(Float.floatToIntBits(val));
!!!8552709.java!!!	writePackedFloat(in fieldId : long, inout val : float [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_FLOAT);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            writeKnownLengthHeader(id, N * 4);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawFixed32(Float.floatToIntBits(val[i]));
            }
        }
!!!8552837.java!!!	writeUnsignedVarintFromSignedInt(in val : int) : void
        if (val >= 0) {
            mBuffer.writeRawVarint32(val);
        } else {
            mBuffer.writeRawVarint64(val);
        }
!!!8552965.java!!!	writeInt32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_INT32);

        writeInt32Impl(id, val);
!!!8553093.java!!!	writeInt32Impl(in id : int, in val : int) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            writeUnsignedVarintFromSignedInt(val);
        }
!!!8553221.java!!!	writeRepeatedInt32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_INT32);

        writeRepeatedInt32Impl(id, val);
!!!8553349.java!!!	writeRepeatedInt32Impl(in id : int, in val : int) : void
        writeTag(id, WIRE_TYPE_VARINT);
        writeUnsignedVarintFromSignedInt(val);
!!!8553477.java!!!	writePackedInt32(in fieldId : long, inout val : int [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_INT32);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                final int v = val[i];
                size += v >= 0 ? EncodedBuffer.getRawVarint32Size(v) : 10;
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                writeUnsignedVarintFromSignedInt(val[i]);
            }
        }
!!!8553605.java!!!	writeInt64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_INT64);

        writeInt64Impl(id, val);
!!!8553733.java!!!	writeInt64Impl(in id : int, in val : long) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            mBuffer.writeRawVarint64(val);
        }
!!!8553861.java!!!	writeRepeatedInt64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_INT64);

        writeRepeatedInt64Impl(id, val);
!!!8553989.java!!!	writeRepeatedInt64Impl(in id : int, in val : long) : void
        writeTag(id, WIRE_TYPE_VARINT);
        mBuffer.writeRawVarint64(val);
!!!8554117.java!!!	writePackedInt64(in fieldId : long, inout val : long [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_INT64);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                size += EncodedBuffer.getRawVarint64Size(val[i]);
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawVarint64(val[i]);
            }
        }
!!!8554245.java!!!	writeUInt32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_UINT32);

        writeUInt32Impl(id, val);
!!!8554373.java!!!	writeUInt32Impl(in id : int, in val : int) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            mBuffer.writeRawVarint32(val);
        }
!!!8554501.java!!!	writeRepeatedUInt32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_UINT32);

        writeRepeatedUInt32Impl(id, val);
!!!8554629.java!!!	writeRepeatedUInt32Impl(in id : int, in val : int) : void
        writeTag(id, WIRE_TYPE_VARINT);
        mBuffer.writeRawVarint32(val);
!!!8554757.java!!!	writePackedUInt32(in fieldId : long, inout val : int [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_UINT32);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                size += EncodedBuffer.getRawVarint32Size(val[i]);
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawVarint32(val[i]);
            }
        }
!!!8554885.java!!!	writeUInt64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_UINT64);

        writeUInt64Impl(id, val);
!!!8555013.java!!!	writeUInt64Impl(in id : int, in val : long) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            mBuffer.writeRawVarint64(val);
        }
!!!8555141.java!!!	writeRepeatedUInt64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_UINT64);

        writeRepeatedUInt64Impl(id, val);
!!!8555269.java!!!	writeRepeatedUInt64Impl(in id : int, in val : long) : void
        writeTag(id, WIRE_TYPE_VARINT);
        mBuffer.writeRawVarint64(val);
!!!8555397.java!!!	writePackedUInt64(in fieldId : long, inout val : long [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_UINT64);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                size += EncodedBuffer.getRawVarint64Size(val[i]);
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawVarint64(val[i]);
            }
        }
!!!8555525.java!!!	writeSInt32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_SINT32);

        writeSInt32Impl(id, val);
!!!8555653.java!!!	writeSInt32Impl(in id : int, in val : int) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            mBuffer.writeRawZigZag32(val);
        }
!!!8555781.java!!!	writeRepeatedSInt32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_SINT32);

        writeRepeatedSInt32Impl(id, val);
!!!8555909.java!!!	writeRepeatedSInt32Impl(in id : int, in val : int) : void
        writeTag(id, WIRE_TYPE_VARINT);
        mBuffer.writeRawZigZag32(val);
!!!8556037.java!!!	writePackedSInt32(in fieldId : long, inout val : int [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_SINT32);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                size += EncodedBuffer.getRawZigZag32Size(val[i]);
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawZigZag32(val[i]);
            }
        }
!!!8556165.java!!!	writeSInt64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_SINT64);

        writeSInt64Impl(id, val);
!!!8556293.java!!!	writeSInt64Impl(in id : int, in val : long) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            mBuffer.writeRawZigZag64(val);
        }
!!!8556421.java!!!	writeRepeatedSInt64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_SINT64);

        writeRepeatedSInt64Impl(id, val);
!!!8556549.java!!!	writeRepeatedSInt64Impl(in id : int, in val : long) : void
        writeTag(id, WIRE_TYPE_VARINT);
        mBuffer.writeRawZigZag64(val);
!!!8556677.java!!!	writePackedSInt64(in fieldId : long, inout val : long [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_SINT64);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                size += EncodedBuffer.getRawZigZag64Size(val[i]);
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawZigZag64(val[i]);
            }
        }
!!!8556805.java!!!	writeFixed32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_FIXED32);

        writeFixed32Impl(id, val);
!!!8556933.java!!!	writeFixed32Impl(in id : int, in val : int) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_FIXED32);
            mBuffer.writeRawFixed32(val);
        }
!!!8557061.java!!!	writeRepeatedFixed32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_FIXED32);

        writeRepeatedFixed32Impl(id, val);
!!!8557189.java!!!	writeRepeatedFixed32Impl(in id : int, in val : int) : void
        writeTag(id, WIRE_TYPE_FIXED32);
        mBuffer.writeRawFixed32(val);
!!!8557317.java!!!	writePackedFixed32(in fieldId : long, inout val : int [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_FIXED32);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            writeKnownLengthHeader(id, N * 4);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawFixed32(val[i]);
            }
        }
!!!8557445.java!!!	writeFixed64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_FIXED64);

        writeFixed64Impl(id, val);
!!!8557573.java!!!	writeFixed64Impl(in id : int, in val : long) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_FIXED64);
            mBuffer.writeRawFixed64(val);
        }
!!!8557701.java!!!	writeRepeatedFixed64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_FIXED64);

        writeRepeatedFixed64Impl(id, val);
!!!8557829.java!!!	writeRepeatedFixed64Impl(in id : int, in val : long) : void
        writeTag(id, WIRE_TYPE_FIXED64);
        mBuffer.writeRawFixed64(val);
!!!8557957.java!!!	writePackedFixed64(in fieldId : long, inout val : long [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_FIXED64);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            writeKnownLengthHeader(id, N * 8);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawFixed64(val[i]);
            }
        }
!!!8558085.java!!!	writeSFixed32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_SFIXED32);

        writeSFixed32Impl(id, val);
!!!8558213.java!!!	writeSFixed32Impl(in id : int, in val : int) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_FIXED32);
            mBuffer.writeRawFixed32(val);
        }
!!!8558341.java!!!	writeRepeatedSFixed32(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_SFIXED32);

        writeRepeatedSFixed32Impl(id, val);
!!!8558469.java!!!	writeRepeatedSFixed32Impl(in id : int, in val : int) : void
        writeTag(id, WIRE_TYPE_FIXED32);
        mBuffer.writeRawFixed32(val);
!!!8558597.java!!!	writePackedSFixed32(in fieldId : long, inout val : int [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_SFIXED32);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            writeKnownLengthHeader(id, N * 4);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawFixed32(val[i]);
            }
        }
!!!8558725.java!!!	writeSFixed64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_SFIXED64);

        writeSFixed64Impl(id, val);
!!!8558853.java!!!	writeSFixed64Impl(in id : int, in val : long) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_FIXED64);
            mBuffer.writeRawFixed64(val);
        }
!!!8558981.java!!!	writeRepeatedSFixed64(in fieldId : long, in val : long) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_SFIXED64);

        writeRepeatedSFixed64Impl(id, val);
!!!8559109.java!!!	writeRepeatedSFixed64Impl(in id : int, in val : long) : void
        writeTag(id, WIRE_TYPE_FIXED64);
        mBuffer.writeRawFixed64(val);
!!!8559237.java!!!	writePackedSFixed64(in fieldId : long, inout val : long [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_SFIXED64);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            writeKnownLengthHeader(id, N * 8);
            for (int i=0; i<N; i++) {
                mBuffer.writeRawFixed64(val[i]);
            }
        }
!!!8559365.java!!!	writeBool(in fieldId : long, inout val : boolean) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_BOOL);

        writeBoolImpl(id, val);
!!!8559493.java!!!	writeBoolImpl(in id : int, inout val : boolean) : void
        if (val) {
            writeTag(id, WIRE_TYPE_VARINT);
            // 0 and 1 are the same as their varint counterparts
            mBuffer.writeRawByte((byte)1);
        }
!!!8559621.java!!!	writeRepeatedBool(in fieldId : long, inout val : boolean) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_BOOL);

        writeRepeatedBoolImpl(id, val);
!!!8559749.java!!!	writeRepeatedBoolImpl(in id : int, inout val : boolean) : void
        writeTag(id, WIRE_TYPE_VARINT);
        mBuffer.writeRawByte((byte)(val ? 1 : 0));
!!!8559877.java!!!	writePackedBool(in fieldId : long, inout val : boolean [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_BOOL);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            // Write the header
            writeKnownLengthHeader(id, N);

            // Write the data
            for (int i=0; i<N; i++) {
                // 0 and 1 are the same as their varint counterparts
                mBuffer.writeRawByte((byte)(val[i] ? 1 : 0));
            }
        }
!!!8560005.java!!!	writeString(in fieldId : long, in val : String) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_STRING);

        writeStringImpl(id, val);
!!!8560133.java!!!	writeStringImpl(in id : int, in val : String) : void
        if (val != null && val.length() > 0) {
            writeUtf8String(id, val);
        }
!!!8560261.java!!!	writeRepeatedString(in fieldId : long, in val : String) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_STRING);

        writeRepeatedStringImpl(id, val);
!!!8560389.java!!!	writeRepeatedStringImpl(in id : int, in val : String) : void
        if (val == null || val.length() == 0) {
            writeKnownLengthHeader(id, 0);
        } else {
            writeUtf8String(id, val);
        }
!!!8560517.java!!!	writeUtf8String(in id : int, in val : String) : void
        // TODO: Is it worth converting by hand in order to not allocate?
        try {
            final byte[] buf = val.getBytes("UTF-8");
            writeKnownLengthHeader(id, buf.length);
            mBuffer.writeRawBuffer(buf);
        } catch (UnsupportedEncodingException ex) {
            throw new RuntimeException("not possible");
        }
!!!8560645.java!!!	writeBytes(in fieldId : long, inout val : byte [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_BYTES);

        writeBytesImpl(id, val);
!!!8560773.java!!!	writeBytesImpl(in id : int, inout val : byte [[]]) : void
        if (val != null && val.length > 0) {
            writeKnownLengthHeader(id, val.length);
            mBuffer.writeRawBuffer(val);
        }
!!!8560901.java!!!	writeRepeatedBytes(in fieldId : long, inout val : byte [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_BYTES);

        writeRepeatedBytesImpl(id, val);
!!!8561029.java!!!	writeRepeatedBytesImpl(in id : int, inout val : byte [[]]) : void
        writeKnownLengthHeader(id, val == null ? 0 : val.length);
        mBuffer.writeRawBuffer(val);
!!!8561157.java!!!	writeEnum(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_ENUM);

        writeEnumImpl(id, val);
!!!8561285.java!!!	writeEnumImpl(in id : int, in val : int) : void
        if (val != 0) {
            writeTag(id, WIRE_TYPE_VARINT);
            writeUnsignedVarintFromSignedInt(val);
        }
!!!8561413.java!!!	writeRepeatedEnum(in fieldId : long, in val : int) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_ENUM);

        writeRepeatedEnumImpl(id, val);
!!!8561541.java!!!	writeRepeatedEnumImpl(in id : int, in val : int) : void
        writeTag(id, WIRE_TYPE_VARINT);
        writeUnsignedVarintFromSignedInt(val);
!!!8561669.java!!!	writePackedEnum(in fieldId : long, inout val : int [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_PACKED | FIELD_TYPE_ENUM);

        final int N = val != null ? val.length : 0;
        if (N > 0) {
            int size = 0;
            for (int i=0; i<N; i++) {
                final int v = val[i];
                size += v >= 0 ? EncodedBuffer.getRawVarint32Size(v) : 10;
            }
            writeKnownLengthHeader(id, size);
            for (int i=0; i<N; i++) {
                writeUnsignedVarintFromSignedInt(val[i]);
            }
        }
!!!8561797.java!!!	makeToken(in tagSize : int, inout repeated : boolean, in depth : int, in objectId : int, in sizePos : int) : long
        return ((0x07L & (long)tagSize) << 61)
                | (repeated ? (1L << 60) : 0)
                | (0x01ffL & (long)depth) << 51
                | (0x07ffffL & (long)objectId) << 32
                | (0x0ffffffffL & (long)sizePos);
!!!8561925.java!!!	getTagSizeFromToken(in token : long) : int
        return (int)(0x7 & (token >> 61));
!!!8562053.java!!!	getRepeatedFromToken(in token : long) : boolean
        return (0x1 & (token >> 60)) != 0;
!!!8562181.java!!!	getDepthFromToken(in token : long) : int
        return (int)(0x01ff & (token >> 51));
!!!8562309.java!!!	getObjectIdFromToken(in token : long) : int
        return (int)(0x07ffff & (token >> 32));
!!!8562437.java!!!	getSizePosFromToken(in token : long) : int
        return (int)token;
!!!8562565.java!!!	convertObjectIdToOrdinal(in objectId : int) : int
        return (-1 & 0x07ffff) - objectId;
!!!8562693.java!!!	token2String(in token : long) : String
        if (token == 0L) {
            return "Token(0)";
        } else {
            return "Token(val=0x" + Long.toHexString(token)
                    + " depth=" + getDepthFromToken(token)
                    + " object=" + convertObjectIdToOrdinal(getObjectIdFromToken(token))
                    + " tagSize=" + getTagSizeFromToken(token)
                    + " sizePos=" + getSizePosFromToken(token)
                    + ')';
        }
!!!8562821.java!!!	startObject(in fieldId : long) : long
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_OBJECT);

        return startObjectImpl(id, false);
!!!8562949.java!!!	endObject(in token : long) : void
        assertNotCompacted();

        endObjectImpl(token, false);
!!!8563077.java!!!	startRepeatedObject(in fieldId : long) : long
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT);

        return startObjectImpl(id, true);
!!!8563205.java!!!	endRepeatedObject(in token : long) : void
        assertNotCompacted();

        endObjectImpl(token, true);
!!!8563333.java!!!	startObjectImpl(in id : int, inout repeated : boolean) : long
        writeTag(id, WIRE_TYPE_LENGTH_DELIMITED);
        final int sizePos = mBuffer.getWritePos();
        mDepth++;
        mNextObjectId--;

        // Write the previous token, giving us a stack of expected tokens.
        // After endObject returns, the first fixed32 becomeschildRawSize (set in endObject)
        // and the second one becomes childEncodedSize (set in editEncodedSize).
        mBuffer.writeRawFixed32((int)(mExpectedObjectToken >> 32));
        mBuffer.writeRawFixed32((int)mExpectedObjectToken);

        long old = mExpectedObjectToken;

        mExpectedObjectToken = makeToken(getTagSize(id), repeated, mDepth, mNextObjectId, sizePos);
        return mExpectedObjectToken;
!!!8563461.java!!!	endObjectImpl(in token : long, inout repeated : boolean) : void
        // The upper 32 bits of the token is the depth of startObject /
        // endObject calls.  We could get aritrarily sophisticated, but
        // that's enough to prevent the common error of missing an
        // endObject somewhere.
        // The lower 32 bits of the token is the offset in the buffer
        // at which to write the size.
        final int depth = getDepthFromToken(token);
        final boolean expectedRepeated = getRepeatedFromToken(token);
        final int sizePos = getSizePosFromToken(token);
        final int childRawSize = mBuffer.getWritePos() - sizePos - 8;

        if (repeated != expectedRepeated) {
            if (repeated) {
                throw new IllegalArgumentException("endRepeatedObject called where endObject should"
                        + " have been");
            } else {
                throw new IllegalArgumentException("endObject called where endRepeatedObject should"
                        + " have been");
            }
        }

        // Check that we're getting the token and depth that we are expecting.
        if ((mDepth & 0x01ff) != depth || mExpectedObjectToken != token) {
            // This text of exception is united tested.  That test also implicity checks
            // that we're tracking the objectIds and depths correctly.
            throw new IllegalArgumentException("Mismatched startObject/endObject calls."
                    + " Current depth " + mDepth
                    + " token=" + token2String(token)
                    + " expectedToken=" + token2String(mExpectedObjectToken));
        }

        // Get the next expected token that we stashed away in the buffer.
        mExpectedObjectToken = (((long)mBuffer.getRawFixed32At(sizePos)) << 32)
                | (0x0ffffffffL & (long)mBuffer.getRawFixed32At(sizePos+4));

        mDepth--;
        if (childRawSize > 0) {
            mBuffer.editRawFixed32(sizePos, -childRawSize);
            mBuffer.editRawFixed32(sizePos+4, -1);
        } else if (repeated) {
            mBuffer.editRawFixed32(sizePos, 0);
            mBuffer.editRawFixed32(sizePos+4, 0);
        } else {
            // The object has no data.  Don't include it.
            mBuffer.rewindWriteTo(sizePos - getTagSizeFromToken(token));
        }
!!!8563589.java!!!	writeObject(in fieldId : long, inout value : byte [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_SINGLE | FIELD_TYPE_OBJECT);

        writeObjectImpl(id, value);
!!!8563717.java!!!	writeObjectImpl(in id : int, inout value : byte [[]]) : void
        if (value != null && value.length != 0) {
            writeKnownLengthHeader(id, value.length);
            mBuffer.writeRawBuffer(value);
        }
!!!8563845.java!!!	writeRepeatedObject(in fieldId : long, inout value : byte [[]]) : void
        assertNotCompacted();
        final int id = checkFieldId(fieldId, FIELD_COUNT_REPEATED | FIELD_TYPE_OBJECT);

        writeRepeatedObjectImpl(id, value);
!!!8563973.java!!!	writeRepeatedObjectImpl(in id : int, inout value : byte [[]]) : void
        writeKnownLengthHeader(id, value == null ? 0 : value.length);
        mBuffer.writeRawBuffer(value);
!!!8564101.java!!!	makeFieldId(in id : int, in fieldFlags : long) : long
        return fieldFlags | (((long)id) & 0x0ffffffffL);
!!!8564229.java!!!	checkFieldId(in fieldId : long, in expectedFlags : long) : int
        final long fieldCount = fieldId & FIELD_COUNT_MASK;
        final long fieldType = fieldId & FIELD_TYPE_MASK;
        final long expectedCount = expectedFlags & FIELD_COUNT_MASK;
        final long expectedType = expectedFlags & FIELD_TYPE_MASK;
        if (((int)fieldId) == 0) {
            throw new IllegalArgumentException("Invalid proto field " + (int)fieldId
                    + " fieldId=" + Long.toHexString(fieldId));
        }
        if (fieldType != expectedType
                || !((fieldCount == expectedCount)
                    || (fieldCount == FIELD_COUNT_PACKED
                        && expectedCount == FIELD_COUNT_REPEATED))) {
            final String countString = getFieldCountString(fieldCount);
            final String typeString = getFieldTypeString(fieldType);
            if (typeString != null && countString != null) {
                final StringBuilder sb = new StringBuilder();
                if (expectedType == FIELD_TYPE_OBJECT) {
                    sb.append("start");
                } else {
                    sb.append("write");
                }
                sb.append(getFieldCountString(expectedCount));
                sb.append(getFieldTypeString(expectedType));
                sb.append(" called for field ");
                sb.append((int)fieldId);
                sb.append(" which should be used with ");
                if (fieldType == FIELD_TYPE_OBJECT) {
                    sb.append("start");
                } else {
                    sb.append("write");
                }
                sb.append(countString);
                sb.append(typeString);
                if (fieldCount == FIELD_COUNT_PACKED) {
                    sb.append(" or writeRepeated");
                    sb.append(typeString);
                }
                sb.append('.');
                throw new IllegalArgumentException(sb.toString());
            } else {
                final StringBuilder sb = new StringBuilder();
                if (expectedType == FIELD_TYPE_OBJECT) {
                    sb.append("start");
                } else {
                    sb.append("write");
                }
                sb.append(getFieldCountString(expectedCount));
                sb.append(getFieldTypeString(expectedType));
                sb.append(" called with an invalid fieldId: 0x");
                sb.append(Long.toHexString(fieldId));
                sb.append(". The proto field ID might be ");
                sb.append((int)fieldId);
                sb.append('.');
                throw new IllegalArgumentException(sb.toString());
            }
        }
        return (int)fieldId;
!!!8564357.java!!!	getFieldTypeString(in fieldType : long) : String
        int index = ((int)((fieldType & FIELD_TYPE_MASK) >>> FIELD_TYPE_SHIFT)) - 1;
        if (index >= 0 && index < FIELD_TYPE_NAMES.length) {
            return FIELD_TYPE_NAMES[index];
        } else {
            return null;
        }
!!!8564485.java!!!	getFieldCountString(in fieldCount : long) : String
        if (fieldCount == FIELD_COUNT_SINGLE) {
            return "";
        } else if (fieldCount == FIELD_COUNT_REPEATED) {
            return "Repeated";
        } else if (fieldCount == FIELD_COUNT_PACKED) {
            return "Packed";
        } else {
            return null;
        }
!!!8564613.java!!!	getFieldIdString(in fieldId : long) : String
        final long fieldCount = fieldId & FIELD_COUNT_MASK;
        String countString = getFieldCountString(fieldCount);
        if (countString == null) {
            countString = "fieldCount=" + fieldCount;
        }

        final long fieldType = fieldId & FIELD_TYPE_MASK;
        String typeString = getFieldTypeString(fieldType);
        if (typeString == null) {
            typeString = "fieldType=" + fieldType;
        }

        return fieldCount + " " + typeString + " tag=" + ((int)fieldId)
                + " fieldId=0x" + Long.toHexString(fieldId);
!!!8564741.java!!!	getTagSize(in id : int) : int
        return EncodedBuffer.getRawVarint32Size(id << FIELD_ID_SHIFT);
!!!8564869.java!!!	writeTag(in id : int, in wireType : int) : void
        mBuffer.writeRawVarint32((id << FIELD_ID_SHIFT) | wireType);
!!!8564997.java!!!	writeKnownLengthHeader(in id : int, in size : int) : void
        // Write the tag
        writeTag(id, WIRE_TYPE_LENGTH_DELIMITED);
        // Size will be compacted later, but we know the size, so write it,
        // once for the rawSize and once for the encodedSize.
        mBuffer.writeRawFixed32(size);
        mBuffer.writeRawFixed32(size);
!!!8565125.java!!!	assertNotCompacted() : void
        if (mCompacted) {
            throw new IllegalArgumentException("write called after compact");
        }
!!!8565253.java!!!	getBytes() : byte
        compactIfNecessary();

        return mBuffer.getBytes(mBuffer.getReadableSize());
!!!8565381.java!!!	compactIfNecessary() : void
        if (!mCompacted) {
            if (mDepth != 0) {
                throw new IllegalArgumentException("Trying to compact with " + mDepth
                        + " missing calls to endObject");
            }

            // The buffer must be compacted.
            mBuffer.startEditing();
            final int readableSize = mBuffer.getReadableSize();

            // Cache the sizes of the objects
            editEncodedSize(readableSize);

            // Re-write the buffer with the sizes as proper varints instead
            // of pairs of uint32s. We know this will always fit in the same
            // buffer because the pair of uint32s is exactly 8 bytes long, and
            // the single varint size will be no more than 5 bytes long.
            mBuffer.rewindRead();
            compactSizes(readableSize);

            // If there is any data left over that wasn't copied yet, copy it.
            if (mCopyBegin < readableSize) {
                mBuffer.writeFromThisBuffer(mCopyBegin, readableSize - mCopyBegin);
            }

            // Set the new readableSize
            mBuffer.startEditing();

            // It's not valid to write to this object anymore. The write
            // pointers are off, and then some of the data would be compacted
            // and some not.
            mCompacted = true;
        }
!!!8565509.java!!!	editEncodedSize(in rawSize : int) : int
        int objectStart = mBuffer.getReadPos();
        int objectEnd = objectStart + rawSize;
        int encodedSize = 0;
        int tagPos;

        while ((tagPos = mBuffer.getReadPos()) < objectEnd) {
            int tag = readRawTag();
            encodedSize += EncodedBuffer.getRawVarint32Size(tag);

            final int wireType = tag & WIRE_TYPE_MASK;
            switch (wireType) {
                case WIRE_TYPE_VARINT:
                    encodedSize++;
                    while ((mBuffer.readRawByte() & 0x80) != 0) {
                        encodedSize++;
                    }
                    break;
                case WIRE_TYPE_FIXED64:
                    encodedSize += 8;
                    mBuffer.skipRead(8);
                    break;
                case WIRE_TYPE_LENGTH_DELIMITED: {
                    // This object is not of a fixed-size type.  So we need to figure
                    // out how big it should be.
                    final int childRawSize = mBuffer.readRawFixed32();
                    final int childEncodedSizePos = mBuffer.getReadPos();
                    int childEncodedSize = mBuffer.readRawFixed32();
                    if (childRawSize >= 0) {
                        // We know the size, just skip ahead.
                        if (childEncodedSize != childRawSize) {
                            throw new RuntimeException("Pre-computed size where the"
                                    + " precomputed size and the raw size in the buffer"
                                    + " don't match! childRawSize=" + childRawSize
                                    + " childEncodedSize=" + childEncodedSize
                                    + " childEncodedSizePos=" + childEncodedSizePos);
                        }
                        mBuffer.skipRead(childRawSize);
                    } else {
                        // We need to compute the size.  Recurse.
                        childEncodedSize = editEncodedSize(-childRawSize);
                        mBuffer.editRawFixed32(childEncodedSizePos, childEncodedSize);
                    }
                    encodedSize += EncodedBuffer.getRawVarint32Size(childEncodedSize)
                            + childEncodedSize;
                    break;
                }
                case WIRE_TYPE_START_GROUP:
                case WIRE_TYPE_END_GROUP:
                    throw new RuntimeException("groups not supported at index " + tagPos);
                case WIRE_TYPE_FIXED32:
                    encodedSize += 4;
                    mBuffer.skipRead(4);
                    break;
                default:
                    throw new ProtoParseException("editEncodedSize Bad tag tag=0x"
                            + Integer.toHexString(tag) + " wireType=" + wireType
                            + " -- " + mBuffer.getDebugString());
            }
        }

        return encodedSize;
!!!8565637.java!!!	compactSizes(in rawSize : int) : void
        int objectStart = mBuffer.getReadPos();
        int objectEnd = objectStart + rawSize;
        int tagPos;
        while ((tagPos = mBuffer.getReadPos()) < objectEnd) {
            int tag = readRawTag();

            // For all the non-length-delimited field types, just skip over them,
            // and we'll just System.arraycopy it later, either in the case for
            // WIRE_TYPE_LENGTH_DELIMITED or at the top of the stack in compactIfNecessary().
            final int wireType = tag & WIRE_TYPE_MASK;
            switch (wireType) {
                case WIRE_TYPE_VARINT:
                    while ((mBuffer.readRawByte() & 0x80) != 0) { }
                    break;
                case WIRE_TYPE_FIXED64:
                    mBuffer.skipRead(8);
                    break;
                case WIRE_TYPE_LENGTH_DELIMITED: {
                    // Copy everything up to now, including the tag for this field.
                    mBuffer.writeFromThisBuffer(mCopyBegin, mBuffer.getReadPos() - mCopyBegin);
                    // Write the new size.
                    final int childRawSize = mBuffer.readRawFixed32();
                    final int childEncodedSize = mBuffer.readRawFixed32();
                    mBuffer.writeRawVarint32(childEncodedSize);
                    // Next time, start copying from here.
                    mCopyBegin = mBuffer.getReadPos();
                    if (childRawSize >= 0) {
                        // This is raw data, not an object. Skip ahead by the size.
                        // Recurse into the child
                        mBuffer.skipRead(childEncodedSize);
                    } else {
                        compactSizes(-childRawSize);
                    }
                    break;
                    // TODO: What does regular proto do if the object would be 0 size
                    // (e.g. if it is all default values).
                }
                case WIRE_TYPE_START_GROUP:
                case WIRE_TYPE_END_GROUP:
                    throw new RuntimeException("groups not supported at index " + tagPos);
                case WIRE_TYPE_FIXED32:
                    mBuffer.skipRead(4);
                    break;
                default:
                    throw new ProtoParseException("compactSizes Bad tag tag=0x"
                            + Integer.toHexString(tag) + " wireType=" + wireType
                            + " -- " + mBuffer.getDebugString());
            }
        }
!!!8565765.java!!!	flush() : void
        if (mStream == null) {
            return;
        }
        if (mDepth != 0) {
            // TODO: The compacting code isn't ready yet to compact unless we're done.
            // TODO: Fix that.
            return;
        }
        if (mCompacted) {
            // If we're compacted, we already wrote it finished.
            return;
        }
        compactIfNecessary();
        final byte[] data = mBuffer.getBytes(mBuffer.getReadableSize());
        try {
            mStream.write(data);
            mStream.flush();
        } catch (IOException ex) {
            throw new RuntimeException("Error flushing proto to stream", ex);
        }
!!!8565893.java!!!	readRawTag() : int
        if (mBuffer.getReadPos() == mBuffer.getReadableSize()) {
            return 0;
        }
        return (int)mBuffer.readRawUnsigned();
!!!8566021.java!!!	dump(in tag : String) : void
        Log.d(tag, mBuffer.getDebugString());
        mBuffer.dumpBuffers(tag);
