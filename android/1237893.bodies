class ConnectivityManager
!!!7086469.java!!!	isNetworkTypeValid(in networkType : int) : boolean
        return networkType >= 0 && networkType <= MAX_NETWORK_TYPE;
!!!7086597.java!!!	getNetworkTypeName(in type : int) : String
        switch (type) {
            case TYPE_MOBILE:
                return "MOBILE";
            case TYPE_WIFI:
                return "WIFI";
            case TYPE_MOBILE_MMS:
                return "MOBILE_MMS";
            case TYPE_MOBILE_SUPL:
                return "MOBILE_SUPL";
            case TYPE_MOBILE_DUN:
                return "MOBILE_DUN";
            case TYPE_MOBILE_HIPRI:
                return "MOBILE_HIPRI";
            case TYPE_WIMAX:
                return "WIMAX";
            case TYPE_BLUETOOTH:
                return "BLUETOOTH";
            case TYPE_DUMMY:
                return "DUMMY";
            case TYPE_ETHERNET:
                return "ETHERNET";
            case TYPE_MOBILE_FOTA:
                return "MOBILE_FOTA";
            case TYPE_MOBILE_IMS:
                return "MOBILE_IMS";
            case TYPE_MOBILE_CBS:
                return "MOBILE_CBS";
            case TYPE_WIFI_P2P:
                return "WIFI_P2P";
            case TYPE_MOBILE_IA:
                return "MOBILE_IA";
            case TYPE_MOBILE_EMERGENCY:
                return "MOBILE_EMERGENCY";
            case TYPE_PROXY:
                return "PROXY";
            case TYPE_VPN:
                return "VPN";
            default:
                return Integer.toString(type);
        }
!!!7086725.java!!!	isNetworkTypeMobile(in networkType : int) : boolean
        switch (networkType) {
            case TYPE_MOBILE:
            case TYPE_MOBILE_MMS:
            case TYPE_MOBILE_SUPL:
            case TYPE_MOBILE_DUN:
            case TYPE_MOBILE_HIPRI:
            case TYPE_MOBILE_FOTA:
            case TYPE_MOBILE_IMS:
            case TYPE_MOBILE_CBS:
            case TYPE_MOBILE_IA:
            case TYPE_MOBILE_EMERGENCY:
                return true;
            default:
                return false;
        }
!!!7086853.java!!!	isNetworkTypeWifi(in networkType : int) : boolean
        switch (networkType) {
            case TYPE_WIFI:
            case TYPE_WIFI_P2P:
                return true;
            default:
                return false;
        }
!!!7087109.java!!!	getNetworkPreference() : int
        return TYPE_NONE;
!!!7087237.java!!!	getActiveNetworkInfo() : NetworkInfo
        try {
            return mService.getActiveNetworkInfo();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7087365.java!!!	getActiveNetwork() : Network
        try {
            return mService.getActiveNetwork();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7087493.java!!!	getActiveNetworkForUid(in uid : int) : Network
        return getActiveNetworkForUid(uid, false);
!!!7087621.java!!!	getActiveNetworkForUid(in uid : int, inout ignoreBlocked : boolean) : Network
        try {
            return mService.getActiveNetworkForUid(uid, ignoreBlocked);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7087749.java!!!	setAlwaysOnVpnPackageForUser(in userId : int, in vpnPackage : String, inout lockdownEnabled : boolean) : boolean
        try {
            return mService.setAlwaysOnVpnPackage(userId, vpnPackage, lockdownEnabled);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7087877.java!!!	getAlwaysOnVpnPackageForUser(in userId : int) : String
        try {
            return mService.getAlwaysOnVpnPackage(userId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7088005.java!!!	getActiveNetworkInfoForUid(in uid : int) : NetworkInfo
        return getActiveNetworkInfoForUid(uid, false);
!!!7088133.java!!!	getActiveNetworkInfoForUid(in uid : int, inout ignoreBlocked : boolean) : NetworkInfo
        try {
            return mService.getActiveNetworkInfoForUid(uid, ignoreBlocked);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7088261.java!!!	getNetworkInfo(in networkType : int) : NetworkInfo
        try {
            return mService.getNetworkInfo(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7088389.java!!!	getNetworkInfo(inout network : Network) : NetworkInfo
        return getNetworkInfoForUid(network, Process.myUid(), false);
!!!7088517.java!!!	getNetworkInfoForUid(inout network : Network, in uid : int, inout ignoreBlocked : boolean) : NetworkInfo
        try {
            return mService.getNetworkInfoForUid(network, uid, ignoreBlocked);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7088645.java!!!	getAllNetworkInfo() : NetworkInfo
        try {
            return mService.getAllNetworkInfo();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7088773.java!!!	getNetworkForType(in networkType : int) : Network
        try {
            return mService.getNetworkForType(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7088901.java!!!	getAllNetworks() : Network
        try {
            return mService.getAllNetworks();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089029.java!!!	getDefaultNetworkCapabilitiesForUser(in userId : int) : NetworkCapabilities
        try {
            return mService.getDefaultNetworkCapabilitiesForUser(userId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089157.java!!!	getActiveLinkProperties() : LinkProperties
        try {
            return mService.getActiveLinkProperties();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089285.java!!!	getLinkProperties(in networkType : int) : LinkProperties
        try {
            return mService.getLinkPropertiesForType(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089413.java!!!	getLinkProperties(inout network : Network) : LinkProperties
        try {
            return mService.getLinkProperties(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089541.java!!!	getNetworkCapabilities(inout network : Network) : NetworkCapabilities
        try {
            return mService.getNetworkCapabilities(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089669.java!!!	getCaptivePortalServerUrl() : String
        try {
            return mService.getCaptivePortalServerUrl();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7089797.java!!!	startUsingNetworkFeature(in networkType : int, in feature : String) : int
        checkLegacyRoutingApiAccess();
        NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
        if (netCap == null) {
            Log.d(TAG, "Can't satisfy startUsingNetworkFeature for " + networkType + ", " +
                    feature);
            return PhoneConstants.APN_REQUEST_FAILED;
        }

        NetworkRequest request = null;
        synchronized (sLegacyRequests) {
            LegacyRequest l = sLegacyRequests.get(netCap);
            if (l != null) {
                Log.d(TAG, "renewing startUsingNetworkFeature request " + l.networkRequest);
                renewRequestLocked(l);
                if (l.currentNetwork != null) {
                    return PhoneConstants.APN_ALREADY_ACTIVE;
                } else {
                    return PhoneConstants.APN_REQUEST_STARTED;
                }
            }

            request = requestNetworkForFeatureLocked(netCap);
        }
        if (request != null) {
            Log.d(TAG, "starting startUsingNetworkFeature for request " + request);
            return PhoneConstants.APN_REQUEST_STARTED;
        } else {
            Log.d(TAG, " request Failed");
            return PhoneConstants.APN_REQUEST_FAILED;
        }
!!!7089925.java!!!	stopUsingNetworkFeature(in networkType : int, in feature : String) : int
        checkLegacyRoutingApiAccess();
        NetworkCapabilities netCap = networkCapabilitiesForFeature(networkType, feature);
        if (netCap == null) {
            Log.d(TAG, "Can't satisfy stopUsingNetworkFeature for " + networkType + ", " +
                    feature);
            return -1;
        }

        if (removeRequestForFeature(netCap)) {
            Log.d(TAG, "stopUsingNetworkFeature for " + networkType + ", " + feature);
        }
        return 1;
!!!7090053.java!!!	networkCapabilitiesForFeature(in networkType : int, in feature : String) : NetworkCapabilities
        if (networkType == TYPE_MOBILE) {
            switch (feature) {
                case "enableCBS":
                    return networkCapabilitiesForType(TYPE_MOBILE_CBS);
                case "enableDUN":
                case "enableDUNAlways":
                    return networkCapabilitiesForType(TYPE_MOBILE_DUN);
                case "enableFOTA":
                    return networkCapabilitiesForType(TYPE_MOBILE_FOTA);
                case "enableHIPRI":
                    return networkCapabilitiesForType(TYPE_MOBILE_HIPRI);
                case "enableIMS":
                    return networkCapabilitiesForType(TYPE_MOBILE_IMS);
                case "enableMMS":
                    return networkCapabilitiesForType(TYPE_MOBILE_MMS);
                case "enableSUPL":
                    return networkCapabilitiesForType(TYPE_MOBILE_SUPL);
                default:
                    return null;
            }
        } else if (networkType == TYPE_WIFI && "p2p".equals(feature)) {
            return networkCapabilitiesForType(TYPE_WIFI_P2P);
        }
        return null;
!!!7090181.java!!!	inferLegacyTypeForNetworkCapabilities(inout netCap : NetworkCapabilities) : int
        if (netCap == null) {
            return TYPE_NONE;
        }

        if (!netCap.hasTransport(NetworkCapabilities.TRANSPORT_CELLULAR)) {
            return TYPE_NONE;
        }

        // Do this only for SUPL, until GnssLocationProvider is fixed. http://b/25876485 .
        if (!netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
            // NOTE: if this causes app breakage, we should not just comment out this early return;
            // instead, we should make this early return conditional on the requesting app's target
            // SDK version, as described in the comment above.
            return TYPE_NONE;
        }

        String type = null;
        int result = TYPE_NONE;

        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_CBS)) {
            type = "enableCBS";
            result = TYPE_MOBILE_CBS;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS)) {
            type = "enableIMS";
            result = TYPE_MOBILE_IMS;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)) {
            type = "enableFOTA";
            result = TYPE_MOBILE_FOTA;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_DUN)) {
            type = "enableDUN";
            result = TYPE_MOBILE_DUN;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
            type = "enableSUPL";
            result = TYPE_MOBILE_SUPL;
        // back out this hack for mms as they no longer need this and it's causing
        // device slowdowns - b/23350688 (note, supl still needs this)
        //} else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_MMS)) {
        //    type = "enableMMS";
        //    result = TYPE_MOBILE_MMS;
        } else if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
            type = "enableHIPRI";
            result = TYPE_MOBILE_HIPRI;
        }
        if (type != null) {
            NetworkCapabilities testCap = networkCapabilitiesForFeature(TYPE_MOBILE, type);
            if (testCap.equalsNetCapabilities(netCap) && testCap.equalsTransportTypes(netCap)) {
                return result;
            }
        }
        return TYPE_NONE;
!!!7090309.java!!!	legacyTypeForNetworkCapabilities(inout netCap : NetworkCapabilities) : int
        if (netCap == null) return TYPE_NONE;
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_CBS)) {
            return TYPE_MOBILE_CBS;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_IMS)) {
            return TYPE_MOBILE_IMS;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_FOTA)) {
            return TYPE_MOBILE_FOTA;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_DUN)) {
            return TYPE_MOBILE_DUN;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_SUPL)) {
            return TYPE_MOBILE_SUPL;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_MMS)) {
            return TYPE_MOBILE_MMS;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_INTERNET)) {
            return TYPE_MOBILE_HIPRI;
        }
        if (netCap.hasCapability(NetworkCapabilities.NET_CAPABILITY_WIFI_P2P)) {
            return TYPE_WIFI_P2P;
        }
        return TYPE_NONE;
!!!7090565.java!!!	findRequestForFeature(inout netCap : NetworkCapabilities) : NetworkRequest
        synchronized (sLegacyRequests) {
            LegacyRequest l = sLegacyRequests.get(netCap);
            if (l != null) return l.networkRequest;
        }
        return null;
!!!7090693.java!!!	renewRequestLocked(inout l : ConnectivityManager::LegacyRequest) : void
        l.expireSequenceNumber++;
        Log.d(TAG, "renewing request to seqNum " + l.expireSequenceNumber);
        sendExpireMsgForFeature(l.networkCapabilities, l.expireSequenceNumber, l.delay);
!!!7090821.java!!!	expireRequest(inout netCap : NetworkCapabilities, in sequenceNum : int) : void
        int ourSeqNum = -1;
        synchronized (sLegacyRequests) {
            LegacyRequest l = sLegacyRequests.get(netCap);
            if (l == null) return;
            ourSeqNum = l.expireSequenceNumber;
            if (l.expireSequenceNumber == sequenceNum) removeRequestForFeature(netCap);
        }
        Log.d(TAG, "expireRequest with " + ourSeqNum + ", " + sequenceNum);
!!!7090949.java!!!	requestNetworkForFeatureLocked(inout netCap : NetworkCapabilities) : NetworkRequest
        int delay = -1;
        int type = legacyTypeForNetworkCapabilities(netCap);
        try {
            delay = mService.getRestoreDefaultNetworkDelay(type);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        LegacyRequest l = new LegacyRequest();
        l.networkCapabilities = netCap;
        l.delay = delay;
        l.expireSequenceNumber = 0;
        l.networkRequest = sendRequestForNetwork(
                netCap, l.networkCallback, 0, REQUEST, type, getDefaultHandler());
        if (l.networkRequest == null) return null;
        sLegacyRequests.put(netCap, l);
        sendExpireMsgForFeature(netCap, l.expireSequenceNumber, delay);
        return l.networkRequest;
!!!7091077.java!!!	sendExpireMsgForFeature(inout netCap : NetworkCapabilities, in seqNum : int, in delay : int) : void
        if (delay >= 0) {
            Log.d(TAG, "sending expire msg with seqNum " + seqNum + " and delay " + delay);
            CallbackHandler handler = getDefaultHandler();
            Message msg = handler.obtainMessage(EXPIRE_LEGACY_REQUEST, seqNum, 0, netCap);
            handler.sendMessageDelayed(msg, delay);
        }
!!!7091205.java!!!	removeRequestForFeature(inout netCap : NetworkCapabilities) : boolean
        final LegacyRequest l;
        synchronized (sLegacyRequests) {
            l = sLegacyRequests.remove(netCap);
        }
        if (l == null) return false;
        unregisterNetworkCallback(l.networkCallback);
        l.clearDnsBinding();
        return true;
!!!7091333.java!!!	networkCapabilitiesForType(in type : int) : NetworkCapabilities
        final NetworkCapabilities nc = new NetworkCapabilities();

        // Map from type to transports.
        final int NOT_FOUND = -1;
        final int transport = sLegacyTypeToTransport.get(type, NOT_FOUND);
        if (transport == NOT_FOUND) {
            throw new IllegalArgumentException("unknown legacy type: " + type);
        }
        nc.addTransportType(transport);

        // Map from type to capabilities.
        nc.addCapability(sLegacyTypeToCapability.get(
                type, NetworkCapabilities.NET_CAPABILITY_INTERNET));
        nc.maybeMarkCapabilitiesRestricted();
        return nc;
!!!7092229.java!!!	startNattKeepalive(inout network : Network, in intervalSeconds : int, inout callback : ConnectivityManager::PacketKeepaliveCallback, inout srcAddr : InetAddress, in srcPort : int, inout dstAddr : InetAddress) : ConnectivityManager::PacketKeepalive
        final PacketKeepalive k = new PacketKeepalive(network, callback);
        try {
            mService.startNattKeepalive(network, intervalSeconds, k.mMessenger, new Binder(),
                    srcAddr.getHostAddress(), srcPort, dstAddr.getHostAddress());
        } catch (RemoteException e) {
            Log.e(TAG, "Error starting packet keepalive: ", e);
            k.stopLooper();
            return null;
        }
        return k;
!!!7092357.java!!!	requestRouteToHost(in networkType : int, in hostAddress : int) : boolean
        return requestRouteToHostAddress(networkType, NetworkUtils.intToInetAddress(hostAddress));
!!!7092485.java!!!	requestRouteToHostAddress(in networkType : int, inout hostAddress : InetAddress) : boolean
        checkLegacyRoutingApiAccess();
        try {
            return mService.requestRouteToHostAddress(networkType, hostAddress.getAddress());
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7092613.java!!!	getBackgroundDataSetting() : boolean
        // assume that background data is allowed; final authority is
        // NetworkInfo which may be blocked.
        return true;
!!!7092741.java!!!	setBackgroundDataSetting(inout allowBackgroundData : boolean) : void
        // ignored
!!!7092869.java!!!	getActiveNetworkQuotaInfo() : NetworkQuotaInfo
        try {
            return mService.getActiveNetworkQuotaInfo();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7092997.java!!!	getMobileDataEnabled() : boolean
        IBinder b = ServiceManager.getService(Context.TELEPHONY_SERVICE);
        if (b != null) {
            try {
                ITelephony it = ITelephony.Stub.asInterface(b);
                int subId = SubscriptionManager.getDefaultDataSubscriptionId();
                Log.d("ConnectivityManager", "getMobileDataEnabled()+ subId=" + subId);
                boolean retVal = it.getDataEnabled(subId);
                Log.d("ConnectivityManager", "getMobileDataEnabled()- subId=" + subId
                        + " retVal=" + retVal);
                return retVal;
            } catch (RemoteException e) {
                throw e.rethrowFromSystemServer();
            }
        }
        Log.d("ConnectivityManager", "getMobileDataEnabled()- remote exception retVal=false");
        return false;
!!!7093253.java!!!	getNetworkManagementService() : INetworkManagementService
        synchronized (this) {
            if (mNMService != null) {
                return mNMService;
            }
            IBinder b = ServiceManager.getService(Context.NETWORKMANAGEMENT_SERVICE);
            mNMService = INetworkManagementService.Stub.asInterface(b);
            return mNMService;
        }
!!!7093381.java!!!	addDefaultNetworkActiveListener(in l : ConnectivityManager::OnNetworkActiveListener) : void
        INetworkActivityListener rl = new INetworkActivityListener.Stub() {
            @Override
            public void onNetworkActive() throws RemoteException {
                l.onNetworkActive();
            }
        };

        try {
            getNetworkManagementService().registerNetworkActivityListener(rl);
            mNetworkActivityListeners.put(l, rl);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7093509.java!!!	removeDefaultNetworkActiveListener(inout l : ConnectivityManager::OnNetworkActiveListener) : void
        INetworkActivityListener rl = mNetworkActivityListeners.get(l);
        if (rl == null) {
            throw new IllegalArgumentException("Listener not registered: " + l);
        }
        try {
            getNetworkManagementService().unregisterNetworkActivityListener(rl);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7093637.java!!!	isDefaultNetworkActive() : boolean
        try {
            return getNetworkManagementService().isNetworkActive();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7093765.java!!!	ConnectivityManager(inout context : Context, inout service : IConnectivityManager)
        mContext = checkNotNull(context, "missing context");
        mService = checkNotNull(service, "missing IConnectivityManager");
        sInstance = this;
!!!7093893.java!!!	from(inout context : Context) : ConnectivityManager
        return (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
!!!7094021.java!!!	checkChangePermission(inout context : Context) : boolean
        int uid = Binder.getCallingUid();
        return Settings.checkAndNoteChangeNetworkStateOperation(context, uid, Settings
                .getPackageNameForUid(context, uid), false /* throwException */);
!!!7094149.java!!!	enforceChangePermission(inout context : Context) : void
        int uid = Binder.getCallingUid();
        Settings.checkAndNoteChangeNetworkStateOperation(context, uid, Settings
                .getPackageNameForUid(context, uid), true /* throwException */);
!!!7094277.java!!!	enforceTetherChangePermission(inout context : Context) : void
        if (context.getResources().getStringArray(
                com.android.internal.R.array.config_mobile_hotspot_provision_app).length == 2) {
            // Have a provisioning app - must only let system apps (which check this app)
            // turn on tethering
            context.enforceCallingOrSelfPermission(
                    android.Manifest.permission.TETHER_PRIVILEGED, "ConnectivityService");
        } else {
            int uid = Binder.getCallingUid();
            Settings.checkAndNoteWriteSettingsOperation(context, uid, Settings
                    .getPackageNameForUid(context, uid), true /* throwException */);
        }
!!!7094405.java!!!	getInstanceOrNull() : ConnectivityManager
        return sInstance;
!!!7094533.java!!!	getInstance() : ConnectivityManager
        if (getInstanceOrNull() == null) {
            throw new IllegalStateException("No ConnectivityManager yet constructed");
        }
        return getInstanceOrNull();
!!!7094661.java!!!	getTetherableIfaces() : String
        try {
            return mService.getTetherableIfaces();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7094789.java!!!	getTetheredIfaces() : String
        try {
            return mService.getTetheredIfaces();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7094917.java!!!	getTetheringErroredIfaces() : String
        try {
            return mService.getTetheringErroredIfaces();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7095045.java!!!	getTetheredDhcpRanges() : String
        try {
            return mService.getTetheredDhcpRanges();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7095173.java!!!	tether(in iface : String) : int
        try {
            return mService.tether(iface);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7095301.java!!!	untether(in iface : String) : int
        try {
            return mService.untether(iface);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7095429.java!!!	isTetheringSupported() : boolean
        try {
            return mService.isTetheringSupported();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7095813.java!!!	startTethering(in type : int, inout showProvisioningUi : boolean, in callback : ConnectivityManager::OnStartTetheringCallback) : void
        startTethering(type, showProvisioningUi, callback, null);
!!!7095941.java!!!	startTethering(in type : int, inout showProvisioningUi : boolean, in callback : ConnectivityManager::OnStartTetheringCallback, inout handler : Handler) : void
        checkNotNull(callback, "OnStartTetheringCallback cannot be null.");

        ResultReceiver wrappedCallback = new ResultReceiver(handler) {
            @Override
            protected void onReceiveResult(int resultCode, Bundle resultData) {
                if (resultCode == TETHER_ERROR_NO_ERROR) {
                    callback.onTetheringStarted();
                } else {
                    callback.onTetheringFailed();
                }
            }
        };

        try {
            mService.startTethering(type, wrappedCallback, showProvisioningUi);
        } catch (RemoteException e) {
            Log.e(TAG, "Exception trying to start tethering.", e);
            wrappedCallback.send(TETHER_ERROR_SERVICE_UNAVAIL, null);
        }
!!!7096069.java!!!	stopTethering(in type : int) : void
        try {
            mService.stopTethering(type);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096197.java!!!	getTetherableUsbRegexs() : String
        try {
            return mService.getTetherableUsbRegexs();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096325.java!!!	getTetherableWifiRegexs() : String
        try {
            return mService.getTetherableWifiRegexs();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096453.java!!!	getTetherableBluetoothRegexs() : String
        try {
            return mService.getTetherableBluetoothRegexs();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096581.java!!!	setUsbTethering(inout enable : boolean) : int
        try {
            return mService.setUsbTethering(enable);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096709.java!!!	getLastTetherError(in iface : String) : int
        try {
            return mService.getLastTetherError(iface);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096837.java!!!	reportInetCondition(in networkType : int, in percentage : int) : void
        try {
            mService.reportInetCondition(networkType, percentage);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7096965.java!!!	reportBadNetwork(inout network : Network) : void
        try {
            // One of these will be ignored because it matches system's current state.
            // The other will trigger the necessary reevaluation.
            mService.reportNetworkConnectivity(network, true);
            mService.reportNetworkConnectivity(network, false);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097093.java!!!	reportNetworkConnectivity(inout network : Network, inout hasConnectivity : boolean) : void
        try {
            mService.reportNetworkConnectivity(network, hasConnectivity);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097221.java!!!	setGlobalProxy(inout p : ProxyInfo) : void
        try {
            mService.setGlobalProxy(p);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097349.java!!!	getGlobalProxy() : ProxyInfo
        try {
            return mService.getGlobalProxy();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097477.java!!!	getProxyForNetwork(inout network : Network) : ProxyInfo
        try {
            return mService.getProxyForNetwork(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097605.java!!!	getDefaultProxy() : ProxyInfo
        return getProxyForNetwork(getBoundNetworkForProcess());
!!!7097733.java!!!	isNetworkSupported(in networkType : int) : boolean
        try {
            return mService.isNetworkSupported(networkType);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097861.java!!!	isActiveNetworkMetered() : boolean
        try {
            return mService.isActiveNetworkMetered();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7097989.java!!!	updateLockdownVpn() : boolean
        try {
            return mService.updateLockdownVpn();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7098117.java!!!	checkMobileProvisioning(in suggestedTimeOutMs : int) : int
        int timeOutMs = -1;
        try {
            timeOutMs = mService.checkMobileProvisioning(suggestedTimeOutMs);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        return timeOutMs;
!!!7098245.java!!!	getMobileProvisioningUrl() : String
        try {
            return mService.getMobileProvisioningUrl();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7098373.java!!!	setProvisioningNotificationVisible(inout visible : boolean, in networkType : int, in action : String) : void
        try {
            mService.setProvisioningNotificationVisible(visible, networkType, action);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7098501.java!!!	setAirplaneMode(inout enable : boolean) : void
        try {
            mService.setAirplaneMode(enable);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7098629.java!!!	registerNetworkFactory(inout messenger : Messenger, in name : String) : void
        try {
            mService.registerNetworkFactory(messenger, name);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7098757.java!!!	unregisterNetworkFactory(inout messenger : Messenger) : void
        try {
            mService.unregisterNetworkFactory(messenger);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7098885.java!!!	registerNetworkAgent(inout messenger : Messenger, inout ni : NetworkInfo, inout lp : LinkProperties, inout nc : NetworkCapabilities, in score : int, inout misc : NetworkMisc) : int
        try {
            return mService.registerNetworkAgent(messenger, ni, lp, nc, score, misc);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7100165.java!!!	getCallbackName(in whichCallback : int) : String
        switch (whichCallback) {
            case CALLBACK_PRECHECK:     return "CALLBACK_PRECHECK";
            case CALLBACK_AVAILABLE:    return "CALLBACK_AVAILABLE";
            case CALLBACK_LOSING:       return "CALLBACK_LOSING";
            case CALLBACK_LOST:         return "CALLBACK_LOST";
            case CALLBACK_UNAVAIL:      return "CALLBACK_UNAVAIL";
            case CALLBACK_CAP_CHANGED:  return "CALLBACK_CAP_CHANGED";
            case CALLBACK_IP_CHANGED:   return "CALLBACK_IP_CHANGED";
            case CALLBACK_RELEASED:     return "CALLBACK_RELEASED";
            case CALLBACK_EXIT:         return "CALLBACK_EXIT";
            case EXPIRE_LEGACY_REQUEST: return "EXPIRE_LEGACY_REQUEST";
            case CALLBACK_SUSPENDED:    return "CALLBACK_SUSPENDED";
            case CALLBACK_RESUMED:      return "CALLBACK_RESUMED";
            default:
                return Integer.toString(whichCallback);
        }
!!!7100933.java!!!	getDefaultHandler() : ConnectivityManager::CallbackHandler
        synchronized (sCallbacks) {
            if (sCallbackHandler == null) {
                sCallbackHandler = new CallbackHandler(ConnectivityThread.getInstanceLooper());
            }
            return sCallbackHandler;
        }
!!!7101061.java!!!	sendRequestForNetwork(inout need : NetworkCapabilities, inout callback : ConnectivityManager::NetworkCallback, in timeoutMs : int, in action : int, in legacyType : int, inout handler : ConnectivityManager::CallbackHandler) : NetworkRequest
        if (callback == null) {
            throw new IllegalArgumentException("null NetworkCallback");
        }
        if (need == null && action != REQUEST) {
            throw new IllegalArgumentException("null NetworkCapabilities");
        }
        // TODO: throw an exception if callback.networkRequest is not null.
        // http://b/20701525
        final NetworkRequest request;
        try {
            synchronized(sCallbacks) {
                Messenger messenger = new Messenger(handler);
                Binder binder = new Binder();
                if (action == LISTEN) {
                    request = mService.listenForNetwork(need, messenger, binder);
                } else {
                    request = mService.requestNetwork(
                            need, messenger, timeoutMs, binder, legacyType);
                }
                if (request != null) {
                    sCallbacks.put(request, callback);
                }
                callback.networkRequest = request;
            }
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
        return request;
!!!7101189.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, in timeoutMs : int, in legacyType : int, inout handler : Handler) : void
        CallbackHandler cbHandler = new CallbackHandler(handler);
        NetworkCapabilities nc = request.networkCapabilities;
        sendRequestForNetwork(nc, networkCallback, timeoutMs, REQUEST, legacyType, cbHandler);
!!!7101317.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback) : void
        requestNetwork(request, networkCallback, getDefaultHandler());
!!!7101445.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, inout handler : Handler) : void
        int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
        CallbackHandler cbHandler = new CallbackHandler(handler);
        requestNetwork(request, networkCallback, 0, legacyType, cbHandler);
!!!7101573.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, in timeoutMs : int) : void
        if (timeoutMs <= 0) {
            throw new IllegalArgumentException("Non-positive timeoutMs: " + timeoutMs);
        }
        int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
        requestNetwork(request, networkCallback, timeoutMs, legacyType, getDefaultHandler());
!!!7101701.java!!!	requestNetwork(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, inout handler : Handler, in timeoutMs : int) : void
        if (timeoutMs <= 0) {
            throw new IllegalArgumentException("Non-positive timeoutMs");
        }
        int legacyType = inferLegacyTypeForNetworkCapabilities(request.networkCapabilities);
        CallbackHandler cbHandler = new CallbackHandler(handler);
        requestNetwork(request, networkCallback, timeoutMs, legacyType, cbHandler);
!!!7101829.java!!!	requestNetwork(inout request : NetworkRequest, inout operation : PendingIntent) : void
        checkPendingIntent(operation);
        try {
            mService.pendingRequestForNetwork(request.networkCapabilities, operation);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7101957.java!!!	releaseNetworkRequest(inout operation : PendingIntent) : void
        checkPendingIntent(operation);
        try {
            mService.releasePendingNetworkRequest(operation);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7102085.java!!!	checkPendingIntent(inout intent : PendingIntent) : void
        if (intent == null) {
            throw new IllegalArgumentException("PendingIntent cannot be null.");
        }
!!!7102213.java!!!	registerNetworkCallback(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback) : void
        registerNetworkCallback(request, networkCallback, getDefaultHandler());
!!!7102341.java!!!	registerNetworkCallback(inout request : NetworkRequest, inout networkCallback : ConnectivityManager::NetworkCallback, inout handler : Handler) : void
        CallbackHandler cbHandler = new CallbackHandler(handler);
        NetworkCapabilities nc = request.networkCapabilities;
        sendRequestForNetwork(nc, networkCallback, 0, LISTEN, TYPE_NONE, cbHandler);
!!!7102469.java!!!	registerNetworkCallback(inout request : NetworkRequest, inout operation : PendingIntent) : void
        checkPendingIntent(operation);
        try {
            mService.pendingListenForNetwork(request.networkCapabilities, operation);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7102597.java!!!	registerDefaultNetworkCallback(inout networkCallback : ConnectivityManager::NetworkCallback) : void
        registerDefaultNetworkCallback(networkCallback, getDefaultHandler());
!!!7102725.java!!!	registerDefaultNetworkCallback(inout networkCallback : ConnectivityManager::NetworkCallback, inout handler : Handler) : void
        // This works because if the NetworkCapabilities are null,
        // ConnectivityService takes them from the default request.
        //
        // Since the capabilities are exactly the same as the default request's
        // capabilities, this request is guaranteed, at all times, to be
        // satisfied by the same network, if any, that satisfies the default
        // request, i.e., the system default network.
        CallbackHandler cbHandler = new CallbackHandler(handler);
        sendRequestForNetwork(null, networkCallback, 0, REQUEST, TYPE_NONE, cbHandler);
!!!7102853.java!!!	requestBandwidthUpdate(inout network : Network) : boolean
        try {
            return mService.requestBandwidthUpdate(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7102981.java!!!	unregisterNetworkCallback(inout networkCallback : ConnectivityManager::NetworkCallback) : void
        if (networkCallback == null || networkCallback.networkRequest == null ||
                networkCallback.networkRequest.requestId == REQUEST_ID_UNSET) {
            throw new IllegalArgumentException("Invalid NetworkCallback");
        }
        try {
            // CallbackHandler will release callback when receiving CALLBACK_RELEASED.
            mService.releaseNetworkRequest(networkCallback.networkRequest);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7103109.java!!!	unregisterNetworkCallback(inout operation : PendingIntent) : void
        releaseNetworkRequest(operation);
!!!7103237.java!!!	setAcceptUnvalidated(inout network : Network, inout accept : boolean, inout always : boolean) : void
        try {
            mService.setAcceptUnvalidated(network, accept, always);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7103365.java!!!	setAvoidUnvalidated(inout network : Network) : void
        try {
            mService.setAvoidUnvalidated(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7103493.java!!!	startCaptivePortalApp(inout network : Network) : void
        try {
            mService.startCaptivePortalApp(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7103621.java!!!	getMultipathPreference(inout network : Network) : int
        try {
            return mService.getMultipathPreference(network);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7103749.java!!!	factoryReset() : void
        try {
            mService.factoryReset();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7103877.java!!!	bindProcessToNetwork(inout network : Network) : boolean
        // Forcing callers to call thru non-static function ensures ConnectivityManager
        // instantiated.
        return setProcessDefaultNetwork(network);
!!!7104005.java!!!	setProcessDefaultNetwork(inout network : Network) : boolean
        int netId = (network == null) ? NETID_UNSET : network.netId;
        if (netId == NetworkUtils.getBoundNetworkForProcess()) {
            return true;
        }
        if (NetworkUtils.bindProcessToNetwork(netId)) {
            // Set HTTP proxy system properties to match network.
            // TODO: Deprecate this static method and replace it with a non-static version.
            try {
                Proxy.setHttpProxySystemProperty(getInstance().getDefaultProxy());
            } catch (SecurityException e) {
                // The process doesn't have ACCESS_NETWORK_STATE, so we can't fetch the proxy.
                Log.e(TAG, "Can't set proxy properties", e);
            }
            // Must flush DNS cache as new network may have different DNS resolutions.
            InetAddress.clearDnsCache();
            // Must flush socket pool as idle sockets will be bound to previous network and may
            // cause subsequent fetches to be performed on old network.
            NetworkEventDispatcher.getInstance().onNetworkConfigurationChanged();
            return true;
        } else {
            return false;
        }
!!!7104133.java!!!	getBoundNetworkForProcess() : Network
        // Forcing callers to call thru non-static function ensures ConnectivityManager
        // instantiated.
        return getProcessDefaultNetwork();
!!!7104261.java!!!	getProcessDefaultNetwork() : Network
        int netId = NetworkUtils.getBoundNetworkForProcess();
        if (netId == NETID_UNSET) return null;
        return new Network(netId);
!!!7104389.java!!!	unsupportedStartingFrom(in version : int) : void
        if (Process.myUid() == Process.SYSTEM_UID) {
            // The getApplicationInfo() call we make below is not supported in system context, and
            // we want to allow the system to use these APIs anyway.
            return;
        }

        if (mContext.getApplicationInfo().targetSdkVersion >= version) {
            throw new UnsupportedOperationException(
                    "This method is not supported in target SDK version " + version + " and above");
        }
!!!7104517.java!!!	checkLegacyRoutingApiAccess() : void
        if (mContext.checkCallingOrSelfPermission("com.android.permission.INJECT_OMADM_SETTINGS")
                == PackageManager.PERMISSION_GRANTED) {
            return;
        }

        unsupportedStartingFrom(VERSION_CODES.M);
!!!7104645.java!!!	setProcessDefaultNetworkForHostResolution(inout network : Network) : boolean
        return NetworkUtils.bindProcessToNetworkForHostResolution(
                network == null ? NETID_UNSET : network.netId);
!!!7104773.java!!!	getNetworkPolicyManager() : INetworkPolicyManager
        synchronized (this) {
            if (mNPManager != null) {
                return mNPManager;
            }
            mNPManager = INetworkPolicyManager.Stub.asInterface(ServiceManager
                    .getService(Context.NETWORK_POLICY_SERVICE));
            return mNPManager;
        }
!!!7104901.java!!!	getRestrictBackgroundStatus() : int
        try {
            return getNetworkPolicyManager().getRestrictBackgroundByCaller();
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!7105029.java!!!	whatToString(in what : int) : String
        return NoPreloadHolder.sMagicDecoderRing.get(what, Integer.toString(what));
