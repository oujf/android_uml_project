class LayoutManager
!!!10339845.java!!!	setRecyclerView(inout recyclerView : RecyclerView) : void
            if (recyclerView == null) {
                mRecyclerView = null;
                mChildHelper = null;
                mWidth = 0;
                mHeight = 0;
            } else {
                mRecyclerView = recyclerView;
                mChildHelper = recyclerView.mChildHelper;
                mWidth = recyclerView.getWidth();
                mHeight = recyclerView.getHeight();
            }
            mWidthMode = MeasureSpec.EXACTLY;
            mHeightMode = MeasureSpec.EXACTLY;
!!!10339973.java!!!	setMeasureSpecs(in wSpec : int, in hSpec : int) : void
            mWidth = MeasureSpec.getSize(wSpec);
            mWidthMode = MeasureSpec.getMode(wSpec);
            if (mWidthMode == MeasureSpec.UNSPECIFIED && !ALLOW_SIZE_IN_UNSPECIFIED_SPEC) {
                mWidth = 0;
            }

            mHeight = MeasureSpec.getSize(hSpec);
            mHeightMode = MeasureSpec.getMode(hSpec);
            if (mHeightMode == MeasureSpec.UNSPECIFIED && !ALLOW_SIZE_IN_UNSPECIFIED_SPEC) {
                mHeight = 0;
            }
!!!10340101.java!!!	setMeasuredDimensionFromChildren(in widthSpec : int, in heightSpec : int) : void
            final int count = getChildCount();
            if (count == 0) {
                mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
                return;
            }
            int minX = Integer.MAX_VALUE;
            int minY = Integer.MAX_VALUE;
            int maxX = Integer.MIN_VALUE;
            int maxY = Integer.MIN_VALUE;

            for (int i = 0; i < count; i++) {
                View child = getChildAt(i);
                final Rect bounds = mRecyclerView.mTempRect;
                getDecoratedBoundsWithMargins(child, bounds);
                if (bounds.left < minX) {
                    minX = bounds.left;
                }
                if (bounds.right > maxX) {
                    maxX = bounds.right;
                }
                if (bounds.top < minY) {
                    minY = bounds.top;
                }
                if (bounds.bottom > maxY) {
                    maxY = bounds.bottom;
                }
            }
            mRecyclerView.mTempRect.set(minX, minY, maxX, maxY);
            setMeasuredDimension(mRecyclerView.mTempRect, widthSpec, heightSpec);
!!!10340229.java!!!	setMeasuredDimension(inout childrenBounds : Rect, in wSpec : int, in hSpec : int) : void
            int usedWidth = childrenBounds.width() + getPaddingLeft() + getPaddingRight();
            int usedHeight = childrenBounds.height() + getPaddingTop() + getPaddingBottom();
            int width = chooseSize(wSpec, usedWidth, getMinimumWidth());
            int height = chooseSize(hSpec, usedHeight, getMinimumHeight());
            setMeasuredDimension(width, height);
!!!10340357.java!!!	requestLayout() : void
            if (mRecyclerView != null) {
                mRecyclerView.requestLayout();
            }
!!!10340485.java!!!	assertInLayoutOrScroll(in message : String) : void
            if (mRecyclerView != null) {
                mRecyclerView.assertInLayoutOrScroll(message);
            }
!!!10340613.java!!!	chooseSize(in spec : int, in desired : int, in min : int) : int
            final int mode = View.MeasureSpec.getMode(spec);
            final int size = View.MeasureSpec.getSize(spec);
            switch (mode) {
                case View.MeasureSpec.EXACTLY:
                    return size;
                case View.MeasureSpec.AT_MOST:
                    return Math.min(size, Math.max(desired, min));
                case View.MeasureSpec.UNSPECIFIED:
                default:
                    return Math.max(desired, min);
            }
!!!10340741.java!!!	assertNotInLayoutOrScroll(in message : String) : void
            if (mRecyclerView != null) {
                mRecyclerView.assertNotInLayoutOrScroll(message);
            }
!!!10340869.java!!!	setAutoMeasureEnabled(inout enabled : boolean) : void
            mAutoMeasure = enabled;
!!!10340997.java!!!	isAutoMeasureEnabled() : boolean
            return mAutoMeasure;
!!!10341125.java!!!	supportsPredictiveItemAnimations() : boolean
            return false;
!!!10341253.java!!!	setItemPrefetchEnabled(inout enabled : boolean) : void
            if (enabled != mItemPrefetchEnabled) {
                mItemPrefetchEnabled = enabled;
                mPrefetchMaxCountObserved = 0;
                if (mRecyclerView != null) {
                    mRecyclerView.mRecycler.updateViewCacheSize();
                }
            }
!!!10341381.java!!!	isItemPrefetchEnabled() : boolean
            return mItemPrefetchEnabled;
!!!10341765.java!!!	dispatchAttachedToWindow(inout view : RecyclerView) : void
            mIsAttachedToWindow = true;
            onAttachedToWindow(view);
!!!10341893.java!!!	dispatchDetachedFromWindow(inout view : RecyclerView, inout recycler : RecyclerView::Recycler) : void
            mIsAttachedToWindow = false;
            onDetachedFromWindow(view, recycler);
!!!10342021.java!!!	isAttachedToWindow() : boolean
            return mIsAttachedToWindow;
!!!10342149.java!!!	postOnAnimation(inout action : Runnable) : void
            if (mRecyclerView != null) {
                mRecyclerView.postOnAnimation(action);
            }
!!!10342277.java!!!	removeCallbacks(inout action : Runnable) : boolean
            if (mRecyclerView != null) {
                return mRecyclerView.removeCallbacks(action);
            }
            return false;
!!!10342533.java!!!	onDetachedFromWindow(inout view : RecyclerView) : void

!!!10342661.java!!!	onDetachedFromWindow(inout view : RecyclerView, inout recycler : RecyclerView::Recycler) : void
            onDetachedFromWindow(view);
!!!10342789.java!!!	getClipToPadding() : boolean
            return mRecyclerView != null && mRecyclerView.mClipToPadding;
!!!10342917.java!!!	onLayoutChildren(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : void
            Log.e(TAG, "You must override onLayoutChildren(Recycler recycler, State state) ");
!!!10343301.java!!!	checkLayoutParams(inout lp : ViewGroup::LayoutParams) : boolean
            return lp != null;
!!!10343429.java!!!	generateLayoutParams(inout lp : ViewGroup::LayoutParams) : ViewGroup::LayoutParams
            if (lp instanceof LayoutParams) {
                return new LayoutParams((LayoutParams) lp);
            } else if (lp instanceof MarginLayoutParams) {
                return new LayoutParams((MarginLayoutParams) lp);
            } else {
                return new LayoutParams(lp);
            }
!!!10343557.java!!!	generateLayoutParams(inout c : Context, inout attrs : AttributeSet) : ViewGroup::LayoutParams
            return new LayoutParams(c, attrs);
!!!10343685.java!!!	scrollHorizontallyBy(in dx : int, inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            return 0;
!!!10343813.java!!!	scrollVerticallyBy(in dy : int, inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            return 0;
!!!10343941.java!!!	canScrollHorizontally() : boolean
            return false;
!!!10344069.java!!!	canScrollVertically() : boolean
            return false;
!!!10344197.java!!!	scrollToPosition(in position : int) : void
            if (DEBUG) {
                Log.e(TAG, "You MUST implement scrollToPosition. It will soon become abstract");
            }
!!!10344325.java!!!	smoothScrollToPosition(inout recyclerView : RecyclerView, inout state : RecyclerView::State, in position : int) : void
            Log.e(TAG, "You must override smoothScrollToPosition to support smooth scrolling");
!!!10344453.java!!!	startSmoothScroll(inout smoothScroller : RecyclerView::SmoothScroller) : void
            if (mSmoothScroller != null && smoothScroller != mSmoothScroller
                    && mSmoothScroller.isRunning()) {
                mSmoothScroller.stop();
            }
            mSmoothScroller = smoothScroller;
            mSmoothScroller.start(mRecyclerView, this);
!!!10344581.java!!!	isSmoothScrolling() : boolean
            return mSmoothScroller != null && mSmoothScroller.isRunning();
!!!10344709.java!!!	getLayoutDirection() : int
            return mRecyclerView.getLayoutDirection();
!!!10344837.java!!!	endAnimation(inout view : View) : void
            if (mRecyclerView.mItemAnimator != null) {
                mRecyclerView.mItemAnimator.endAnimation(getChildViewHolderInt(view));
            }
!!!10344965.java!!!	addDisappearingView(inout child : View) : void
            addDisappearingView(child, -1);
!!!10345093.java!!!	addDisappearingView(inout child : View, in index : int) : void
            addViewInt(child, index, true);
!!!10345221.java!!!	addView(inout child : View) : void
            addView(child, -1);
!!!10345349.java!!!	addView(inout child : View, in index : int) : void
            addViewInt(child, index, false);
!!!10345477.java!!!	addViewInt(inout child : View, in index : int, inout disappearing : boolean) : void
            final ViewHolder holder = getChildViewHolderInt(child);
            if (disappearing || holder.isRemoved()) {
                // these views will be hidden at the end of the layout pass.
                mRecyclerView.mViewInfoStore.addToDisappearedInLayout(holder);
            } else {
                // This may look like unnecessary but may happen if layout manager supports
                // predictive layouts and adapter removed then re-added the same item.
                // In this case, added version will be visible in the post layout (because add is
                // deferred) but RV will still bind it to the same View.
                // So if a View re-appears in post layout pass, remove it from disappearing list.
                mRecyclerView.mViewInfoStore.removeFromDisappearedInLayout(holder);
            }
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            if (holder.wasReturnedFromScrap() || holder.isScrap()) {
                if (holder.isScrap()) {
                    holder.unScrap();
                } else {
                    holder.clearReturnedFromScrapFlag();
                }
                mChildHelper.attachViewToParent(child, index, child.getLayoutParams(), false);
                if (DISPATCH_TEMP_DETACH) {
                    child.dispatchFinishTemporaryDetach();
                }
            } else if (child.getParent() == mRecyclerView) { // it was not a scrap but a valid child
                // ensure in correct position
                int currentIndex = mChildHelper.indexOfChild(child);
                if (index == -1) {
                    index = mChildHelper.getChildCount();
                }
                if (currentIndex == -1) {
                    throw new IllegalStateException("Added View has RecyclerView as parent but"
                            + " view is not a real child. Unfiltered index:"
                            + mRecyclerView.indexOfChild(child));
                }
                if (currentIndex != index) {
                    mRecyclerView.mLayout.moveView(currentIndex, index);
                }
            } else {
                mChildHelper.addView(child, index, false);
                lp.mInsetsDirty = true;
                if (mSmoothScroller != null && mSmoothScroller.isRunning()) {
                    mSmoothScroller.onChildAttachedToWindow(child);
                }
            }
            if (lp.mPendingInvalidate) {
                if (DEBUG) {
                    Log.d(TAG, "consuming pending invalidate on child " + lp.mViewHolder);
                }
                holder.itemView.invalidate();
                lp.mPendingInvalidate = false;
            }
!!!10345605.java!!!	removeView(inout child : View) : void
            mChildHelper.removeView(child);
!!!10345733.java!!!	removeViewAt(in index : int) : void
            final View child = getChildAt(index);
            if (child != null) {
                mChildHelper.removeViewAt(index);
            }
!!!10345861.java!!!	removeAllViews() : void
            // Only remove non-animating views
            final int childCount = getChildCount();
            for (int i = childCount - 1; i >= 0; i--) {
                mChildHelper.removeViewAt(i);
            }
!!!10345989.java!!!	getBaseline() : int
            return -1;
!!!10346117.java!!!	getPosition(inout view : View) : int
            return ((RecyclerView.LayoutParams) view.getLayoutParams()).getViewLayoutPosition();
!!!10346245.java!!!	getItemViewType(inout view : View) : int
            return getChildViewHolderInt(view).getItemViewType();
!!!10346373.java!!!	findContainingItemView(inout view : View) : View
            if (mRecyclerView == null) {
                return null;
            }
            View found = mRecyclerView.findContainingItemView(view);
            if (found == null) {
                return null;
            }
            if (mChildHelper.isHidden(found)) {
                return null;
            }
            return found;
!!!10346501.java!!!	findViewByPosition(in position : int) : View
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                View child = getChildAt(i);
                ViewHolder vh = getChildViewHolderInt(child);
                if (vh == null) {
                    continue;
                }
                if (vh.getLayoutPosition() == position && !vh.shouldIgnore()
                        && (mRecyclerView.mState.isPreLayout() || !vh.isRemoved())) {
                    return child;
                }
            }
            return null;
!!!10346629.java!!!	detachView(inout child : View) : void
            final int ind = mChildHelper.indexOfChild(child);
            if (ind >= 0) {
                detachViewInternal(ind, child);
            }
!!!10346757.java!!!	detachViewAt(in index : int) : void
            detachViewInternal(index, getChildAt(index));
!!!10346885.java!!!	detachViewInternal(in index : int, inout view : View) : void
            if (DISPATCH_TEMP_DETACH) {
                view.dispatchStartTemporaryDetach();
            }
            mChildHelper.detachViewFromParent(index);
!!!10347013.java!!!	attachView(inout child : View, in index : int, inout lp : ViewGroup::LayoutParams) : void
            ViewHolder vh = getChildViewHolderInt(child);
            if (vh.isRemoved()) {
                mRecyclerView.mViewInfoStore.addToDisappearedInLayout(vh);
            } else {
                mRecyclerView.mViewInfoStore.removeFromDisappearedInLayout(vh);
            }
            mChildHelper.attachViewToParent(child, index, lp, vh.isRemoved());
            if (DISPATCH_TEMP_DETACH)  {
                child.dispatchFinishTemporaryDetach();
            }
!!!10347141.java!!!	attachView(inout child : View, in index : int) : void
            attachView(child, index, (LayoutParams) child.getLayoutParams());
!!!10347269.java!!!	attachView(inout child : View) : void
            attachView(child, -1);
!!!10347397.java!!!	removeDetachedView(inout child : View) : void
            mRecyclerView.removeDetachedView(child, false);
!!!10347525.java!!!	moveView(in fromIndex : int, in toIndex : int) : void
            View view = getChildAt(fromIndex);
            if (view == null) {
                throw new IllegalArgumentException("Cannot move a child from non-existing index:"
                        + fromIndex);
            }
            detachViewAt(fromIndex);
            attachView(view, toIndex);
!!!10347653.java!!!	detachAndScrapView(inout child : View, inout recycler : RecyclerView::Recycler) : void
            int index = mChildHelper.indexOfChild(child);
            scrapOrRecycleView(recycler, index, child);
!!!10347781.java!!!	detachAndScrapViewAt(in index : int, inout recycler : RecyclerView::Recycler) : void
            final View child = getChildAt(index);
            scrapOrRecycleView(recycler, index, child);
!!!10347909.java!!!	removeAndRecycleView(inout child : View, inout recycler : RecyclerView::Recycler) : void
            removeView(child);
            recycler.recycleView(child);
!!!10348037.java!!!	removeAndRecycleViewAt(in index : int, inout recycler : RecyclerView::Recycler) : void
            final View view = getChildAt(index);
            removeViewAt(index);
            recycler.recycleView(view);
!!!10348165.java!!!	getChildCount() : int
            return mChildHelper != null ? mChildHelper.getChildCount() : 0;
!!!10348293.java!!!	getChildAt(in index : int) : View
            return mChildHelper != null ? mChildHelper.getChildAt(index) : null;
!!!10348421.java!!!	getWidthMode() : int
            return mWidthMode;
!!!10348549.java!!!	getHeightMode() : int
            return mHeightMode;
!!!10348677.java!!!	getWidth() : int
            return mWidth;
!!!10348805.java!!!	getHeight() : int
            return mHeight;
!!!10348933.java!!!	getPaddingLeft() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingLeft() : 0;
!!!10349061.java!!!	getPaddingTop() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingTop() : 0;
!!!10349189.java!!!	getPaddingRight() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingRight() : 0;
!!!10349317.java!!!	getPaddingBottom() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingBottom() : 0;
!!!10349445.java!!!	getPaddingStart() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingStart() : 0;
!!!10349573.java!!!	getPaddingEnd() : int
            return mRecyclerView != null ? mRecyclerView.getPaddingEnd() : 0;
!!!10349701.java!!!	isFocused() : boolean
            return mRecyclerView != null && mRecyclerView.isFocused();
!!!10349829.java!!!	hasFocus() : boolean
            return mRecyclerView != null && mRecyclerView.hasFocus();
!!!10349957.java!!!	getFocusedChild() : View
            if (mRecyclerView == null) {
                return null;
            }
            final View focused = mRecyclerView.getFocusedChild();
            if (focused == null || mChildHelper.isHidden(focused)) {
                return null;
            }
            return focused;
!!!10350085.java!!!	getItemCount() : int
            final Adapter a = mRecyclerView != null ? mRecyclerView.getAdapter() : null;
            return a != null ? a.getItemCount() : 0;
!!!10350213.java!!!	offsetChildrenHorizontal(in dx : int) : void
            if (mRecyclerView != null) {
                mRecyclerView.offsetChildrenHorizontal(dx);
            }
!!!10350341.java!!!	offsetChildrenVertical(in dy : int) : void
            if (mRecyclerView != null) {
                mRecyclerView.offsetChildrenVertical(dy);
            }
!!!10350469.java!!!	ignoreView(inout view : View) : void
            if (view.getParent() != mRecyclerView || mRecyclerView.indexOfChild(view) == -1) {
                // checking this because calling this method on a recycled or detached view may
                // cause loss of state.
                throw new IllegalArgumentException("View should be fully attached to be ignored");
            }
            final ViewHolder vh = getChildViewHolderInt(view);
            vh.addFlags(ViewHolder.FLAG_IGNORE);
            mRecyclerView.mViewInfoStore.removeViewHolder(vh);
!!!10350597.java!!!	stopIgnoringView(inout view : View) : void
            final ViewHolder vh = getChildViewHolderInt(view);
            vh.stopIgnoring();
            vh.resetInternal();
            vh.addFlags(ViewHolder.FLAG_INVALID);
!!!10350725.java!!!	detachAndScrapAttachedViews(inout recycler : RecyclerView::Recycler) : void
            final int childCount = getChildCount();
            for (int i = childCount - 1; i >= 0; i--) {
                final View v = getChildAt(i);
                scrapOrRecycleView(recycler, i, v);
            }
!!!10350853.java!!!	scrapOrRecycleView(inout recycler : RecyclerView::Recycler, in index : int, inout view : View) : void
            final ViewHolder viewHolder = getChildViewHolderInt(view);
            if (viewHolder.shouldIgnore()) {
                if (DEBUG) {
                    Log.d(TAG, "ignoring view " + viewHolder);
                }
                return;
            }
            if (viewHolder.isInvalid() && !viewHolder.isRemoved()
                    && !mRecyclerView.mAdapter.hasStableIds()) {
                removeViewAt(index);
                recycler.recycleViewHolderInternal(viewHolder);
            } else {
                detachViewAt(index);
                recycler.scrapView(view);
                mRecyclerView.mViewInfoStore.onViewDetached(viewHolder);
            }
!!!10350981.java!!!	removeAndRecycleScrapInt(inout recycler : RecyclerView::Recycler) : void
            final int scrapCount = recycler.getScrapCount();
            // Loop backward, recycler might be changed by removeDetachedView()
            for (int i = scrapCount - 1; i >= 0; i--) {
                final View scrap = recycler.getScrapViewAt(i);
                final ViewHolder vh = getChildViewHolderInt(scrap);
                if (vh.shouldIgnore()) {
                    continue;
                }
                // If the scrap view is animating, we need to cancel them first. If we cancel it
                // here, ItemAnimator callback may recycle it which will cause double recycling.
                // To avoid this, we mark it as not recycleable before calling the item animator.
                // Since removeDetachedView calls a user API, a common mistake (ending animations on
                // the view) may recycle it too, so we guard it before we call user APIs.
                vh.setIsRecyclable(false);
                if (vh.isTmpDetached()) {
                    mRecyclerView.removeDetachedView(scrap, false);
                }
                if (mRecyclerView.mItemAnimator != null) {
                    mRecyclerView.mItemAnimator.endAnimation(vh);
                }
                vh.setIsRecyclable(true);
                recycler.quickRecycleScrapView(scrap);
            }
            recycler.clearScrap();
            if (scrapCount > 0) {
                mRecyclerView.invalidate();
            }
!!!10351109.java!!!	measureChild(inout child : View, in widthUsed : int, in heightUsed : int) : void
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;
            final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight() + widthUsed, lp.width,
                    canScrollHorizontally());
            final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom() + heightUsed, lp.height,
                    canScrollVertically());
            if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {
                child.measure(widthSpec, heightSpec);
            }
!!!10351237.java!!!	shouldReMeasureChild(inout child : View, in widthSpec : int, in heightSpec : int, inout lp : ViewGroup::LayoutParams) : boolean
            return !mMeasurementCacheEnabled
                    || !isMeasurementUpToDate(child.getMeasuredWidth(), widthSpec, lp.width)
                    || !isMeasurementUpToDate(child.getMeasuredHeight(), heightSpec, lp.height);
!!!10351365.java!!!	shouldMeasureChild(inout child : View, in widthSpec : int, in heightSpec : int, inout lp : ViewGroup::LayoutParams) : boolean
            return child.isLayoutRequested()
                    || !mMeasurementCacheEnabled
                    || !isMeasurementUpToDate(child.getWidth(), widthSpec, lp.width)
                    || !isMeasurementUpToDate(child.getHeight(), heightSpec, lp.height);
!!!10351493.java!!!	isMeasurementCacheEnabled() : boolean
            return mMeasurementCacheEnabled;
!!!10351621.java!!!	setMeasurementCacheEnabled(inout measurementCacheEnabled : boolean) : void
            mMeasurementCacheEnabled = measurementCacheEnabled;
!!!10351749.java!!!	isMeasurementUpToDate(in childSize : int, in spec : int, in dimension : int) : boolean
            final int specMode = MeasureSpec.getMode(spec);
            final int specSize = MeasureSpec.getSize(spec);
            if (dimension > 0 && childSize != dimension) {
                return false;
            }
            switch (specMode) {
                case MeasureSpec.UNSPECIFIED:
                    return true;
                case MeasureSpec.AT_MOST:
                    return specSize >= childSize;
                case MeasureSpec.EXACTLY:
                    return  specSize == childSize;
            }
            return false;
!!!10351877.java!!!	measureChildWithMargins(inout child : View, in widthUsed : int, in heightUsed : int) : void
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();

            final Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            widthUsed += insets.left + insets.right;
            heightUsed += insets.top + insets.bottom;

            final int widthSpec = getChildMeasureSpec(getWidth(), getWidthMode(),
                    getPaddingLeft() + getPaddingRight()
                            + lp.leftMargin + lp.rightMargin + widthUsed, lp.width,
                    canScrollHorizontally());
            final int heightSpec = getChildMeasureSpec(getHeight(), getHeightMode(),
                    getPaddingTop() + getPaddingBottom()
                            + lp.topMargin + lp.bottomMargin + heightUsed, lp.height,
                    canScrollVertically());
            if (shouldMeasureChild(child, widthSpec, heightSpec, lp)) {
                child.measure(widthSpec, heightSpec);
            }
!!!10352005.java!!!	getChildMeasureSpec(in parentSize : int, in padding : int, in childDimension : int, inout canScroll : boolean) : int
            int size = Math.max(0, parentSize - padding);
            int resultSize = 0;
            int resultMode = 0;
            if (canScroll) {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else {
                    // MATCH_PARENT can't be applied since we can scroll in this dimension, wrap
                    // instead using UNSPECIFIED.
                    resultSize = 0;
                    resultMode = MeasureSpec.UNSPECIFIED;
                }
            } else {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.MATCH_PARENT) {
                    resultSize = size;
                    // TODO this should be my spec.
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                    resultSize = size;
                    resultMode = MeasureSpec.AT_MOST;
                }
            }
            return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
!!!10352133.java!!!	getChildMeasureSpec(in parentSize : int, in parentMode : int, in padding : int, in childDimension : int, inout canScroll : boolean) : int
            int size = Math.max(0, parentSize - padding);
            int resultSize = 0;
            int resultMode = 0;
            if (canScroll) {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.MATCH_PARENT) {
                    switch (parentMode) {
                        case MeasureSpec.AT_MOST:
                        case MeasureSpec.EXACTLY:
                            resultSize = size;
                            resultMode = parentMode;
                            break;
                        case MeasureSpec.UNSPECIFIED:
                            resultSize = 0;
                            resultMode = MeasureSpec.UNSPECIFIED;
                            break;
                    }
                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                    resultSize = 0;
                    resultMode = MeasureSpec.UNSPECIFIED;
                }
            } else {
                if (childDimension >= 0) {
                    resultSize = childDimension;
                    resultMode = MeasureSpec.EXACTLY;
                } else if (childDimension == LayoutParams.MATCH_PARENT) {
                    resultSize = size;
                    resultMode = parentMode;
                } else if (childDimension == LayoutParams.WRAP_CONTENT) {
                    resultSize = size;
                    if (parentMode == MeasureSpec.AT_MOST || parentMode == MeasureSpec.EXACTLY) {
                        resultMode = MeasureSpec.AT_MOST;
                    } else {
                        resultMode = MeasureSpec.UNSPECIFIED;
                    }

                }
            }
            //noinspection WrongConstant
            return MeasureSpec.makeMeasureSpec(resultSize, resultMode);
!!!10352261.java!!!	getDecoratedMeasuredWidth(inout child : View) : int
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            return child.getMeasuredWidth() + insets.left + insets.right;
!!!10352389.java!!!	getDecoratedMeasuredHeight(inout child : View) : int
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            return child.getMeasuredHeight() + insets.top + insets.bottom;
!!!10352517.java!!!	layoutDecorated(inout child : View, in left : int, in top : int, in right : int, in bottom : int) : void
            final Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
            child.layout(left + insets.left, top + insets.top, right - insets.right,
                    bottom - insets.bottom);
!!!10352645.java!!!	layoutDecoratedWithMargins(inout child : View, in left : int, in top : int, in right : int, in bottom : int) : void
            final LayoutParams lp = (LayoutParams) child.getLayoutParams();
            final Rect insets = lp.mDecorInsets;
            child.layout(left + insets.left + lp.leftMargin, top + insets.top + lp.topMargin,
                    right - insets.right - lp.rightMargin,
                    bottom - insets.bottom - lp.bottomMargin);
!!!10352773.java!!!	getTransformedBoundingBox(inout child : View, inout includeDecorInsets : boolean, inout out : Rect) : void
            if (includeDecorInsets) {
                Rect insets = ((LayoutParams) child.getLayoutParams()).mDecorInsets;
                out.set(-insets.left, -insets.top,
                        child.getWidth() + insets.right, child.getHeight() + insets.bottom);
            } else {
                out.set(0, 0, child.getWidth(), child.getHeight());
            }

            if (mRecyclerView != null) {
                final Matrix childMatrix = child.getMatrix();
                if (childMatrix != null && !childMatrix.isIdentity()) {
                    final RectF tempRectF = mRecyclerView.mTempRectF;
                    tempRectF.set(out);
                    childMatrix.mapRect(tempRectF);
                    out.set(
                            (int) Math.floor(tempRectF.left),
                            (int) Math.floor(tempRectF.top),
                            (int) Math.ceil(tempRectF.right),
                            (int) Math.ceil(tempRectF.bottom)
                    );
                }
            }
            out.offset(child.getLeft(), child.getTop());
!!!10352901.java!!!	getDecoratedBoundsWithMargins(inout view : View, inout outBounds : Rect) : void
            RecyclerView.getDecoratedBoundsWithMarginsInt(view, outBounds);
!!!10353029.java!!!	getDecoratedLeft(inout child : View) : int
            return child.getLeft() - getLeftDecorationWidth(child);
!!!10353157.java!!!	getDecoratedTop(inout child : View) : int
            return child.getTop() - getTopDecorationHeight(child);
!!!10353285.java!!!	getDecoratedRight(inout child : View) : int
            return child.getRight() + getRightDecorationWidth(child);
!!!10353413.java!!!	getDecoratedBottom(inout child : View) : int
            return child.getBottom() + getBottomDecorationHeight(child);
!!!10353541.java!!!	calculateItemDecorationsForChild(inout child : View, inout outRect : Rect) : void
            if (mRecyclerView == null) {
                outRect.set(0, 0, 0, 0);
                return;
            }
            Rect insets = mRecyclerView.getItemDecorInsetsForChild(child);
            outRect.set(insets);
!!!10353669.java!!!	getTopDecorationHeight(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.top;
!!!10353797.java!!!	getBottomDecorationHeight(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.bottom;
!!!10353925.java!!!	getLeftDecorationWidth(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.left;
!!!10354053.java!!!	getRightDecorationWidth(inout child : View) : int
            return ((LayoutParams) child.getLayoutParams()).mDecorInsets.right;
!!!10354181.java!!!	onFocusSearchFailed(inout focused : View, in direction : int, inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : View
            return null;
!!!10354309.java!!!	onInterceptFocusSearch(inout focused : View, in direction : int) : View
            return null;
!!!10354437.java!!!	requestChildRectangleOnScreen(inout parent : RecyclerView, inout child : View, inout rect : Rect, inout immediate : boolean) : boolean
            final int parentLeft = getPaddingLeft();
            final int parentTop = getPaddingTop();
            final int parentRight = getWidth() - getPaddingRight();
            final int parentBottom = getHeight() - getPaddingBottom();
            final int childLeft = child.getLeft() + rect.left - child.getScrollX();
            final int childTop = child.getTop() + rect.top - child.getScrollY();
            final int childRight = childLeft + rect.width();
            final int childBottom = childTop + rect.height();

            final int offScreenLeft = Math.min(0, childLeft - parentLeft);
            final int offScreenTop = Math.min(0, childTop - parentTop);
            final int offScreenRight = Math.max(0, childRight - parentRight);
            final int offScreenBottom = Math.max(0, childBottom - parentBottom);

            // Favor the "start" layout direction over the end when bringing one side or the other
            // of a large rect into view. If we decide to bring in end because start is already
            // visible, limit the scroll such that start won't go out of bounds.
            final int dx;
            if (getLayoutDirection() == View.LAYOUT_DIRECTION_RTL) {
                dx = offScreenRight != 0 ? offScreenRight
                        : Math.max(offScreenLeft, childRight - parentRight);
            } else {
                dx = offScreenLeft != 0 ? offScreenLeft
                        : Math.min(childLeft - parentLeft, offScreenRight);
            }

            // Favor bringing the top into view over the bottom. If top is already visible and
            // we should scroll to make bottom visible, make sure top does not go out of bounds.
            final int dy = offScreenTop != 0 ? offScreenTop
                    : Math.min(childTop - parentTop, offScreenBottom);

            if (dx != 0 || dy != 0) {
                if (immediate) {
                    parent.scrollBy(dx, dy);
                } else {
                    parent.smoothScrollBy(dx, dy);
                }
                return true;
            }
            return false;
!!!10354565.java!!!	onRequestChildFocus(inout parent : RecyclerView, inout child : View, inout focused : View) : boolean
            // eat the request if we are in the middle of a scroll or layout
            return isSmoothScrolling() || parent.isComputingLayout();
!!!10354693.java!!!	onRequestChildFocus(inout parent : RecyclerView, inout state : RecyclerView::State, inout child : View, inout focused : View) : boolean
            return onRequestChildFocus(parent, child, focused);
!!!10354949.java!!!	onAddFocusables(inout recyclerView : RecyclerView, inout views : ArrayList<View>, in direction : int, in focusableMode : int) : boolean
            return false;
!!!10355589.java!!!	onItemsUpdated(inout recyclerView : RecyclerView, in positionStart : int, in itemCount : int, inout payload : Object) : void
            onItemsUpdated(recyclerView, positionStart, itemCount);
!!!10355717.java!!!	onItemsMoved(inout recyclerView : RecyclerView, in from : int, in to : int, in itemCount : int) : void

!!!10355845.java!!!	computeHorizontalScrollExtent(inout state : RecyclerView::State) : int
            return 0;
!!!10355973.java!!!	computeHorizontalScrollOffset(inout state : RecyclerView::State) : int
            return 0;
!!!10356101.java!!!	computeHorizontalScrollRange(inout state : RecyclerView::State) : int
            return 0;
!!!10356229.java!!!	computeVerticalScrollExtent(inout state : RecyclerView::State) : int
            return 0;
!!!10356357.java!!!	computeVerticalScrollOffset(inout state : RecyclerView::State) : int
            return 0;
!!!10356485.java!!!	computeVerticalScrollRange(inout state : RecyclerView::State) : int
            return 0;
!!!10356613.java!!!	onMeasure(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, in widthSpec : int, in heightSpec : int) : void
            mRecyclerView.defaultOnMeasure(widthSpec, heightSpec);
!!!10356741.java!!!	setMeasuredDimension(in widthSize : int, in heightSize : int) : void
            mRecyclerView.setMeasuredDimension(widthSize, heightSize);
!!!10356869.java!!!	getMinimumWidth() : int
            return mRecyclerView.getMinimumWidth();
!!!10356997.java!!!	getMinimumHeight() : int
            return mRecyclerView.getMinimumHeight();
!!!10357125.java!!!	onSaveInstanceState() : Parcelable
            return null;
!!!10357253.java!!!	onRestoreInstanceState(inout state : Parcelable) : void

!!!10357381.java!!!	stopSmoothScroller() : void
            if (mSmoothScroller != null) {
                mSmoothScroller.stop();
            }
!!!10357509.java!!!	onSmoothScrollerStopped(inout smoothScroller : RecyclerView::SmoothScroller) : void
            if (mSmoothScroller == smoothScroller) {
                mSmoothScroller = null;
            }
!!!10357765.java!!!	removeAndRecycleAllViews(inout recycler : RecyclerView::Recycler) : void
            for (int i = getChildCount() - 1; i >= 0; i--) {
                final View view = getChildAt(i);
                if (!getChildViewHolderInt(view).shouldIgnore()) {
                    removeAndRecycleViewAt(i, recycler);
                }
            }
!!!10357893.java!!!	onInitializeAccessibilityNodeInfo(inout info : AccessibilityNodeInfo) : void
            onInitializeAccessibilityNodeInfo(mRecyclerView.mRecycler, mRecyclerView.mState, info);
!!!10358021.java!!!	onInitializeAccessibilityNodeInfo(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout info : AccessibilityNodeInfo) : void
            if (mRecyclerView.canScrollVertically(-1)
                    || mRecyclerView.canScrollHorizontally(-1)) {
                info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD);
                info.setScrollable(true);
            }
            if (mRecyclerView.canScrollVertically(1)
                    || mRecyclerView.canScrollHorizontally(1)) {
                info.addAction(AccessibilityNodeInfo.ACTION_SCROLL_FORWARD);
                info.setScrollable(true);
            }
            final AccessibilityNodeInfo.CollectionInfo collectionInfo =
                    AccessibilityNodeInfo.CollectionInfo
                            .obtain(getRowCountForAccessibility(recycler, state),
                                    getColumnCountForAccessibility(recycler, state),
                                    isLayoutHierarchical(recycler, state),
                                    getSelectionModeForAccessibility(recycler, state));
            info.setCollectionInfo(collectionInfo);
!!!10358149.java!!!	onInitializeAccessibilityEvent(inout event : AccessibilityEvent) : void
            onInitializeAccessibilityEvent(mRecyclerView.mRecycler, mRecyclerView.mState, event);
!!!10358277.java!!!	onInitializeAccessibilityEvent(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout event : AccessibilityEvent) : void
            if (mRecyclerView == null || event == null) {
                return;
            }
            event.setScrollable(mRecyclerView.canScrollVertically(1)
                    || mRecyclerView.canScrollVertically(-1)
                    || mRecyclerView.canScrollHorizontally(-1)
                    || mRecyclerView.canScrollHorizontally(1));

            if (mRecyclerView.mAdapter != null) {
                event.setItemCount(mRecyclerView.mAdapter.getItemCount());
            }
!!!10358405.java!!!	onInitializeAccessibilityNodeInfoForItem(inout host : View, inout info : AccessibilityNodeInfo) : void
            final ViewHolder vh = getChildViewHolderInt(host);
            // avoid trying to create accessibility node info for removed children
            if (vh != null && !vh.isRemoved() && !mChildHelper.isHidden(vh.itemView)) {
                onInitializeAccessibilityNodeInfoForItem(mRecyclerView.mRecycler,
                        mRecyclerView.mState, host, info);
            }
!!!10358533.java!!!	onInitializeAccessibilityNodeInfoForItem(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout host : View, inout info : AccessibilityNodeInfo) : void
            int rowIndexGuess = canScrollVertically() ? getPosition(host) : 0;
            int columnIndexGuess = canScrollHorizontally() ? getPosition(host) : 0;
            final AccessibilityNodeInfo.CollectionItemInfo itemInfo =
                    AccessibilityNodeInfo.CollectionItemInfo.obtain(rowIndexGuess, 1,
                            columnIndexGuess, 1, false, false);
            info.setCollectionItemInfo(itemInfo);
!!!10358661.java!!!	requestSimpleAnimationsInNextLayout() : void
            mRequestedSimpleAnimations = true;
!!!10358789.java!!!	getSelectionModeForAccessibility(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            return AccessibilityNodeInfo.CollectionInfo.SELECTION_MODE_NONE;
!!!10358917.java!!!	getRowCountForAccessibility(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            if (mRecyclerView == null || mRecyclerView.mAdapter == null) {
                return 1;
            }
            return canScrollVertically() ? mRecyclerView.mAdapter.getItemCount() : 1;
!!!10359045.java!!!	getColumnCountForAccessibility(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : int
            if (mRecyclerView == null || mRecyclerView.mAdapter == null) {
                return 1;
            }
            return canScrollHorizontally() ? mRecyclerView.mAdapter.getItemCount() : 1;
!!!10359173.java!!!	isLayoutHierarchical(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State) : boolean
            return false;
!!!10359301.java!!!	performAccessibilityAction(in action : int, inout args : Bundle) : boolean
            return performAccessibilityAction(mRecyclerView.mRecycler, mRecyclerView.mState,
                    action, args);
!!!10359429.java!!!	performAccessibilityAction(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, in action : int, inout args : Bundle) : boolean
            if (mRecyclerView == null) {
                return false;
            }
            int vScroll = 0, hScroll = 0;
            switch (action) {
                case AccessibilityNodeInfo.ACTION_SCROLL_BACKWARD:
                    if (mRecyclerView.canScrollVertically(-1)) {
                        vScroll = -(getHeight() - getPaddingTop() - getPaddingBottom());
                    }
                    if (mRecyclerView.canScrollHorizontally(-1)) {
                        hScroll = -(getWidth() - getPaddingLeft() - getPaddingRight());
                    }
                    break;
                case AccessibilityNodeInfo.ACTION_SCROLL_FORWARD:
                    if (mRecyclerView.canScrollVertically(1)) {
                        vScroll = getHeight() - getPaddingTop() - getPaddingBottom();
                    }
                    if (mRecyclerView.canScrollHorizontally(1)) {
                        hScroll = getWidth() - getPaddingLeft() - getPaddingRight();
                    }
                    break;
            }
            if (vScroll == 0 && hScroll == 0) {
                return false;
            }
            mRecyclerView.scrollBy(hScroll, vScroll);
            return true;
!!!10359557.java!!!	performAccessibilityActionForItem(inout view : View, in action : int, inout args : Bundle) : boolean
            return performAccessibilityActionForItem(mRecyclerView.mRecycler, mRecyclerView.mState,
                    view, action, args);
!!!10359685.java!!!	performAccessibilityActionForItem(inout recycler : RecyclerView::Recycler, inout state : RecyclerView::State, inout view : View, in action : int, inout args : Bundle) : boolean
            return false;
!!!10359813.java!!!	getProperties(inout context : Context, inout attrs : AttributeSet, in defStyleAttr : int, in defStyleRes : int) : RecyclerView::LayoutManager::Properties
            Properties properties = new Properties();
            TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.RecyclerView,
                    defStyleAttr, defStyleRes);
            properties.orientation = a.getInt(R.styleable.RecyclerView_orientation, VERTICAL);
            properties.spanCount = a.getInt(R.styleable.RecyclerView_spanCount, 1);
            properties.reverseLayout = a.getBoolean(R.styleable.RecyclerView_reverseLayout, false);
            properties.stackFromEnd = a.getBoolean(R.styleable.RecyclerView_stackFromEnd, false);
            a.recycle();
            return properties;
!!!10359941.java!!!	setExactMeasureSpecsFrom(inout recyclerView : RecyclerView) : void
            setMeasureSpecs(
                    MeasureSpec.makeMeasureSpec(recyclerView.getWidth(), MeasureSpec.EXACTLY),
                    MeasureSpec.makeMeasureSpec(recyclerView.getHeight(), MeasureSpec.EXACTLY)
            );
!!!10360069.java!!!	shouldMeasureTwice() : boolean
            return false;
!!!10360197.java!!!	hasFlexibleChildInBothOrientations() : boolean
            final int childCount = getChildCount();
            for (int i = 0; i < childCount; i++) {
                final View child = getChildAt(i);
                final ViewGroup.LayoutParams lp = child.getLayoutParams();
                if (lp.width < 0 && lp.height < 0) {
                    return true;
                }
            }
            return false;
