class Surface
!!!14307205.cpp!!!	Surface(in bufferProducer : sp<IGraphicBufferProducer>, in controlledByApp : bool = false)
    // Initialize the ANativeWindow function pointers.
    ANativeWindow::setSwapInterval  = hook_setSwapInterval;
    ANativeWindow::dequeueBuffer    = hook_dequeueBuffer;
    ANativeWindow::cancelBuffer     = hook_cancelBuffer;
    ANativeWindow::queueBuffer      = hook_queueBuffer;
    ANativeWindow::query            = hook_query;
    ANativeWindow::perform          = hook_perform;

    ANativeWindow::dequeueBuffer_DEPRECATED = hook_dequeueBuffer_DEPRECATED;
    ANativeWindow::cancelBuffer_DEPRECATED  = hook_cancelBuffer_DEPRECATED;
    ANativeWindow::lockBuffer_DEPRECATED    = hook_lockBuffer_DEPRECATED;
    ANativeWindow::queueBuffer_DEPRECATED   = hook_queueBuffer_DEPRECATED;

    const_cast<int&>(ANativeWindow::minSwapInterval) = 0;
    const_cast<int&>(ANativeWindow::maxSwapInterval) = 1;

    mReqWidth = 0;
    mReqHeight = 0;
    mReqFormat = 0;
    mReqUsage = 0;
    mTimestamp = NATIVE_WINDOW_TIMESTAMP_AUTO;
    mDataSpace = HAL_DATASPACE_UNKNOWN;
    mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;
    mTransform = 0;
    mStickyTransform = 0;
    mDefaultWidth = 0;
    mDefaultHeight = 0;
    mUserWidth = 0;
    mUserHeight = 0;
    mTransformHint = 0;
    mConsumerRunningBehind = false;
    mConnectedToCpu = false;
    mProducerControlledByApp = controlledByApp;
    mSwapIntervalZero = false;
!!!14307333.cpp!!!	getIGraphicBufferProducer() : sp<IGraphicBufferProducer>
    return mGraphicBufferProducer;
!!!14307589.cpp!!!	setSidebandStream(in stream : sp<NativeHandle>) : void
    mGraphicBufferProducer->setSidebandStream(stream);
!!!14307717.cpp!!!	allocateBuffers() : void
    uint32_t reqWidth = mReqWidth ? mReqWidth : mUserWidth;
    uint32_t reqHeight = mReqHeight ? mReqHeight : mUserHeight;
    mGraphicBufferProducer->allocateBuffers(reqWidth, reqHeight,
            mReqFormat, mReqUsage);
!!!14307845.cpp!!!	setGenerationNumber(in generation : uint32_t) : status_t
    status_t result = mGraphicBufferProducer->setGenerationNumber(generation);
    if (result == NO_ERROR) {
        mGenerationNumber = generation;
    }
    return result;
!!!14307973.cpp!!!	getConsumerName() : String8
    return mGraphicBufferProducer->getConsumerName();
!!!14308101.cpp!!!	getNextFrameNumber() : uint64_t
    Mutex::Autolock lock(mMutex);
    return mNextFrameNumber;
!!!14308229.cpp!!!	setScalingMode(in mode : int) : int
    ATRACE_CALL();
    ALOGV("Surface::setScalingMode(%d)", mode);

    switch (mode) {
        case NATIVE_WINDOW_SCALING_MODE_FREEZE:
        case NATIVE_WINDOW_SCALING_MODE_SCALE_TO_WINDOW:
        case NATIVE_WINDOW_SCALING_MODE_SCALE_CROP:
        case NATIVE_WINDOW_SCALING_MODE_NO_SCALE_CROP:
            break;
        default:
            ALOGE("unknown scaling mode: %d", mode);
            return BAD_VALUE;
    }

    Mutex::Autolock lock(mMutex);
    mScalingMode = mode;
    return NO_ERROR;
!!!14308357.cpp!!!	setDequeueTimeout(in timeout : nsecs_t) : status_t
    return mGraphicBufferProducer->setDequeueTimeout(timeout);
!!!14308485.cpp!!!	waitForNextFrame(in lastFrame : uint64_t, in timeout : nsecs_t) : bool
    Mutex::Autolock lock(mMutex);
    if (mNextFrameNumber > lastFrame) {
      return true;
    }
    return mQueueBufferCondition.waitRelative(mMutex, timeout) == OK;
!!!14308613.cpp!!!	getLastQueuedBuffer(inout outBuffer : sp<GraphicBuffer>, inout outFence : sp<Fence>, in outTransformMatrix : float) : status_t
    return mGraphicBufferProducer->getLastQueuedBuffer(outBuffer, outFence,
            outTransformMatrix);
!!!14308741.cpp!!!	getDisplayRefreshCycleDuration(inout outRefreshDuration : nsecs_t) : status_t
    ATRACE_CALL();

    DisplayStatInfo stats;
    status_t err = composerService()->getDisplayStats(NULL, &stats);

    *outRefreshDuration = stats.vsyncPeriod;

    return NO_ERROR;
!!!14308869.cpp!!!	enableFrameTimestamps(in enable : bool) : void
    Mutex::Autolock lock(mMutex);
    // If going from disabled to enabled, get the initial values for
    // compositor and display timing.
    if (!mEnableFrameTimestamps && enable) {
        FrameEventHistoryDelta delta;
        mGraphicBufferProducer->getFrameTimestamps(&delta);
        mFrameEventHistory->applyDelta(delta);
    }
    mEnableFrameTimestamps = enable;
!!!14308997.cpp!!!	getCompositorTiming(inout compositeDeadline : nsecs_t, inout compositeInterval : nsecs_t, inout compositeToPresentLatency : nsecs_t) : status_t
    Mutex::Autolock lock(mMutex);
    if (!mEnableFrameTimestamps) {
        return INVALID_OPERATION;
    }

    if (compositeDeadline != nullptr) {
        *compositeDeadline =
                mFrameEventHistory->getNextCompositeDeadline(now());
    }
    if (compositeInterval != nullptr) {
        *compositeInterval = mFrameEventHistory->getCompositeInterval();
    }
    if (compositeToPresentLatency != nullptr) {
        *compositeToPresentLatency =
                mFrameEventHistory->getCompositeToPresentLatency();
    }
    return NO_ERROR;
!!!14309125.cpp!!!	getFrameTimestamps(in frameNumber : uint64_t, inout outRequestedPresentTime : nsecs_t, inout outAcquireTime : nsecs_t, inout outLatchTime : nsecs_t, inout outFirstRefreshStartTime : nsecs_t, inout outLastRefreshStartTime : nsecs_t, inout outGpuCompositionDoneTime : nsecs_t, inout outDisplayPresentTime : nsecs_t, inout outDequeueReadyTime : nsecs_t, inout outReleaseTime : nsecs_t) : status_t
    ATRACE_CALL();

    Mutex::Autolock lock(mMutex);

    if (!mEnableFrameTimestamps) {
        return INVALID_OPERATION;
    }

    // Verify the requested timestamps are supported.
    querySupportedTimestampsLocked();
    if (outDisplayPresentTime != nullptr && !mFrameTimestampsSupportsPresent) {
        return BAD_VALUE;
    }

    FrameEvents* events = mFrameEventHistory->getFrame(frameNumber);
    if (events == nullptr) {
        // If the entry isn't available in the producer, it's definitely not
        // available in the consumer.
        return NAME_NOT_FOUND;
    }

    // Update our cache of events if the requested events are not available.
    if (checkConsumerForUpdates(events, mLastFrameNumber,
            outLatchTime, outFirstRefreshStartTime, outLastRefreshStartTime,
            outGpuCompositionDoneTime, outDisplayPresentTime,
            outDequeueReadyTime, outReleaseTime)) {
        FrameEventHistoryDelta delta;
        mGraphicBufferProducer->getFrameTimestamps(&delta);
        mFrameEventHistory->applyDelta(delta);
        events = mFrameEventHistory->getFrame(frameNumber);
    }

    if (events == nullptr) {
        // The entry was available before the update, but was overwritten
        // after the update. Make sure not to send the wrong frame's data.
        return NAME_NOT_FOUND;
    }

    getFrameTimestamp(outRequestedPresentTime, events->requestedPresentTime);
    getFrameTimestamp(outLatchTime, events->latchTime);
    getFrameTimestamp(outFirstRefreshStartTime, events->firstRefreshStartTime);
    getFrameTimestamp(outLastRefreshStartTime, events->lastRefreshStartTime);
    getFrameTimestamp(outDequeueReadyTime, events->dequeueReadyTime);

    getFrameTimestampFence(outAcquireTime, events->acquireFence,
            events->hasAcquireInfo());
    getFrameTimestampFence(outGpuCompositionDoneTime,
            events->gpuCompositionDoneFence,
            events->hasGpuCompositionDoneInfo());
    getFrameTimestampFence(outDisplayPresentTime, events->displayPresentFence,
            events->hasDisplayPresentInfo());
    getFrameTimestampFence(outReleaseTime, events->releaseFence,
            events->hasReleaseInfo());

    return NO_ERROR;
!!!14309253.cpp!!!	getWideColorSupport(inout supported : bool) : status_t
    ATRACE_CALL();

    sp<IBinder> display(
        composerService()->getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
    Vector<android_color_mode_t> colorModes;
    status_t err =
        composerService()->getDisplayColorModes(display, &colorModes);

    if (err)
        return err;

    bool wideColorBoardConfig =
        getBool<ISurfaceFlingerConfigs,
                &ISurfaceFlingerConfigs::hasWideColorDisplay>(false);

    *supported = false;
    for (android_color_mode_t colorMode : colorModes) {
        switch (colorMode) {
            case HAL_COLOR_MODE_DISPLAY_P3:
            case HAL_COLOR_MODE_ADOBE_RGB:
            case HAL_COLOR_MODE_DCI_P3:
                if (wideColorBoardConfig) {
                    *supported = true;
                }
                break;
            default:
                break;
        }
    }

    return NO_ERROR;
!!!14309381.cpp!!!	getHdrSupport(inout supported : bool) : status_t
    ATRACE_CALL();

    sp<IBinder> display(
        composerService()->getBuiltInDisplay(ISurfaceComposer::eDisplayIdMain));
    HdrCapabilities hdrCapabilities;
    status_t err =
        composerService()->getHdrCapabilities(display, &hdrCapabilities);

    if (err)
        return err;

    *supported = !hdrCapabilities.getSupportedHdrTypes().empty();

    return NO_ERROR;
!!!14309509.cpp!!!	getUniqueId(inout outId : uint64_t) : status_t
    Mutex::Autolock lock(mMutex);
    return mGraphicBufferProducer->getUniqueId(outId);
!!!14309637.cpp!!!	getLastDequeueStartTime() : nsecs_t
    Mutex::Autolock lock(mMutex);
    return mLastDequeueStartTime;
!!!14309765.cpp!!!	~Surface()
    if (mConnectedToCpu) {
        Surface::disconnect(NATIVE_WINDOW_API_CPU);
    }
!!!14309893.cpp!!!	composerService() : sp<ISurfaceComposer>
    return ComposerService::getComposerService();
!!!14310021.cpp!!!	now() : nsecs_t
    return systemTime();
!!!14310405.cpp!!!	hook_cancelBuffer(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer, in fenceFd : int) : int
    Surface* c = getSelf(window);
    return c->cancelBuffer(buffer, fenceFd);
!!!14310533.cpp!!!	hook_dequeueBuffer(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer, inout fenceFd : int) : int
    Surface* c = getSelf(window);
    return c->dequeueBuffer(buffer, fenceFd);
!!!14310661.cpp!!!	hook_perform(inout window : ANativeWindow, in operation : int) : int
    va_list args;
    va_start(args, operation);
    Surface* c = getSelf(window);
    int result = c->perform(operation, args);
    va_end(args);
    return result;
!!!14310789.cpp!!!	hook_query(in window : ANativeWindow, in what : int, inout value : int) : int
    const Surface* c = getSelf(window);
    return c->query(what, value);
!!!14310917.cpp!!!	hook_queueBuffer(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer, in fenceFd : int) : int
    Surface* c = getSelf(window);
    return c->queueBuffer(buffer, fenceFd);
!!!14311045.cpp!!!	hook_setSwapInterval(inout window : ANativeWindow, in interval : int) : int
    Surface* c = getSelf(window);
    return c->setSwapInterval(interval);
!!!14311173.cpp!!!	hook_cancelBuffer_DEPRECATED(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer) : int
    Surface* c = getSelf(window);
    return c->cancelBuffer(buffer, -1);
!!!14311301.cpp!!!	hook_dequeueBuffer_DEPRECATED(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer) : int
    Surface* c = getSelf(window);
    ANativeWindowBuffer* buf;
    int fenceFd = -1;
    int result = c->dequeueBuffer(&buf, &fenceFd);
    if (result != OK) {
        return result;
    }
    sp<Fence> fence(new Fence(fenceFd));
    int waitResult = fence->waitForever("dequeueBuffer_DEPRECATED");
    if (waitResult != OK) {
        ALOGE("dequeueBuffer_DEPRECATED: Fence::wait returned an error: %d",
                waitResult);
        c->cancelBuffer(buf, -1);
        return waitResult;
    }
    *buffer = buf;
    return result;
!!!14311429.cpp!!!	hook_lockBuffer_DEPRECATED(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer) : int
    Surface* c = getSelf(window);
    return c->lockBuffer_DEPRECATED(buffer);
!!!14311557.cpp!!!	hook_queueBuffer_DEPRECATED(inout window : ANativeWindow, inout buffer : ANativeWindowBuffer) : int
    Surface* c = getSelf(window);
    return c->queueBuffer(buffer, -1);
!!!14311685.cpp!!!	dispatchConnect(in args : va_list) : int
    int api = va_arg(args, int);
    return connect(api);
!!!14311813.cpp!!!	dispatchDisconnect(in args : va_list) : int
    int api = va_arg(args, int);
    return disconnect(api);
!!!14311941.cpp!!!	dispatchSetBufferCount(in args : va_list) : int
    size_t bufferCount = va_arg(args, size_t);
    return setBufferCount(static_cast<int32_t>(bufferCount));
!!!14312069.cpp!!!	dispatchSetBuffersGeometry(in args : va_list) : int
    uint32_t width = va_arg(args, uint32_t);
    uint32_t height = va_arg(args, uint32_t);
    PixelFormat format = va_arg(args, PixelFormat);
    int err = setBuffersDimensions(width, height);
    if (err != 0) {
        return err;
    }
    return setBuffersFormat(format);
!!!14312197.cpp!!!	dispatchSetBuffersDimensions(in args : va_list) : int
    uint32_t width = va_arg(args, uint32_t);
    uint32_t height = va_arg(args, uint32_t);
    return setBuffersDimensions(width, height);
!!!14312325.cpp!!!	dispatchSetBuffersUserDimensions(in args : va_list) : int
    uint32_t width = va_arg(args, uint32_t);
    uint32_t height = va_arg(args, uint32_t);
    return setBuffersUserDimensions(width, height);
!!!14312453.cpp!!!	dispatchSetBuffersFormat(in args : va_list) : int
    PixelFormat format = va_arg(args, PixelFormat);
    return setBuffersFormat(format);
!!!14312581.cpp!!!	dispatchSetScalingMode(in args : va_list) : int
    int mode = va_arg(args, int);
    return setScalingMode(mode);
!!!14312709.cpp!!!	dispatchSetBuffersTransform(in args : va_list) : int
    uint32_t transform = va_arg(args, uint32_t);
    return setBuffersTransform(transform);
!!!14312837.cpp!!!	dispatchSetBuffersStickyTransform(in args : va_list) : int
    uint32_t transform = va_arg(args, uint32_t);
    return setBuffersStickyTransform(transform);
!!!14312965.cpp!!!	dispatchSetBuffersTimestamp(in args : va_list) : int
    int64_t timestamp = va_arg(args, int64_t);
    return setBuffersTimestamp(timestamp);
!!!14313093.cpp!!!	dispatchSetCrop(in args : va_list) : int
    android_native_rect_t const* rect = va_arg(args, android_native_rect_t*);
    return setCrop(reinterpret_cast<Rect const*>(rect));
!!!14313349.cpp!!!	dispatchSetUsage(in args : va_list) : int
    int usage = va_arg(args, int);
    return setUsage(static_cast<uint32_t>(usage));
!!!14313477.cpp!!!	dispatchLock(in args : va_list) : int
    ANativeWindow_Buffer* outBuffer = va_arg(args, ANativeWindow_Buffer*);
    ARect* inOutDirtyBounds = va_arg(args, ARect*);
    return lock(outBuffer, inOutDirtyBounds);
!!!14313733.cpp!!!	dispatchSetSidebandStream(in args : va_list) : int
    native_handle_t* sH = va_arg(args, native_handle_t*);
    sp<NativeHandle> sidebandHandle = NativeHandle::create(sH, false);
    setSidebandStream(sidebandHandle);
    return OK;
!!!14313861.cpp!!!	dispatchSetBuffersDataSpace(in args : va_list) : int
    android_dataspace dataspace =
            static_cast<android_dataspace>(va_arg(args, int));
    return setBuffersDataSpace(dataspace);
!!!14313989.cpp!!!	dispatchSetSurfaceDamage(in args : va_list) : int
    android_native_rect_t* rects = va_arg(args, android_native_rect_t*);
    size_t numRects = va_arg(args, size_t);
    setSurfaceDamage(rects, numRects);
    return NO_ERROR;
!!!14314117.cpp!!!	dispatchSetSharedBufferMode(in args : va_list) : int
    bool sharedBufferMode = va_arg(args, int);
    return setSharedBufferMode(sharedBufferMode);
!!!14314245.cpp!!!	dispatchSetAutoRefresh(in args : va_list) : int
    bool autoRefresh = va_arg(args, int);
    return setAutoRefresh(autoRefresh);
!!!14314373.cpp!!!	dispatchGetDisplayRefreshCycleDuration(in args : va_list) : int
    nsecs_t* outRefreshDuration = va_arg(args, int64_t*);
    return getDisplayRefreshCycleDuration(outRefreshDuration);
!!!14314501.cpp!!!	dispatchGetNextFrameId(in args : va_list) : int
    uint64_t* nextFrameId = va_arg(args, uint64_t*);
    *nextFrameId = getNextFrameNumber();
    return NO_ERROR;
!!!14314629.cpp!!!	dispatchEnableFrameTimestamps(in args : va_list) : int
    bool enable = va_arg(args, int);
    enableFrameTimestamps(enable);
    return NO_ERROR;
!!!14314757.cpp!!!	dispatchGetCompositorTiming(in args : va_list) : int
    nsecs_t* compositeDeadline = va_arg(args, int64_t*);
    nsecs_t* compositeInterval = va_arg(args, int64_t*);
    nsecs_t* compositeToPresentLatency = va_arg(args, int64_t*);
    return getCompositorTiming(compositeDeadline, compositeInterval,
            compositeToPresentLatency);
!!!14314885.cpp!!!	dispatchGetFrameTimestamps(in args : va_list) : int
    uint64_t frameId = va_arg(args, uint64_t);
    nsecs_t* outRequestedPresentTime = va_arg(args, int64_t*);
    nsecs_t* outAcquireTime = va_arg(args, int64_t*);
    nsecs_t* outLatchTime = va_arg(args, int64_t*);
    nsecs_t* outFirstRefreshStartTime = va_arg(args, int64_t*);
    nsecs_t* outLastRefreshStartTime = va_arg(args, int64_t*);
    nsecs_t* outGpuCompositionDoneTime = va_arg(args, int64_t*);
    nsecs_t* outDisplayPresentTime = va_arg(args, int64_t*);
    nsecs_t* outDequeueReadyTime = va_arg(args, int64_t*);
    nsecs_t* outReleaseTime = va_arg(args, int64_t*);
    return getFrameTimestamps(frameId,
            outRequestedPresentTime, outAcquireTime, outLatchTime,
            outFirstRefreshStartTime, outLastRefreshStartTime,
            outGpuCompositionDoneTime, outDisplayPresentTime,
            outDequeueReadyTime, outReleaseTime);
!!!14315013.cpp!!!	dispatchGetWideColorSupport(in args : va_list) : int
    bool* outSupport = va_arg(args, bool*);
    return getWideColorSupport(outSupport);
!!!14315141.cpp!!!	dispatchGetHdrSupport(in args : va_list) : int
    bool* outSupport = va_arg(args, bool*);
    return getHdrSupport(outSupport);
!!!14315653.cpp!!!	perform(in operation : int, in args : va_list) : int
    int res = NO_ERROR;
    switch (operation) {
    case NATIVE_WINDOW_CONNECT:
        // deprecated. must return NO_ERROR.
        break;
    case NATIVE_WINDOW_DISCONNECT:
        // deprecated. must return NO_ERROR.
        break;
    case NATIVE_WINDOW_SET_USAGE:
        res = dispatchSetUsage(args);
        break;
    case NATIVE_WINDOW_SET_CROP:
        res = dispatchSetCrop(args);
        break;
    case NATIVE_WINDOW_SET_BUFFER_COUNT:
        res = dispatchSetBufferCount(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_GEOMETRY:
        res = dispatchSetBuffersGeometry(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_TRANSFORM:
        res = dispatchSetBuffersTransform(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_STICKY_TRANSFORM:
        res = dispatchSetBuffersStickyTransform(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_TIMESTAMP:
        res = dispatchSetBuffersTimestamp(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_DIMENSIONS:
        res = dispatchSetBuffersDimensions(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_USER_DIMENSIONS:
        res = dispatchSetBuffersUserDimensions(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_FORMAT:
        res = dispatchSetBuffersFormat(args);
        break;
    case NATIVE_WINDOW_LOCK:
        res = dispatchLock(args);
        break;
    case NATIVE_WINDOW_UNLOCK_AND_POST:
        res = dispatchUnlockAndPost(args);
        break;
    case NATIVE_WINDOW_SET_SCALING_MODE:
        res = dispatchSetScalingMode(args);
        break;
    case NATIVE_WINDOW_API_CONNECT:
        res = dispatchConnect(args);
        break;
    case NATIVE_WINDOW_API_DISCONNECT:
        res = dispatchDisconnect(args);
        break;
    case NATIVE_WINDOW_SET_SIDEBAND_STREAM:
        res = dispatchSetSidebandStream(args);
        break;
    case NATIVE_WINDOW_SET_BUFFERS_DATASPACE:
        res = dispatchSetBuffersDataSpace(args);
        break;
    case NATIVE_WINDOW_SET_SURFACE_DAMAGE:
        res = dispatchSetSurfaceDamage(args);
        break;
    case NATIVE_WINDOW_SET_SHARED_BUFFER_MODE:
        res = dispatchSetSharedBufferMode(args);
        break;
    case NATIVE_WINDOW_SET_AUTO_REFRESH:
        res = dispatchSetAutoRefresh(args);
        break;
    case NATIVE_WINDOW_GET_REFRESH_CYCLE_DURATION:
        res = dispatchGetDisplayRefreshCycleDuration(args);
        break;
    case NATIVE_WINDOW_GET_NEXT_FRAME_ID:
        res = dispatchGetNextFrameId(args);
        break;
    case NATIVE_WINDOW_ENABLE_FRAME_TIMESTAMPS:
        res = dispatchEnableFrameTimestamps(args);
        break;
    case NATIVE_WINDOW_GET_COMPOSITOR_TIMING:
        res = dispatchGetCompositorTiming(args);
        break;
    case NATIVE_WINDOW_GET_FRAME_TIMESTAMPS:
        res = dispatchGetFrameTimestamps(args);
        break;
    case NATIVE_WINDOW_GET_WIDE_COLOR_SUPPORT:
        res = dispatchGetWideColorSupport(args);
        break;
    case NATIVE_WINDOW_GET_HDR_SUPPORT:
        res = dispatchGetHdrSupport(args);
        break;
    default:
        res = NAME_NOT_FOUND;
        break;
    }
    return res;
!!!14315781.cpp!!!	setSwapInterval(in interval : int) : int
    ATRACE_CALL();
    // EGL specification states:
    //  interval is silently clamped to minimum and maximum implementation
    //  dependent values before being stored.

    if (interval < minSwapInterval)
        interval = minSwapInterval;

    if (interval > maxSwapInterval)
        interval = maxSwapInterval;

    mSwapIntervalZero = (interval == 0);
    mGraphicBufferProducer->setAsyncMode(mSwapIntervalZero);

    return NO_ERROR;
!!!14316037.cpp!!!	connect(in api : int) : int
    static sp<IProducerListener> listener = new DummyProducerListener();
    return connect(api, listener);
!!!14316165.cpp!!!	setBufferCount(in bufferCount : int) : int
    ATRACE_CALL();
    ALOGV("Surface::setBufferCount");
    Mutex::Autolock lock(mMutex);

    status_t err = NO_ERROR;
    if (bufferCount == 0) {
        err = mGraphicBufferProducer->setMaxDequeuedBufferCount(1);
    } else {
        int minUndequeuedBuffers = 0;
        err = mGraphicBufferProducer->query(
                NATIVE_WINDOW_MIN_UNDEQUEUED_BUFFERS, &minUndequeuedBuffers);
        if (err == NO_ERROR) {
            err = mGraphicBufferProducer->setMaxDequeuedBufferCount(
                    bufferCount - minUndequeuedBuffers);
        }
    }

    ALOGE_IF(err, "IGraphicBufferProducer::setBufferCount(%d) returned %s",
             bufferCount, strerror(-err));

    return err;
!!!14316293.cpp!!!	setBuffersUserDimensions(in width : uint32_t, in height : uint32_t) : int
    ATRACE_CALL();
    ALOGV("Surface::setBuffersUserDimensions");

    if ((width && !height) || (!width && height))
        return BAD_VALUE;

    Mutex::Autolock lock(mMutex);
    if (width != mUserWidth || height != mUserHeight) {
        mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
    }
    mUserWidth = width;
    mUserHeight = height;
    return NO_ERROR;
!!!14316421.cpp!!!	setBuffersFormat(in format : PixelFormat) : int
    ALOGV("Surface::setBuffersFormat");

    Mutex::Autolock lock(mMutex);
    if (format != mReqFormat) {
        mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
    }
    mReqFormat = format;
    return NO_ERROR;
!!!14316549.cpp!!!	setBuffersTransform(in transform : uint32_t) : int
    ATRACE_CALL();
    ALOGV("Surface::setBuffersTransform");
    Mutex::Autolock lock(mMutex);
    mTransform = transform;
    return NO_ERROR;
!!!14316677.cpp!!!	setBuffersStickyTransform(in transform : uint32_t) : int
    ATRACE_CALL();
    ALOGV("Surface::setBuffersStickyTransform");
    Mutex::Autolock lock(mMutex);
    mStickyTransform = transform;
    return NO_ERROR;
!!!14316805.cpp!!!	setBuffersTimestamp(in timestamp : int64_t) : int
    ALOGV("Surface::setBuffersTimestamp");
    Mutex::Autolock lock(mMutex);
    mTimestamp = timestamp;
    return NO_ERROR;
!!!14316933.cpp!!!	setBuffersDataSpace(in dataSpace : android_dataspace) : int
    ALOGV("Surface::setBuffersDataSpace");
    Mutex::Autolock lock(mMutex);
    mDataSpace = dataSpace;
    return NO_ERROR;
!!!14317061.cpp!!!	setCrop(in rect : Rect) : int
    ATRACE_CALL();

    Rect realRect(Rect::EMPTY_RECT);
    if (rect == NULL || rect->isEmpty()) {
        realRect.clear();
    } else {
        realRect = *rect;
    }

    ALOGV("Surface::setCrop rect=[%d %d %d %d]",
            realRect.left, realRect.top, realRect.right, realRect.bottom);

    Mutex::Autolock lock(mMutex);
    mCrop = realRect;
    return NO_ERROR;
!!!14317189.cpp!!!	setUsage(in reqUsage : uint32_t) : int
    ALOGV("Surface::setUsage");
    Mutex::Autolock lock(mMutex);
    if (reqUsage != mReqUsage) {
        mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
    }
    mReqUsage = reqUsage;
    return OK;
!!!14317317.cpp!!!	setSurfaceDamage(inout rects : android_native_rect_t, in numRects : size_t) : void
    ATRACE_CALL();
    ALOGV("Surface::setSurfaceDamage");
    Mutex::Autolock lock(mMutex);

    if (mConnectedToCpu || numRects == 0) {
        mDirtyRegion = Region::INVALID_REGION;
        return;
    }

    mDirtyRegion.clear();
    for (size_t r = 0; r < numRects; ++r) {
        // We intentionally flip top and bottom here, since because they're
        // specified with a bottom-left origin, top > bottom, which fails
        // validation in the Region class. We will fix this up when we flip to a
        // top-left origin in queueBuffer.
        Rect rect(rects[r].left, rects[r].bottom, rects[r].right, rects[r].top);
        mDirtyRegion.orSelf(rect);
    }
!!!14317445.cpp!!!	disconnect(in api : int, in mode : IGraphicBufferProducer::DisconnectMode = IGraphicBufferProducer::DisconnectMode::Api) : int
    ATRACE_CALL();
    ALOGV("Surface::disconnect");
    Mutex::Autolock lock(mMutex);
    mRemovedBuffers.clear();
    mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
    mSharedBufferHasBeenQueued = false;
    freeAllBuffers();
    int err = mGraphicBufferProducer->disconnect(api, mode);
    if (!err) {
        mReqFormat = 0;
        mReqWidth = 0;
        mReqHeight = 0;
        mReqUsage = 0;
        mCrop.clear();
        mScalingMode = NATIVE_WINDOW_SCALING_MODE_FREEZE;
        mTransform = 0;
        mStickyTransform = 0;

        if (api == NATIVE_WINDOW_API_CPU) {
            mConnectedToCpu = false;
        }
    }
    return err;
!!!14317573.cpp!!!	setMaxDequeuedBufferCount(in maxDequeuedBuffers : int) : int
    ATRACE_CALL();
    ALOGV("Surface::setMaxDequeuedBufferCount");
    Mutex::Autolock lock(mMutex);

    status_t err = mGraphicBufferProducer->setMaxDequeuedBufferCount(
            maxDequeuedBuffers);
    ALOGE_IF(err, "IGraphicBufferProducer::setMaxDequeuedBufferCount(%d) "
            "returned %s", maxDequeuedBuffers, strerror(-err));

    return err;
!!!14317701.cpp!!!	setAsyncMode(in async : bool) : int
    ATRACE_CALL();
    ALOGV("Surface::setAsyncMode");
    Mutex::Autolock lock(mMutex);

    status_t err = mGraphicBufferProducer->setAsyncMode(async);
    ALOGE_IF(err, "IGraphicBufferProducer::setAsyncMode(%d) returned %s",
            async, strerror(-err));

    return err;
!!!14317829.cpp!!!	setSharedBufferMode(in sharedBufferMode : bool) : int
    ATRACE_CALL();
    ALOGV("Surface::setSharedBufferMode (%d)", sharedBufferMode);
    Mutex::Autolock lock(mMutex);

    status_t err = mGraphicBufferProducer->setSharedBufferMode(
            sharedBufferMode);
    if (err == NO_ERROR) {
        mSharedBufferMode = sharedBufferMode;
    }
    ALOGE_IF(err, "IGraphicBufferProducer::setSharedBufferMode(%d) returned"
            "%s", sharedBufferMode, strerror(-err));

    return err;
!!!14317957.cpp!!!	setAutoRefresh(in autoRefresh : bool) : int
    ATRACE_CALL();
    ALOGV("Surface::setAutoRefresh (%d)", autoRefresh);
    Mutex::Autolock lock(mMutex);

    status_t err = mGraphicBufferProducer->setAutoRefresh(autoRefresh);
    if (err == NO_ERROR) {
        mAutoRefresh = autoRefresh;
    }
    ALOGE_IF(err, "IGraphicBufferProducer::setAutoRefresh(%d) returned %s",
            autoRefresh, strerror(-err));
    return err;
!!!14318085.cpp!!!	setBuffersDimensions(in width : uint32_t, in height : uint32_t) : int
    ATRACE_CALL();
    ALOGV("Surface::setBuffersDimensions");

    if ((width && !height) || (!width && height))
        return BAD_VALUE;

    Mutex::Autolock lock(mMutex);
    if (width != mReqWidth || height != mReqHeight) {
        mSharedBufferSlot = BufferItem::INVALID_BUFFER_SLOT;
    }
    mReqWidth = width;
    mReqHeight = height;
    return NO_ERROR;
!!!14318213.cpp!!!	lock(inout outBuffer : ANativeWindow_Buffer, inout inOutDirtyBounds : ARect) : int
    if (mLockedBuffer != 0) {
        ALOGE("Surface::lock failed, already locked");
        return INVALID_OPERATION;
    }

    if (!mConnectedToCpu) {
        int err = Surface::connect(NATIVE_WINDOW_API_CPU);
        if (err) {
            return err;
        }
        // we're intending to do software rendering from this point
        setUsage(GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN);
    }

    ANativeWindowBuffer* out;
    int fenceFd = -1;
    status_t err = dequeueBuffer(&out, &fenceFd);
    ALOGE_IF(err, "dequeueBuffer failed (%s)", strerror(-err));
    if (err == NO_ERROR) {
        sp<GraphicBuffer> backBuffer(GraphicBuffer::getSelf(out));
        const Rect bounds(backBuffer->width, backBuffer->height);

        Region newDirtyRegion;
        if (inOutDirtyBounds) {
            newDirtyRegion.set(static_cast<Rect const&>(*inOutDirtyBounds));
            newDirtyRegion.andSelf(bounds);
        } else {
            newDirtyRegion.set(bounds);
        }

        // figure out if we can copy the frontbuffer back
        const sp<GraphicBuffer>& frontBuffer(mPostedBuffer);
        const bool canCopyBack = (frontBuffer != 0 &&
                backBuffer->width  == frontBuffer->width &&
                backBuffer->height == frontBuffer->height &&
                backBuffer->format == frontBuffer->format);

        if (canCopyBack) {
            // copy the area that is invalid and not repainted this round
            const Region copyback(mDirtyRegion.subtract(newDirtyRegion));
            if (!copyback.isEmpty()) {
                copyBlt(backBuffer, frontBuffer, copyback, &fenceFd);
            }
        } else {
            // if we can't copy-back anything, modify the user's dirty
            // region to make sure they redraw the whole buffer
            newDirtyRegion.set(bounds);
            mDirtyRegion.clear();
            Mutex::Autolock lock(mMutex);
            for (size_t i=0 ; i<NUM_BUFFER_SLOTS ; i++) {
                mSlots[i].dirtyRegion.clear();
            }
        }


        { // scope for the lock
            Mutex::Autolock lock(mMutex);
            int backBufferSlot(getSlotFromBufferLocked(backBuffer.get()));
            if (backBufferSlot >= 0) {
                Region& dirtyRegion(mSlots[backBufferSlot].dirtyRegion);
                mDirtyRegion.subtract(dirtyRegion);
                dirtyRegion = newDirtyRegion;
            }
        }

        mDirtyRegion.orSelf(newDirtyRegion);
        if (inOutDirtyBounds) {
            *inOutDirtyBounds = newDirtyRegion.getBounds();
        }

        void* vaddr;
        status_t res = backBuffer->lockAsync(
                GRALLOC_USAGE_SW_READ_OFTEN | GRALLOC_USAGE_SW_WRITE_OFTEN,
                newDirtyRegion.bounds(), &vaddr, fenceFd);

        ALOGW_IF(res, "failed locking buffer (handle = %p)",
                backBuffer->handle);

        if (res != 0) {
            err = INVALID_OPERATION;
        } else {
            mLockedBuffer = backBuffer;
            outBuffer->width  = backBuffer->width;
            outBuffer->height = backBuffer->height;
            outBuffer->stride = backBuffer->stride;
            outBuffer->format = backBuffer->format;
            outBuffer->bits   = vaddr;
        }
    }
    return err;
!!!14318341.cpp!!!	unlockAndPost() : int
    if (mLockedBuffer == 0) {
        ALOGE("Surface::unlockAndPost failed, no locked buffer");
        return INVALID_OPERATION;
    }

    int fd = -1;
    status_t err = mLockedBuffer->unlockAsync(&fd);
    ALOGE_IF(err, "failed unlocking buffer (%p)", mLockedBuffer->handle);

    err = queueBuffer(mLockedBuffer.get(), fd);
    ALOGE_IF(err, "queueBuffer (handle=%p) failed (%s)",
            mLockedBuffer->handle, strerror(-err));

    mPostedBuffer = mLockedBuffer;
    mLockedBuffer = 0;
    return err;
!!!14318469.cpp!!!	query(in what : int, inout value : int) : int
    ATRACE_CALL();
    ALOGV("Surface::query");
    { // scope for the lock
        Mutex::Autolock lock(mMutex);
        switch (what) {
            case NATIVE_WINDOW_FORMAT:
                if (mReqFormat) {
                    *value = static_cast<int>(mReqFormat);
                    return NO_ERROR;
                }
                break;
            case NATIVE_WINDOW_QUEUES_TO_WINDOW_COMPOSER: {
                if (composerService()->authenticateSurfaceTexture(
                        mGraphicBufferProducer)) {
                    *value = 1;
                } else {
                    *value = 0;
                }
                return NO_ERROR;
            }
            case NATIVE_WINDOW_CONCRETE_TYPE:
                *value = NATIVE_WINDOW_SURFACE;
                return NO_ERROR;
            case NATIVE_WINDOW_DEFAULT_WIDTH:
                *value = static_cast<int>(
                        mUserWidth ? mUserWidth : mDefaultWidth);
                return NO_ERROR;
            case NATIVE_WINDOW_DEFAULT_HEIGHT:
                *value = static_cast<int>(
                        mUserHeight ? mUserHeight : mDefaultHeight);
                return NO_ERROR;
            case NATIVE_WINDOW_TRANSFORM_HINT:
                *value = static_cast<int>(mTransformHint);
                return NO_ERROR;
            case NATIVE_WINDOW_CONSUMER_RUNNING_BEHIND: {
                status_t err = NO_ERROR;
                if (!mConsumerRunningBehind) {
                    *value = 0;
                } else {
                    err = mGraphicBufferProducer->query(what, value);
                    if (err == NO_ERROR) {
                        mConsumerRunningBehind = *value;
                    }
                }
                return err;
            }
            case NATIVE_WINDOW_LAST_DEQUEUE_DURATION: {
                int64_t durationUs = mLastDequeueDuration / 1000;
                *value = durationUs > std::numeric_limits<int>::max() ?
                        std::numeric_limits<int>::max() :
                        static_cast<int>(durationUs);
                return NO_ERROR;
            }
            case NATIVE_WINDOW_LAST_QUEUE_DURATION: {
                int64_t durationUs = mLastQueueDuration / 1000;
                *value = durationUs > std::numeric_limits<int>::max() ?
                        std::numeric_limits<int>::max() :
                        static_cast<int>(durationUs);
                return NO_ERROR;
            }
            case NATIVE_WINDOW_FRAME_TIMESTAMPS_SUPPORTS_PRESENT: {
                querySupportedTimestampsLocked();
                *value = mFrameTimestampsSupportsPresent ? 1 : 0;
                return NO_ERROR;
            }
            case NATIVE_WINDOW_IS_VALID: {
                *value = mGraphicBufferProducer != nullptr ? 1 : 0;
                return NO_ERROR;
            }
        }
    }
    return mGraphicBufferProducer->query(what, value);
!!!14318597.cpp!!!	connect(in api : int, in listener : sp<IProducerListener>) : int
    return connect(api, listener, false);
!!!14318725.cpp!!!	connect(in api : int, in listener : sp<IProducerListener>, in reportBufferRemoval : bool) : int
    ATRACE_CALL();
    ALOGV("Surface::connect");
    Mutex::Autolock lock(mMutex);
    IGraphicBufferProducer::QueueBufferOutput output;
    mReportRemovedBuffers = reportBufferRemoval;
    int err = mGraphicBufferProducer->connect(listener, api, mProducerControlledByApp, &output);
    if (err == NO_ERROR) {
        mDefaultWidth = output.width;
        mDefaultHeight = output.height;
        mNextFrameNumber = output.nextFrameNumber;

        // Disable transform hint if sticky transform is set.
        if (mStickyTransform == 0) {
            mTransformHint = output.transformHint;
        }

        mConsumerRunningBehind = (output.numPendingBuffers >= 2);
    }
    if (!err && api == NATIVE_WINDOW_API_CPU) {
        mConnectedToCpu = true;
        // Clear the dirty region in case we're switching from a non-CPU API
        mDirtyRegion.clear();
    } else if (!err) {
        // Initialize the dirty region for tracking surface damage
        mDirtyRegion = Region::INVALID_REGION;
    }

    return err;
!!!14318853.cpp!!!	detachNextBuffer(inout outBuffer : sp<GraphicBuffer>, inout outFence : sp<Fence>) : int
    ATRACE_CALL();
    ALOGV("Surface::detachNextBuffer");

    if (outBuffer == NULL || outFence == NULL) {
        return BAD_VALUE;
    }

    Mutex::Autolock lock(mMutex);
    if (mReportRemovedBuffers) {
        mRemovedBuffers.clear();
    }

    sp<GraphicBuffer> buffer(NULL);
    sp<Fence> fence(NULL);
    status_t result = mGraphicBufferProducer->detachNextBuffer(
            &buffer, &fence);
    if (result != NO_ERROR) {
        return result;
    }

    *outBuffer = buffer;
    if (fence != NULL && fence->isValid()) {
        *outFence = fence;
    } else {
        *outFence = Fence::NO_FENCE;
    }

    for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
        if (mSlots[i].buffer != NULL &&
                mSlots[i].buffer->getId() == buffer->getId()) {
            if (mReportRemovedBuffers) {
                mRemovedBuffers.push_back(mSlots[i].buffer);
            }
            mSlots[i].buffer = NULL;
        }
    }

    return NO_ERROR;
!!!14318981.cpp!!!	attachBuffer(inout buffer : ANativeWindowBuffer) : int
    ATRACE_CALL();
    ALOGV("Surface::attachBuffer");

    Mutex::Autolock lock(mMutex);
    if (mReportRemovedBuffers) {
        mRemovedBuffers.clear();
    }

    sp<GraphicBuffer> graphicBuffer(static_cast<GraphicBuffer*>(buffer));
    uint32_t priorGeneration = graphicBuffer->mGenerationNumber;
    graphicBuffer->mGenerationNumber = mGenerationNumber;
    int32_t attachedSlot = -1;
    status_t result = mGraphicBufferProducer->attachBuffer(
            &attachedSlot, graphicBuffer);
    if (result != NO_ERROR) {
        ALOGE("attachBuffer: IGraphicBufferProducer call failed (%d)", result);
        graphicBuffer->mGenerationNumber = priorGeneration;
        return result;
    }
    if (mReportRemovedBuffers && (mSlots[attachedSlot].buffer != nullptr)) {
        mRemovedBuffers.push_back(mSlots[attachedSlot].buffer);
    }
    mSlots[attachedSlot].buffer = graphicBuffer;

    return NO_ERROR;
!!!14319109.cpp!!!	getAndFlushRemovedBuffers(inout out : std::vector<sp<GraphicBuffer>>) : status_t
    if (out == nullptr) {
        ALOGE("%s: out must not be null!", __FUNCTION__);
        return BAD_VALUE;
    }

    Mutex::Autolock lock(mMutex);
    *out = mRemovedBuffers;
    mRemovedBuffers.clear();
    return OK;
!!!14319237.cpp!!!	querySupportedTimestampsLocked() : void
    // mMutex must be locked when calling this method.

    if (mQueriedSupportedTimestamps) {
        return;
    }
    mQueriedSupportedTimestamps = true;

    std::vector<FrameEvent> supportedFrameTimestamps;
    status_t err = composerService()->getSupportedFrameTimestamps(
            &supportedFrameTimestamps);

    if (err != NO_ERROR) {
        return;
    }

    for (auto sft : supportedFrameTimestamps) {
        if (sft == FrameEvent::DISPLAY_PRESENT) {
            mFrameTimestampsSupportsPresent = true;
        }
    }
!!!14319365.cpp!!!	freeAllBuffers() : void
    for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
        mSlots[i].buffer = 0;
    }
!!!14319493.cpp!!!	getSlotFromBufferLocked(inout buffer : android_native_buffer_t) : int
    for (int i = 0; i < NUM_BUFFER_SLOTS; i++) {
        if (mSlots[i].buffer != NULL &&
                mSlots[i].buffer->handle == buffer->handle) {
            return i;
        }
    }
    ALOGE("getSlotFromBufferLocked: unknown buffer: %p", buffer->handle);
    return BAD_VALUE;
