class LockPatternUtils
!!!10423173.java!!!	isTrustUsuallyManaged(in userId : int) : boolean
        if (!(mLockSettingsService instanceof ILockSettings.Stub)) {
            throw new IllegalStateException("May only be called by TrustManagerService. "
                    + "Use TrustManager.isTrustUsuallyManaged()");
        }
        try {
            return getLockSettings().getBoolean(IS_TRUST_USUALLY_MANAGED, false, userId);
        } catch (RemoteException e) {
            return false;
        }
!!!10423301.java!!!	setTrustUsuallyManaged(inout managed : boolean, in userId : int) : void
        try {
            getLockSettings().setBoolean(IS_TRUST_USUALLY_MANAGED, managed, userId);
        } catch (RemoteException e) {
            // System dead.
        }
!!!10423429.java!!!	userPresent(in userId : int) : void
        try {
            getLockSettings().userPresent(userId);
        } catch (RemoteException e) {
            throw e.rethrowFromSystemServer();
        }
!!!10423813.java!!!	getDevicePolicyManager() : DevicePolicyManager
        if (mDevicePolicyManager == null) {
            mDevicePolicyManager =
                (DevicePolicyManager)mContext.getSystemService(Context.DEVICE_POLICY_SERVICE);
            if (mDevicePolicyManager == null) {
                Log.e(TAG, "Can't get DevicePolicyManagerService: is it running?",
                        new IllegalStateException("Stack trace:"));
            }
        }
        return mDevicePolicyManager;
!!!10423941.java!!!	getUserManager() : UserManager
        if (mUserManager == null) {
            mUserManager = UserManager.get(mContext);
        }
        return mUserManager;
!!!10424069.java!!!	getTrustManager() : TrustManager
        TrustManager trust = (TrustManager) mContext.getSystemService(Context.TRUST_SERVICE);
        if (trust == null) {
            Log.e(TAG, "Can't get TrustManagerService: is it running?",
                    new IllegalStateException("Stack trace:"));
        }
        return trust;
!!!10424197.java!!!	LockPatternUtils(inout context : Context)
        mContext = context;
        mContentResolver = context.getContentResolver();

        Looper looper = Looper.myLooper();
        mHandler = looper != null ? new Handler(looper) : null;
!!!10424325.java!!!	getLockSettings() : ILockSettings
        if (mLockSettingsService == null) {
            ILockSettings service = ILockSettings.Stub.asInterface(
                    ServiceManager.getService("lock_settings"));
            mLockSettingsService = service;
        }
        return mLockSettingsService;
!!!10424453.java!!!	getRequestedMinimumPasswordLength(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumLength(null, userId);
!!!10424581.java!!!	getRequestedPasswordQuality(in userId : int) : int
        return getDevicePolicyManager().getPasswordQuality(null, userId);
!!!10424709.java!!!	getRequestedPasswordHistoryLength(in userId : int) : int
        return getDevicePolicyManager().getPasswordHistoryLength(null, userId);
!!!10424837.java!!!	getRequestedPasswordMinimumLetters(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumLetters(null, userId);
!!!10424965.java!!!	getRequestedPasswordMinimumUpperCase(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumUpperCase(null, userId);
!!!10425093.java!!!	getRequestedPasswordMinimumLowerCase(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumLowerCase(null, userId);
!!!10425221.java!!!	getRequestedPasswordMinimumNumeric(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumNumeric(null, userId);
!!!10425349.java!!!	getRequestedPasswordMinimumSymbols(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumSymbols(null, userId);
!!!10425477.java!!!	getRequestedPasswordMinimumNonLetter(in userId : int) : int
        return getDevicePolicyManager().getPasswordMinimumNonLetter(null, userId);
!!!10425605.java!!!	reportFailedPasswordAttempt(in userId : int) : void
        getDevicePolicyManager().reportFailedPasswordAttempt(userId);
        getTrustManager().reportUnlockAttempt(false /* authenticated */, userId);
!!!10425733.java!!!	reportSuccessfulPasswordAttempt(in userId : int) : void
        getDevicePolicyManager().reportSuccessfulPasswordAttempt(userId);
        getTrustManager().reportUnlockAttempt(true /* authenticated */, userId);
!!!10425861.java!!!	reportPasswordLockout(in timeoutMs : int, in userId : int) : void
        getTrustManager().reportUnlockLockout(timeoutMs, userId);
!!!10425989.java!!!	getCurrentFailedPasswordAttempts(in userId : int) : int
        return getDevicePolicyManager().getCurrentFailedPasswordAttempts(userId);
!!!10426117.java!!!	getMaximumFailedPasswordsForWipe(in userId : int) : int
        return getDevicePolicyManager().getMaximumFailedPasswordsForWipe(
                null /* componentName */, userId);
!!!10426245.java!!!	verifyCredential(in credential : String, in type : int, in challenge : long, in userId : int) : byte
        try {
            VerifyCredentialResponse response = getLockSettings().verifyCredential(credential,
                    type, challenge, userId);
            if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) {
                return response.getPayload();
            } else if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_RETRY) {
                throw new RequestThrottledException(response.getTimeout());
            } else {
                return null;
            }
        } catch (RemoteException re) {
            return null;
        }
!!!10426373.java!!!	checkCredential(in credential : String, in type : int, in userId : int, inout progressCallback : LockPatternUtils::CheckCredentialProgressCallback) : boolean
        try {
            VerifyCredentialResponse response = getLockSettings().checkCredential(credential, type,
                    userId, wrapCallback(progressCallback));

            if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) {
                return true;
            } else if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_RETRY) {
                throw new RequestThrottledException(response.getTimeout());
            } else {
                return false;
            }
        } catch (RemoteException re) {
            return false;
        }
!!!10426501.java!!!	verifyPattern(inout pattern : List<LockPatternView.Cell>, in challenge : long, in userId : int) : byte
        throwIfCalledOnMainThread();
        return verifyCredential(patternToString(pattern), CREDENTIAL_TYPE_PATTERN, challenge,
                userId);
!!!10426629.java!!!	checkPattern(inout pattern : List<LockPatternView.Cell>, in userId : int) : boolean
        return checkPattern(pattern, userId, null /* progressCallback */);
!!!10426757.java!!!	checkPattern(inout pattern : List<LockPatternView.Cell>, in userId : int, inout progressCallback : LockPatternUtils::CheckCredentialProgressCallback) : boolean
        throwIfCalledOnMainThread();
        return checkCredential(patternToString(pattern), CREDENTIAL_TYPE_PATTERN, userId,
                progressCallback);
!!!10426885.java!!!	verifyPassword(in password : String, in challenge : long, in userId : int) : byte
        throwIfCalledOnMainThread();
        return verifyCredential(password, CREDENTIAL_TYPE_PASSWORD, challenge, userId);
!!!10427013.java!!!	verifyTiedProfileChallenge(in password : String, inout isPattern : boolean, in challenge : long, in userId : int) : byte
        throwIfCalledOnMainThread();
        try {
            VerifyCredentialResponse response =
                    getLockSettings().verifyTiedProfileChallenge(password,
                            isPattern ? CREDENTIAL_TYPE_PATTERN : CREDENTIAL_TYPE_PASSWORD, challenge,
                            userId);

            if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_OK) {
                return response.getPayload();
            } else if (response.getResponseCode() == VerifyCredentialResponse.RESPONSE_RETRY) {
                throw new RequestThrottledException(response.getTimeout());
            } else {
                return null;
            }
        } catch (RemoteException re) {
            return null;
        }
!!!10427141.java!!!	checkPassword(in password : String, in userId : int) : boolean
        return checkPassword(password, userId, null /* progressCallback */);
!!!10427269.java!!!	checkPassword(in password : String, in userId : int, inout progressCallback : LockPatternUtils::CheckCredentialProgressCallback) : boolean
        throwIfCalledOnMainThread();
        return checkCredential(password, CREDENTIAL_TYPE_PASSWORD, userId, progressCallback);
!!!10427397.java!!!	checkVoldPassword(in userId : int) : boolean
        try {
            return getLockSettings().checkVoldPassword(userId);
        } catch (RemoteException re) {
            return false;
        }
!!!10427525.java!!!	checkPasswordHistory(in password : String, in userId : int) : boolean
        String passwordHashString = new String(
                passwordToHash(password, userId), StandardCharsets.UTF_8);
        String passwordHistory = getString(PASSWORD_HISTORY_KEY, userId);
        if (passwordHistory == null) {
            return false;
        }
        // Password History may be too long...
        int passwordHashLength = passwordHashString.length();
        int passwordHistoryLength = getRequestedPasswordHistoryLength(userId);
        if(passwordHistoryLength == 0) {
            return false;
        }
        int neededPasswordHistoryLength = passwordHashLength * passwordHistoryLength
                + passwordHistoryLength - 1;
        if (passwordHistory.length() > neededPasswordHistoryLength) {
            passwordHistory = passwordHistory.substring(0, neededPasswordHistoryLength);
        }
        return passwordHistory.contains(passwordHashString);
!!!10427653.java!!!	savedPatternExists(in userId : int) : boolean
        try {
            return getLockSettings().havePattern(userId);
        } catch (RemoteException re) {
            return false;
        }
!!!10427781.java!!!	savedPasswordExists(in userId : int) : boolean
        try {
            return getLockSettings().havePassword(userId);
        } catch (RemoteException re) {
            return false;
        }
!!!10427909.java!!!	isPatternEverChosen(in userId : int) : boolean
        return getBoolean(PATTERN_EVER_CHOSEN_KEY, false, userId);
!!!10428037.java!!!	getActivePasswordQuality(in userId : int) : int
        int quality = getKeyguardStoredPasswordQuality(userId);

        if (isLockPasswordEnabled(quality, userId)) {
            // Quality is a password and a password exists. Return the quality.
            return quality;
        }

        if (isLockPatternEnabled(quality, userId)) {
            // Quality is a pattern and a pattern exists. Return the quality.
            return quality;
        }

        return DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED;
!!!10428165.java!!!	resetKeyStore(in userId : int) : void
        try {
            getLockSettings().resetKeyStore(userId);
        } catch (RemoteException e) {
            // It should not happen
            Log.e(TAG, "Couldn't reset keystore " + e);
        }
!!!10428293.java!!!	clearLock(in savedCredential : String, in userHandle : int) : void
        setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, userHandle);

        try{
            getLockSettings().setLockCredential(null, CREDENTIAL_TYPE_NONE, savedCredential,
                    userHandle);
        } catch (RemoteException e) {
            // well, we tried...
        }

        if (userHandle == UserHandle.USER_SYSTEM) {
            // Set the encryption password to default.
            updateEncryptionPassword(StorageManager.CRYPT_TYPE_DEFAULT, null);
            setCredentialRequiredToDecrypt(false);
        }

        onAfterChangingPassword(userHandle);
!!!10428421.java!!!	setLockScreenDisabled(inout disable : boolean, in userId : int) : void
        setBoolean(DISABLE_LOCKSCREEN_KEY, disable, userId);
!!!10428549.java!!!	isLockScreenDisabled(in userId : int) : boolean
        if (isSecure(userId)) {
            return false;
        }
        boolean disabledByDefault = mContext.getResources().getBoolean(
                com.android.internal.R.bool.config_disableLockscreenByDefault);
        boolean isSystemUser = UserManager.isSplitSystemUser() && userId == UserHandle.USER_SYSTEM;
        return getBoolean(DISABLE_LOCKSCREEN_KEY, false, userId)
                || (disabledByDefault && !isSystemUser);
!!!10428677.java!!!	saveLockPattern(inout pattern : List<LockPatternView.Cell>, in userId : int) : void
        this.saveLockPattern(pattern, null, userId);
!!!10428805.java!!!	saveLockPattern(inout pattern : List<LockPatternView.Cell>, in savedPattern : String, in userId : int) : void
        try {
            if (pattern == null || pattern.size() < MIN_LOCK_PATTERN_SIZE) {
                throw new IllegalArgumentException("pattern must not be null and at least "
                        + MIN_LOCK_PATTERN_SIZE + " dots long.");
            }

            setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_SOMETHING, userId);
            getLockSettings().setLockCredential(patternToString(pattern), CREDENTIAL_TYPE_PATTERN,
                    savedPattern, userId);

            // Update the device encryption password.
            if (userId == UserHandle.USER_SYSTEM
                    && LockPatternUtils.isDeviceEncryptionEnabled()) {
                if (!shouldEncryptWithCredentials(true)) {
                    clearEncryptionPassword();
                } else {
                    String stringPattern = patternToString(pattern);
                    updateEncryptionPassword(StorageManager.CRYPT_TYPE_PATTERN, stringPattern);
                }
            }

            setBoolean(PATTERN_EVER_CHOSEN_KEY, true, userId);
            onAfterChangingPassword(userId);
        } catch (RemoteException re) {
            Log.e(TAG, "Couldn't save lock pattern " + re);
        }
!!!10428933.java!!!	updateCryptoUserInfo(in userId : int) : void
        if (userId != UserHandle.USER_SYSTEM) {
            return;
        }

        final String ownerInfo = isOwnerInfoEnabled(userId) ? getOwnerInfo(userId) : "";

        IBinder service = ServiceManager.getService("mount");
        if (service == null) {
            Log.e(TAG, "Could not find the mount service to update the user info");
            return;
        }

        IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
        try {
            Log.d(TAG, "Setting owner info");
            storageManager.setField(StorageManager.OWNER_INFO_KEY, ownerInfo);
        } catch (RemoteException e) {
            Log.e(TAG, "Error changing user info", e);
        }
!!!10429061.java!!!	setOwnerInfo(in info : String, in userId : int) : void
        setString(LOCK_SCREEN_OWNER_INFO, info, userId);
        updateCryptoUserInfo(userId);
!!!10429189.java!!!	setOwnerInfoEnabled(inout enabled : boolean, in userId : int) : void
        setBoolean(LOCK_SCREEN_OWNER_INFO_ENABLED, enabled, userId);
        updateCryptoUserInfo(userId);
!!!10429317.java!!!	getOwnerInfo(in userId : int) : String
        return getString(LOCK_SCREEN_OWNER_INFO, userId);
!!!10429445.java!!!	isOwnerInfoEnabled(in userId : int) : boolean
        return getBoolean(LOCK_SCREEN_OWNER_INFO_ENABLED, false, userId);
!!!10429573.java!!!	setDeviceOwnerInfo(in info : String) : void
        if (info != null && info.isEmpty()) {
            info = null;
        }

        setString(LOCK_SCREEN_DEVICE_OWNER_INFO, info, UserHandle.USER_SYSTEM);
!!!10429701.java!!!	getDeviceOwnerInfo() : String
        return getString(LOCK_SCREEN_DEVICE_OWNER_INFO, UserHandle.USER_SYSTEM);
!!!10429829.java!!!	isDeviceOwnerInfoEnabled() : boolean
        return getDeviceOwnerInfo() != null;
!!!10429957.java!!!	updateEncryptionPassword(in type : int, in password : String) : void
        if (!isDeviceEncryptionEnabled()) {
            return;
        }
        final IBinder service = ServiceManager.getService("mount");
        if (service == null) {
            Log.e(TAG, "Could not find the mount service to update the encryption password");
            return;
        }

        new AsyncTask<Void, Void, Void>() {
            @Override
            protected Void doInBackground(Void... dummy) {
                IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
                try {
                    storageManager.changeEncryptionPassword(type, password);
                } catch (RemoteException e) {
                    Log.e(TAG, "Error changing encryption password", e);
                }
                return null;
            }
        }.execute();
!!!10430085.java!!!	saveLockPassword(in password : String, in savedPassword : String, in quality : int, in userHandle : int) : void
        try {
            if (password == null || password.length() < MIN_LOCK_PASSWORD_SIZE) {
                throw new IllegalArgumentException("password must not be null and at least "
                        + "of length " + MIN_LOCK_PASSWORD_SIZE);
            }

            final int computedQuality = PasswordMetrics.computeForPassword(password).quality;
            setLong(PASSWORD_TYPE_KEY, Math.max(quality, computedQuality), userHandle);
            getLockSettings().setLockCredential(password, CREDENTIAL_TYPE_PASSWORD, savedPassword,
                    userHandle);

            updateEncryptionPasswordIfNeeded(password, computedQuality, userHandle);
            updatePasswordHistory(password, userHandle);
        } catch (RemoteException re) {
            // Cant do much
            Log.e(TAG, "Unable to save lock password " + re);
        }
!!!10430213.java!!!	updateEncryptionPasswordIfNeeded(in password : String, in quality : int, in userHandle : int) : void
        // Update the device encryption password.
        if (userHandle == UserHandle.USER_SYSTEM
                && LockPatternUtils.isDeviceEncryptionEnabled()) {
            if (!shouldEncryptWithCredentials(true)) {
                clearEncryptionPassword();
            } else {
                boolean numeric = quality == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC;
                boolean numericComplex = quality
                        == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX;
                int type = numeric || numericComplex ? StorageManager.CRYPT_TYPE_PIN
                        : StorageManager.CRYPT_TYPE_PASSWORD;
                updateEncryptionPassword(type, password);
            }
        }
!!!10430341.java!!!	updatePasswordHistory(in password : String, in userHandle : int) : void

        // Add the password to the password history. We assume all
        // password hashes have the same length for simplicity of implementation.
        String passwordHistory = getString(PASSWORD_HISTORY_KEY, userHandle);
        if (passwordHistory == null) {
            passwordHistory = "";
        }
        int passwordHistoryLength = getRequestedPasswordHistoryLength(userHandle);
        if (passwordHistoryLength == 0) {
            passwordHistory = "";
        } else {
            byte[] hash = passwordToHash(password, userHandle);
            passwordHistory = new String(hash, StandardCharsets.UTF_8) + "," + passwordHistory;
            // Cut it to contain passwordHistoryLength hashes
            // and passwordHistoryLength -1 commas.
            passwordHistory = passwordHistory.substring(0, Math.min(hash.length
                    * passwordHistoryLength + passwordHistoryLength - 1, passwordHistory
                    .length()));
        }
        setString(PASSWORD_HISTORY_KEY, passwordHistory, userHandle);
        onAfterChangingPassword(userHandle);
!!!10430469.java!!!	isDeviceEncryptionEnabled() : boolean
        return StorageManager.isEncrypted();
!!!10430597.java!!!	isFileEncryptionEnabled() : boolean
        return StorageManager.isFileEncryptedNativeOrEmulated();
!!!10430725.java!!!	clearEncryptionPassword() : void
        updateEncryptionPassword(StorageManager.CRYPT_TYPE_DEFAULT, null);
!!!10430853.java!!!	getKeyguardStoredPasswordQuality(in userHandle : int) : int
        return (int) getLong(PASSWORD_TYPE_KEY,
                DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED, userHandle);
!!!10430981.java!!!	setSeparateProfileChallengeEnabled(in userHandle : int, inout enabled : boolean, in managedUserPassword : String) : void
        UserInfo info = getUserManager().getUserInfo(userHandle);
        if (info.isManagedProfile()) {
            try {
                getLockSettings().setSeparateProfileChallengeEnabled(userHandle, enabled,
                        managedUserPassword);
                onAfterChangingPassword(userHandle);
            } catch (RemoteException e) {
                Log.e(TAG, "Couldn't update work profile challenge enabled");
            }
        }
!!!10431109.java!!!	isSeparateProfileChallengeEnabled(in userHandle : int) : boolean
        UserInfo info = getUserManager().getUserInfo(userHandle);
        if (info == null || !info.isManagedProfile()) {
            return false;
        }
        try {
            return getLockSettings().getSeparateProfileChallengeEnabled(userHandle);
        } catch (RemoteException e) {
            Log.e(TAG, "Couldn't get separate profile challenge enabled");
            // Default value is false
            return false;
        }
!!!10431237.java!!!	isSeparateProfileChallengeAllowed(in userHandle : int) : boolean
        UserInfo info = getUserManager().getUserInfo(userHandle);
        if (info == null || !info.isManagedProfile()) {
            return false;
        }
        return getDevicePolicyManager().isSeparateProfileChallengeAllowed(userHandle);
!!!10431365.java!!!	isSeparateProfileChallengeAllowedToUnify(in userHandle : int) : boolean
        return getDevicePolicyManager().isProfileActivePasswordSufficientForParent(userHandle);
!!!10431493.java!!!	stringToPattern(in string : String) : LockPatternView::Cell
        if (string == null) {
            return null;
        }

        List<LockPatternView.Cell> result = Lists.newArrayList();

        final byte[] bytes = string.getBytes();
        for (int i = 0; i < bytes.length; i++) {
            byte b = (byte) (bytes[i] - '1');
            result.add(LockPatternView.Cell.of(b / 3, b % 3));
        }
        return result;
!!!10431621.java!!!	patternToString(inout pattern : List<LockPatternView.Cell>) : String
        if (pattern == null) {
            return "";
        }
        final int patternSize = pattern.size();

        byte[] res = new byte[patternSize];
        for (int i = 0; i < patternSize; i++) {
            LockPatternView.Cell cell = pattern.get(i);
            res[i] = (byte) (cell.getRow() * 3 + cell.getColumn() + '1');
        }
        return new String(res);
!!!10431749.java!!!	patternStringToBaseZero(in pattern : String) : String
        if (pattern == null) {
            return "";
        }
        final int patternSize = pattern.length();

        byte[] res = new byte[patternSize];
        final byte[] bytes = pattern.getBytes();
        for (int i = 0; i < patternSize; i++) {
            res[i] = (byte) (bytes[i] - '1');
        }
        return new String(res);
!!!10431877.java!!!	patternToHash(inout pattern : List<LockPatternView.Cell>) : byte
        if (pattern == null) {
            return null;
        }

        final int patternSize = pattern.size();
        byte[] res = new byte[patternSize];
        for (int i = 0; i < patternSize; i++) {
            LockPatternView.Cell cell = pattern.get(i);
            res[i] = (byte) (cell.getRow() * 3 + cell.getColumn());
        }
        try {
            MessageDigest md = MessageDigest.getInstance("SHA-1");
            byte[] hash = md.digest(res);
            return hash;
        } catch (NoSuchAlgorithmException nsa) {
            return res;
        }
!!!10432005.java!!!	getSalt(in userId : int) : String
        long salt = getLong(LOCK_PASSWORD_SALT_KEY, 0, userId);
        if (salt == 0) {
            try {
                salt = SecureRandom.getInstance("SHA1PRNG").nextLong();
                setLong(LOCK_PASSWORD_SALT_KEY, salt, userId);
                Log.v(TAG, "Initialized lock password salt for user: " + userId);
            } catch (NoSuchAlgorithmException e) {
                // Throw an exception rather than storing a password we'll never be able to recover
                throw new IllegalStateException("Couldn't get SecureRandom number", e);
            }
        }
        return Long.toHexString(salt);
!!!10432133.java!!!	passwordToHash(in password : String, in userId : int) : byte
        if (password == null) {
            return null;
        }

        try {
            byte[] saltedPassword = (password + getSalt(userId)).getBytes();
            byte[] sha1 = MessageDigest.getInstance("SHA-1").digest(saltedPassword);
            byte[] md5 = MessageDigest.getInstance("MD5").digest(saltedPassword);

            byte[] combined = new byte[sha1.length + md5.length];
            System.arraycopy(sha1, 0, combined, 0, sha1.length);
            System.arraycopy(md5, 0, combined, sha1.length, md5.length);

            final char[] hexEncoded = HexEncoding.encode(combined);
            return new String(hexEncoded).getBytes(StandardCharsets.UTF_8);
        } catch (NoSuchAlgorithmException e) {
            throw new AssertionError("Missing digest algorithm: ", e);
        }
!!!10432261.java!!!	isSecure(in userId : int) : boolean
        int mode = getKeyguardStoredPasswordQuality(userId);
        return isLockPatternEnabled(mode, userId) || isLockPasswordEnabled(mode, userId);
!!!10432389.java!!!	isLockPasswordEnabled(in userId : int) : boolean
        return isLockPasswordEnabled(getKeyguardStoredPasswordQuality(userId), userId);
!!!10432517.java!!!	isLockPasswordEnabled(in mode : int, in userId : int) : boolean
        final boolean passwordEnabled = mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHABETIC
                || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC
                || mode == DevicePolicyManager.PASSWORD_QUALITY_NUMERIC_COMPLEX
                || mode == DevicePolicyManager.PASSWORD_QUALITY_ALPHANUMERIC
                || mode == DevicePolicyManager.PASSWORD_QUALITY_COMPLEX
                || mode == DevicePolicyManager.PASSWORD_QUALITY_MANAGED;
        return passwordEnabled && savedPasswordExists(userId);
!!!10432645.java!!!	isLockPatternEnabled(in userId : int) : boolean
        return isLockPatternEnabled(getKeyguardStoredPasswordQuality(userId), userId);
!!!10432773.java!!!	isLegacyLockPatternEnabled(in userId : int) : boolean
        // Note: this value should default to {@code true} to avoid any reset that might result.
        // We must use a special key to read this value, since it will by default return the value
        // based on the new logic.
        return getBoolean(LEGACY_LOCK_PATTERN_ENABLED, true, userId);
!!!10432901.java!!!	setLegacyLockPatternEnabled(in userId : int) : void
        setBoolean(Settings.Secure.LOCK_PATTERN_ENABLED, true, userId);
!!!10433029.java!!!	isLockPatternEnabled(in mode : int, in userId : int) : boolean
        return mode == DevicePolicyManager.PASSWORD_QUALITY_SOMETHING
                && savedPatternExists(userId);
!!!10433157.java!!!	isVisiblePatternEnabled(in userId : int) : boolean
        return getBoolean(Settings.Secure.LOCK_PATTERN_VISIBLE, false, userId);
!!!10433285.java!!!	setVisiblePatternEnabled(inout enabled : boolean, in userId : int) : void
        setBoolean(Settings.Secure.LOCK_PATTERN_VISIBLE, enabled, userId);

        // Update for crypto if owner
        if (userId != UserHandle.USER_SYSTEM) {
            return;
        }

        IBinder service = ServiceManager.getService("mount");
        if (service == null) {
            Log.e(TAG, "Could not find the mount service to update the user info");
            return;
        }

        IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
        try {
            storageManager.setField(StorageManager.PATTERN_VISIBLE_KEY, enabled ? "1" : "0");
        } catch (RemoteException e) {
            Log.e(TAG, "Error changing pattern visible state", e);
        }
!!!10433413.java!!!	setVisiblePasswordEnabled(inout enabled : boolean, in userId : int) : void
        // Update for crypto if owner
        if (userId != UserHandle.USER_SYSTEM) {
            return;
        }

        IBinder service = ServiceManager.getService("mount");
        if (service == null) {
            Log.e(TAG, "Could not find the mount service to update the user info");
            return;
        }

        IStorageManager storageManager = IStorageManager.Stub.asInterface(service);
        try {
            storageManager.setField(StorageManager.PASSWORD_VISIBLE_KEY, enabled ? "1" : "0");
        } catch (RemoteException e) {
            Log.e(TAG, "Error changing password visible state", e);
        }
!!!10433541.java!!!	isTactileFeedbackEnabled() : boolean
        return Settings.System.getIntForUser(mContentResolver,
                Settings.System.HAPTIC_FEEDBACK_ENABLED, 1, UserHandle.USER_CURRENT) != 0;
!!!10433669.java!!!	setLockoutAttemptDeadline(in userId : int, in timeoutMs : int) : long
        final long deadline = SystemClock.elapsedRealtime() + timeoutMs;
        setLong(LOCKOUT_ATTEMPT_DEADLINE, deadline, userId);
        setLong(LOCKOUT_ATTEMPT_TIMEOUT_MS, timeoutMs, userId);
        return deadline;
!!!10433797.java!!!	getLockoutAttemptDeadline(in userId : int) : long
        long deadline = getLong(LOCKOUT_ATTEMPT_DEADLINE, 0L, userId);
        final long timeoutMs = getLong(LOCKOUT_ATTEMPT_TIMEOUT_MS, 0L, userId);
        final long now = SystemClock.elapsedRealtime();
        if (deadline < now && deadline != 0) {
            // timeout expired
            setLong(LOCKOUT_ATTEMPT_DEADLINE, 0, userId);
            setLong(LOCKOUT_ATTEMPT_TIMEOUT_MS, 0, userId);
            return 0L;
        }

        if (deadline > (now + timeoutMs)) {
            // device was rebooted, set new deadline
            deadline = now + timeoutMs;
            setLong(LOCKOUT_ATTEMPT_DEADLINE, deadline, userId);
        }

        return deadline;
!!!10433925.java!!!	getBoolean(in secureSettingKey : String, inout defaultValue : boolean, in userId : int) : boolean
        try {
            return getLockSettings().getBoolean(secureSettingKey, defaultValue, userId);
        } catch (RemoteException re) {
            return defaultValue;
        }
!!!10434053.java!!!	setBoolean(in secureSettingKey : String, inout enabled : boolean, in userId : int) : void
        try {
            getLockSettings().setBoolean(secureSettingKey, enabled, userId);
        } catch (RemoteException re) {
            // What can we do?
            Log.e(TAG, "Couldn't write boolean " + secureSettingKey + re);
        }
!!!10434181.java!!!	getLong(in secureSettingKey : String, in defaultValue : long, in userHandle : int) : long
        try {
            return getLockSettings().getLong(secureSettingKey, defaultValue, userHandle);
        } catch (RemoteException re) {
            return defaultValue;
        }
!!!10434309.java!!!	setLong(in secureSettingKey : String, in value : long, in userHandle : int) : void
        try {
            getLockSettings().setLong(secureSettingKey, value, userHandle);
        } catch (RemoteException re) {
            // What can we do?
            Log.e(TAG, "Couldn't write long " + secureSettingKey + re);
        }
!!!10434437.java!!!	getString(in secureSettingKey : String, in userHandle : int) : String
        try {
            return getLockSettings().getString(secureSettingKey, null, userHandle);
        } catch (RemoteException re) {
            return null;
        }
!!!10434565.java!!!	setString(in secureSettingKey : String, in value : String, in userHandle : int) : void
        try {
            getLockSettings().setString(secureSettingKey, value, userHandle);
        } catch (RemoteException re) {
            // What can we do?
            Log.e(TAG, "Couldn't write string " + secureSettingKey + re);
        }
!!!10434693.java!!!	setPowerButtonInstantlyLocks(inout enabled : boolean, in userId : int) : void
        setBoolean(LOCKSCREEN_POWER_BUTTON_INSTANTLY_LOCKS, enabled, userId);
!!!10434821.java!!!	getPowerButtonInstantlyLocks(in userId : int) : boolean
        return getBoolean(LOCKSCREEN_POWER_BUTTON_INSTANTLY_LOCKS, true, userId);
!!!10434949.java!!!	setEnabledTrustAgents(inout activeTrustAgents : Collection<ComponentName>, in userId : int) : void
        StringBuilder sb = new StringBuilder();
        for (ComponentName cn : activeTrustAgents) {
            if (sb.length() > 0) {
                sb.append(',');
            }
            sb.append(cn.flattenToShortString());
        }
        setString(ENABLED_TRUST_AGENTS, sb.toString(), userId);
        getTrustManager().reportEnabledTrustAgentsChanged(userId);
!!!10435077.java!!!	getEnabledTrustAgents(in userId : int) : ComponentName
        String serialized = getString(ENABLED_TRUST_AGENTS, userId);
        if (TextUtils.isEmpty(serialized)) {
            return null;
        }
        String[] split = serialized.split(",");
        ArrayList<ComponentName> activeTrustAgents = new ArrayList<ComponentName>(split.length);
        for (String s : split) {
            if (!TextUtils.isEmpty(s)) {
                activeTrustAgents.add(ComponentName.unflattenFromString(s));
            }
        }
        return activeTrustAgents;
!!!10435205.java!!!	requireCredentialEntry(in userId : int) : void
        requireStrongAuth(StrongAuthTracker.SOME_AUTH_REQUIRED_AFTER_USER_REQUEST, userId);
!!!10435333.java!!!	requireStrongAuth(in strongAuthReason : int, in userId : int) : void
        try {
            getLockSettings().requireStrongAuth(strongAuthReason, userId);
        } catch (RemoteException e) {
            Log.e(TAG, "Error while requesting strong auth: " + e);
        }
!!!10435461.java!!!	onAfterChangingPassword(in userHandle : int) : void
        getTrustManager().reportEnabledTrustAgentsChanged(userHandle);
!!!10435589.java!!!	isCredentialRequiredToDecrypt(inout defaultValue : boolean) : boolean
        final int value = Settings.Global.getInt(mContentResolver,
                Settings.Global.REQUIRE_PASSWORD_TO_DECRYPT, -1);
        return value == -1 ? defaultValue : (value != 0);
!!!10435717.java!!!	setCredentialRequiredToDecrypt(inout required : boolean) : void
        if (!(getUserManager().isSystemUser() || getUserManager().isPrimaryUser())) {
            throw new IllegalStateException(
                    "Only the system or primary user may call setCredentialRequiredForDecrypt()");
        }

        if (isDeviceEncryptionEnabled()){
            Settings.Global.putInt(mContext.getContentResolver(),
               Settings.Global.REQUIRE_PASSWORD_TO_DECRYPT, required ? 1 : 0);
        }
!!!10435845.java!!!	isDoNotAskCredentialsOnBootSet() : boolean
        return getDevicePolicyManager().getDoNotAskCredentialsOnBoot();
!!!10435973.java!!!	shouldEncryptWithCredentials(inout defaultValue : boolean) : boolean
        return isCredentialRequiredToDecrypt(defaultValue) && !isDoNotAskCredentialsOnBootSet();
!!!10436101.java!!!	throwIfCalledOnMainThread() : void
        if (Looper.getMainLooper().isCurrentThread()) {
            throw new IllegalStateException("should not be called from the main thread.");
        }
!!!10436229.java!!!	registerStrongAuthTracker(in strongAuthTracker : LockPatternUtils::StrongAuthTracker) : void
        try {
            getLockSettings().registerStrongAuthTracker(strongAuthTracker.mStub);
        } catch (RemoteException e) {
            throw new RuntimeException("Could not register StrongAuthTracker");
        }
!!!10436357.java!!!	unregisterStrongAuthTracker(in strongAuthTracker : LockPatternUtils::StrongAuthTracker) : void
        try {
            getLockSettings().unregisterStrongAuthTracker(strongAuthTracker.mStub);
        } catch (RemoteException e) {
            Log.e(TAG, "Could not unregister StrongAuthTracker", e);
        }
!!!10436485.java!!!	getStrongAuthForUser(in userId : int) : int
        try {
            return getLockSettings().getStrongAuthForUser(userId);
        } catch (RemoteException e) {
            Log.e(TAG, "Could not get StrongAuth", e);
            return StrongAuthTracker.getDefaultFlags(mContext);
        }
!!!10436613.java!!!	isTrustAllowedForUser(in userId : int) : boolean
        return getStrongAuthForUser(userId) == StrongAuthTracker.STRONG_AUTH_NOT_REQUIRED;
!!!10436741.java!!!	isFingerprintAllowedForUser(in userId : int) : boolean
        return (getStrongAuthForUser(userId) & ~StrongAuthTracker.ALLOWING_FINGERPRINT) == 0;
!!!10436869.java!!!	wrapCallback(in callback : LockPatternUtils::CheckCredentialProgressCallback) : ICheckCredentialProgressCallback
        if (callback == null) {
            return null;
        } else {
            if (mHandler == null) {
                throw new IllegalStateException("Must construct LockPatternUtils on a looper thread"
                        + " to use progress callbacks.");
            }
            return new ICheckCredentialProgressCallback.Stub() {

                @Override
                public void onCredentialVerified() throws RemoteException {
                    mHandler.post(callback::onEarlyMatched);
                }
            };
        }
!!!10436997.java!!!	addEscrowToken(inout token : byte [[]], in userId : int) : long
        try {
            return getLockSettings().addEscrowToken(token, userId);
        } catch (RemoteException re) {
            return 0L;
        }
!!!10437125.java!!!	removeEscrowToken(in handle : long, in userId : int) : boolean
        try {
            return getLockSettings().removeEscrowToken(handle, userId);
        } catch (RemoteException re) {
            return false;
        }
!!!10437253.java!!!	isEscrowTokenActive(in handle : long, in userId : int) : boolean
        try {
            return getLockSettings().isEscrowTokenActive(handle, userId);
        } catch (RemoteException re) {
            return false;
        }
!!!10437381.java!!!	setLockCredentialWithToken(in credential : String, in type : int, in tokenHandle : long, inout token : byte [[]], in userId : int) : boolean
        try {
            if (type != CREDENTIAL_TYPE_NONE) {
                if (TextUtils.isEmpty(credential) || credential.length() < MIN_LOCK_PASSWORD_SIZE) {
                    throw new IllegalArgumentException("password must not be null and at least "
                            + "of length " + MIN_LOCK_PASSWORD_SIZE);
                }

                final int computedQuality = PasswordMetrics.computeForPassword(credential).quality;
                if (!getLockSettings().setLockCredentialWithToken(credential, type, tokenHandle,
                        token, userId)) {
                    return false;
                }
                setLong(PASSWORD_TYPE_KEY, Math.max(DevicePolicyManager.PASSWORD_QUALITY_NUMERIC,
                        computedQuality), userId);

                updateEncryptionPasswordIfNeeded(credential, computedQuality, userId);
                updatePasswordHistory(credential, userId);
            } else {
                if (!TextUtils.isEmpty(credential)) {
                    throw new IllegalArgumentException("password must be emtpy for NONE type");
                }
                if (!getLockSettings().setLockCredentialWithToken(null, CREDENTIAL_TYPE_NONE,
                        tokenHandle, token, userId)) {
                    return false;
                }
                setLong(PASSWORD_TYPE_KEY, DevicePolicyManager.PASSWORD_QUALITY_UNSPECIFIED,
                        userId);

                if (userId == UserHandle.USER_SYSTEM) {
                    // Set the encryption password to default.
                    updateEncryptionPassword(StorageManager.CRYPT_TYPE_DEFAULT, null);
                    setCredentialRequiredToDecrypt(false);
                }
            }
            onAfterChangingPassword(userId);
            return true;
        } catch (RemoteException re) {
            Log.e(TAG, "Unable to save lock password ", re);
            re.rethrowFromSystemServer();
        }
        return false;
!!!10437509.java!!!	unlockUserWithToken(in tokenHandle : long, inout token : byte [[]], in userId : int) : void
        try {
            getLockSettings().unlockUserWithToken(tokenHandle, token, userId);
        } catch (RemoteException re) {
            Log.e(TAG, "Unable to unlock user with token", re);
            re.rethrowFromSystemServer();
        }
!!!10439045.java!!!	enableSyntheticPassword() : void
        setLong(SYNTHETIC_PASSWORD_ENABLED_KEY, 1L, UserHandle.USER_SYSTEM);
!!!10439173.java!!!	isSyntheticPasswordEnabled() : boolean
        return getLong(SYNTHETIC_PASSWORD_ENABLED_KEY, 0, UserHandle.USER_SYSTEM) != 0;
